// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $JurisdictionsTable extends Jurisdictions
    with d.TableInfo<$JurisdictionsTable, Jurisdiction> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $JurisdictionsTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nameEnMeta =
      const d.VerificationMeta('nameEn');
  @override
  late final d.GeneratedColumn<String> nameEn = d.GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const d.VerificationMeta _nameFrMeta =
      const d.VerificationMeta('nameFr');
  @override
  late final d.GeneratedColumn<String> nameFr = d.GeneratedColumn<String>(
      'name_fr', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  @override
  List<d.GeneratedColumn> get $columns => [code, nameEn, nameFr];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'jurisdictions';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<Jurisdiction> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('name_fr')) {
      context.handle(_nameFrMeta,
          nameFr.isAcceptableOrUnknown(data['name_fr']!, _nameFrMeta));
    } else if (isInserting) {
      context.missing(_nameFrMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {code};
  @override
  Jurisdiction map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Jurisdiction(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      nameFr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_fr'])!,
    );
  }

  @override
  $JurisdictionsTable createAlias(String alias) {
    return $JurisdictionsTable(attachedDatabase, alias);
  }
}

class Jurisdiction extends d.DataClass implements d.Insertable<Jurisdiction> {
  final String code;
  final String nameEn;
  final String nameFr;
  const Jurisdiction(
      {required this.code, required this.nameEn, required this.nameFr});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name_en'] = d.Variable<String>(nameEn);
    map['name_fr'] = d.Variable<String>(nameFr);
    return map;
  }

  JurisdictionsCompanion toCompanion(bool nullToAbsent) {
    return JurisdictionsCompanion(
      code: d.Value(code),
      nameEn: d.Value(nameEn),
      nameFr: d.Value(nameFr),
    );
  }

  factory Jurisdiction.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return Jurisdiction(
      code: serializer.fromJson<String>(json['code']),
      nameEn: serializer.fromJson<String>(json['nameEn']),
      nameFr: serializer.fromJson<String>(json['nameFr']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'nameEn': serializer.toJson<String>(nameEn),
      'nameFr': serializer.toJson<String>(nameFr),
    };
  }

  Jurisdiction copyWith({String? code, String? nameEn, String? nameFr}) =>
      Jurisdiction(
        code: code ?? this.code,
        nameEn: nameEn ?? this.nameEn,
        nameFr: nameFr ?? this.nameFr,
      );
  @override
  String toString() {
    return (StringBuffer('Jurisdiction(')
          ..write('code: $code, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, nameEn, nameFr);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Jurisdiction &&
          other.code == this.code &&
          other.nameEn == this.nameEn &&
          other.nameFr == this.nameFr);
}

class JurisdictionsCompanion extends d.UpdateCompanion<Jurisdiction> {
  final d.Value<String> code;
  final d.Value<String> nameEn;
  final d.Value<String> nameFr;
  final d.Value<int> rowid;
  const JurisdictionsCompanion({
    this.code = const d.Value.absent(),
    this.nameEn = const d.Value.absent(),
    this.nameFr = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  JurisdictionsCompanion.insert({
    required String code,
    required String nameEn,
    required String nameFr,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        nameEn = d.Value(nameEn),
        nameFr = d.Value(nameFr);
  static d.Insertable<Jurisdiction> custom({
    d.Expression<String>? code,
    d.Expression<String>? nameEn,
    d.Expression<String>? nameFr,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (nameEn != null) 'name_en': nameEn,
      if (nameFr != null) 'name_fr': nameFr,
      if (rowid != null) 'rowid': rowid,
    });
  }

  JurisdictionsCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? nameEn,
      d.Value<String>? nameFr,
      d.Value<int>? rowid}) {
    return JurisdictionsCompanion(
      code: code ?? this.code,
      nameEn: nameEn ?? this.nameEn,
      nameFr: nameFr ?? this.nameFr,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (nameEn.present) {
      map['name_en'] = d.Variable<String>(nameEn.value);
    }
    if (nameFr.present) {
      map['name_fr'] = d.Variable<String>(nameFr.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('JurisdictionsCompanion(')
          ..write('code: $code, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PlotsTable extends Plots with d.TableInfo<$PlotsTable, Plot> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PlotsTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _nfiPlotMeta =
      const d.VerificationMeta('nfiPlot');
  @override
  late final d.GeneratedColumn<int> nfiPlot = d.GeneratedColumn<int>(
      'nfi_plot', aliasedName, false,
      check: () =>
          nfiPlot.isBetweenValues(1, 1600000) |
          nfiPlot.isBetweenValues(2000000, 2399999),
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES plots (nfi_plot)'));
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES jurisdictions (code)'));
  static const d.VerificationMeta _lastMeasNumMeta =
      const d.VerificationMeta('lastMeasNum');
  @override
  late final d.GeneratedColumn<int> lastMeasNum = d.GeneratedColumn<int>(
      'last_meas_num', aliasedName, true,
      check: () => lastMeasNum.isBetweenValues(0, 999),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [nfiPlot, code, lastMeasNum];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'plots';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<Plot> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('nfi_plot')) {
      context.handle(_nfiPlotMeta,
          nfiPlot.isAcceptableOrUnknown(data['nfi_plot']!, _nfiPlotMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('last_meas_num')) {
      context.handle(
          _lastMeasNumMeta,
          lastMeasNum.isAcceptableOrUnknown(
              data['last_meas_num']!, _lastMeasNumMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {nfiPlot};
  @override
  Plot map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Plot(
      nfiPlot: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nfi_plot'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      lastMeasNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_meas_num']),
    );
  }

  @override
  $PlotsTable createAlias(String alias) {
    return $PlotsTable(attachedDatabase, alias);
  }
}

class Plot extends d.DataClass implements d.Insertable<Plot> {
  final int nfiPlot;
  final String code;
  final int? lastMeasNum;
  const Plot({required this.nfiPlot, required this.code, this.lastMeasNum});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['nfi_plot'] = d.Variable<int>(nfiPlot);
    map['code'] = d.Variable<String>(code);
    if (!nullToAbsent || lastMeasNum != null) {
      map['last_meas_num'] = d.Variable<int>(lastMeasNum);
    }
    return map;
  }

  PlotsCompanion toCompanion(bool nullToAbsent) {
    return PlotsCompanion(
      nfiPlot: d.Value(nfiPlot),
      code: d.Value(code),
      lastMeasNum: lastMeasNum == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(lastMeasNum),
    );
  }

  factory Plot.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return Plot(
      nfiPlot: serializer.fromJson<int>(json['nfiPlot']),
      code: serializer.fromJson<String>(json['code']),
      lastMeasNum: serializer.fromJson<int?>(json['lastMeasNum']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'nfiPlot': serializer.toJson<int>(nfiPlot),
      'code': serializer.toJson<String>(code),
      'lastMeasNum': serializer.toJson<int?>(lastMeasNum),
    };
  }

  Plot copyWith(
          {int? nfiPlot,
          String? code,
          d.Value<int?> lastMeasNum = const d.Value.absent()}) =>
      Plot(
        nfiPlot: nfiPlot ?? this.nfiPlot,
        code: code ?? this.code,
        lastMeasNum: lastMeasNum.present ? lastMeasNum.value : this.lastMeasNum,
      );
  @override
  String toString() {
    return (StringBuffer('Plot(')
          ..write('nfiPlot: $nfiPlot, ')
          ..write('code: $code, ')
          ..write('lastMeasNum: $lastMeasNum')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(nfiPlot, code, lastMeasNum);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Plot &&
          other.nfiPlot == this.nfiPlot &&
          other.code == this.code &&
          other.lastMeasNum == this.lastMeasNum);
}

class PlotsCompanion extends d.UpdateCompanion<Plot> {
  final d.Value<int> nfiPlot;
  final d.Value<String> code;
  final d.Value<int?> lastMeasNum;
  const PlotsCompanion({
    this.nfiPlot = const d.Value.absent(),
    this.code = const d.Value.absent(),
    this.lastMeasNum = const d.Value.absent(),
  });
  PlotsCompanion.insert({
    this.nfiPlot = const d.Value.absent(),
    required String code,
    this.lastMeasNum = const d.Value.absent(),
  }) : code = d.Value(code);
  static d.Insertable<Plot> custom({
    d.Expression<int>? nfiPlot,
    d.Expression<String>? code,
    d.Expression<int>? lastMeasNum,
  }) {
    return d.RawValuesInsertable({
      if (nfiPlot != null) 'nfi_plot': nfiPlot,
      if (code != null) 'code': code,
      if (lastMeasNum != null) 'last_meas_num': lastMeasNum,
    });
  }

  PlotsCompanion copyWith(
      {d.Value<int>? nfiPlot,
      d.Value<String>? code,
      d.Value<int?>? lastMeasNum}) {
    return PlotsCompanion(
      nfiPlot: nfiPlot ?? this.nfiPlot,
      code: code ?? this.code,
      lastMeasNum: lastMeasNum ?? this.lastMeasNum,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (nfiPlot.present) {
      map['nfi_plot'] = d.Variable<int>(nfiPlot.value);
    }
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (lastMeasNum.present) {
      map['last_meas_num'] = d.Variable<int>(lastMeasNum.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PlotsCompanion(')
          ..write('nfiPlot: $nfiPlot, ')
          ..write('code: $code, ')
          ..write('lastMeasNum: $lastMeasNum')
          ..write(')'))
        .toString();
  }
}

class $TreeGenusTable extends TreeGenus
    with d.TableInfo<$TreeGenusTable, TreeGenusData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TreeGenusTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _genusCodeMeta =
      const d.VerificationMeta('genusCode');
  @override
  late final d.GeneratedColumn<String> genusCode = d.GeneratedColumn<String>(
      'genus_code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 4, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _speciesCodeMeta =
      const d.VerificationMeta('speciesCode');
  @override
  late final d.GeneratedColumn<String> speciesCode = d.GeneratedColumn<String>(
      'species_code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _genusLatinNameMeta =
      const d.VerificationMeta('genusLatinName');
  @override
  late final d.GeneratedColumn<String> genusLatinName =
      d.GeneratedColumn<String>('genus_latin_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _speciesLatinNameMeta =
      const d.VerificationMeta('speciesLatinName');
  @override
  late final d.GeneratedColumn<String> speciesLatinName =
      d.GeneratedColumn<String>('species_latin_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _commonNameEnMeta =
      const d.VerificationMeta('commonNameEn');
  @override
  late final d.GeneratedColumn<String> commonNameEn = d.GeneratedColumn<String>(
      'common_name_en', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _commonNameFrMeta =
      const d.VerificationMeta('commonNameFr');
  @override
  late final d.GeneratedColumn<String> commonNameFr = d.GeneratedColumn<String>(
      'common_name_fr', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        genusCode,
        speciesCode,
        genusLatinName,
        speciesLatinName,
        commonNameEn,
        commonNameFr
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tree_genus';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<TreeGenusData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('genus_code')) {
      context.handle(_genusCodeMeta,
          genusCode.isAcceptableOrUnknown(data['genus_code']!, _genusCodeMeta));
    } else if (isInserting) {
      context.missing(_genusCodeMeta);
    }
    if (data.containsKey('species_code')) {
      context.handle(
          _speciesCodeMeta,
          speciesCode.isAcceptableOrUnknown(
              data['species_code']!, _speciesCodeMeta));
    } else if (isInserting) {
      context.missing(_speciesCodeMeta);
    }
    if (data.containsKey('genus_latin_name')) {
      context.handle(
          _genusLatinNameMeta,
          genusLatinName.isAcceptableOrUnknown(
              data['genus_latin_name']!, _genusLatinNameMeta));
    } else if (isInserting) {
      context.missing(_genusLatinNameMeta);
    }
    if (data.containsKey('species_latin_name')) {
      context.handle(
          _speciesLatinNameMeta,
          speciesLatinName.isAcceptableOrUnknown(
              data['species_latin_name']!, _speciesLatinNameMeta));
    } else if (isInserting) {
      context.missing(_speciesLatinNameMeta);
    }
    if (data.containsKey('common_name_en')) {
      context.handle(
          _commonNameEnMeta,
          commonNameEn.isAcceptableOrUnknown(
              data['common_name_en']!, _commonNameEnMeta));
    } else if (isInserting) {
      context.missing(_commonNameEnMeta);
    }
    if (data.containsKey('common_name_fr')) {
      context.handle(
          _commonNameFrMeta,
          commonNameFr.isAcceptableOrUnknown(
              data['common_name_fr']!, _commonNameFrMeta));
    } else if (isInserting) {
      context.missing(_commonNameFrMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {genusCode, speciesCode};
  @override
  TreeGenusData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TreeGenusData(
      genusCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus_code'])!,
      speciesCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species_code'])!,
      genusLatinName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}genus_latin_name'])!,
      speciesLatinName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}species_latin_name'])!,
      commonNameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}common_name_en'])!,
      commonNameFr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}common_name_fr'])!,
    );
  }

  @override
  $TreeGenusTable createAlias(String alias) {
    return $TreeGenusTable(attachedDatabase, alias);
  }
}

class TreeGenusData extends d.DataClass implements d.Insertable<TreeGenusData> {
  final String genusCode;
  final String speciesCode;
  final String genusLatinName;
  final String speciesLatinName;
  final String commonNameEn;
  final String commonNameFr;
  const TreeGenusData(
      {required this.genusCode,
      required this.speciesCode,
      required this.genusLatinName,
      required this.speciesLatinName,
      required this.commonNameEn,
      required this.commonNameFr});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['genus_code'] = d.Variable<String>(genusCode);
    map['species_code'] = d.Variable<String>(speciesCode);
    map['genus_latin_name'] = d.Variable<String>(genusLatinName);
    map['species_latin_name'] = d.Variable<String>(speciesLatinName);
    map['common_name_en'] = d.Variable<String>(commonNameEn);
    map['common_name_fr'] = d.Variable<String>(commonNameFr);
    return map;
  }

  TreeGenusCompanion toCompanion(bool nullToAbsent) {
    return TreeGenusCompanion(
      genusCode: d.Value(genusCode),
      speciesCode: d.Value(speciesCode),
      genusLatinName: d.Value(genusLatinName),
      speciesLatinName: d.Value(speciesLatinName),
      commonNameEn: d.Value(commonNameEn),
      commonNameFr: d.Value(commonNameFr),
    );
  }

  factory TreeGenusData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return TreeGenusData(
      genusCode: serializer.fromJson<String>(json['genusCode']),
      speciesCode: serializer.fromJson<String>(json['speciesCode']),
      genusLatinName: serializer.fromJson<String>(json['genusLatinName']),
      speciesLatinName: serializer.fromJson<String>(json['speciesLatinName']),
      commonNameEn: serializer.fromJson<String>(json['commonNameEn']),
      commonNameFr: serializer.fromJson<String>(json['commonNameFr']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'genusCode': serializer.toJson<String>(genusCode),
      'speciesCode': serializer.toJson<String>(speciesCode),
      'genusLatinName': serializer.toJson<String>(genusLatinName),
      'speciesLatinName': serializer.toJson<String>(speciesLatinName),
      'commonNameEn': serializer.toJson<String>(commonNameEn),
      'commonNameFr': serializer.toJson<String>(commonNameFr),
    };
  }

  TreeGenusData copyWith(
          {String? genusCode,
          String? speciesCode,
          String? genusLatinName,
          String? speciesLatinName,
          String? commonNameEn,
          String? commonNameFr}) =>
      TreeGenusData(
        genusCode: genusCode ?? this.genusCode,
        speciesCode: speciesCode ?? this.speciesCode,
        genusLatinName: genusLatinName ?? this.genusLatinName,
        speciesLatinName: speciesLatinName ?? this.speciesLatinName,
        commonNameEn: commonNameEn ?? this.commonNameEn,
        commonNameFr: commonNameFr ?? this.commonNameFr,
      );
  @override
  String toString() {
    return (StringBuffer('TreeGenusData(')
          ..write('genusCode: $genusCode, ')
          ..write('speciesCode: $speciesCode, ')
          ..write('genusLatinName: $genusLatinName, ')
          ..write('speciesLatinName: $speciesLatinName, ')
          ..write('commonNameEn: $commonNameEn, ')
          ..write('commonNameFr: $commonNameFr')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(genusCode, speciesCode, genusLatinName,
      speciesLatinName, commonNameEn, commonNameFr);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TreeGenusData &&
          other.genusCode == this.genusCode &&
          other.speciesCode == this.speciesCode &&
          other.genusLatinName == this.genusLatinName &&
          other.speciesLatinName == this.speciesLatinName &&
          other.commonNameEn == this.commonNameEn &&
          other.commonNameFr == this.commonNameFr);
}

class TreeGenusCompanion extends d.UpdateCompanion<TreeGenusData> {
  final d.Value<String> genusCode;
  final d.Value<String> speciesCode;
  final d.Value<String> genusLatinName;
  final d.Value<String> speciesLatinName;
  final d.Value<String> commonNameEn;
  final d.Value<String> commonNameFr;
  final d.Value<int> rowid;
  const TreeGenusCompanion({
    this.genusCode = const d.Value.absent(),
    this.speciesCode = const d.Value.absent(),
    this.genusLatinName = const d.Value.absent(),
    this.speciesLatinName = const d.Value.absent(),
    this.commonNameEn = const d.Value.absent(),
    this.commonNameFr = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  TreeGenusCompanion.insert({
    required String genusCode,
    required String speciesCode,
    required String genusLatinName,
    required String speciesLatinName,
    required String commonNameEn,
    required String commonNameFr,
    this.rowid = const d.Value.absent(),
  })  : genusCode = d.Value(genusCode),
        speciesCode = d.Value(speciesCode),
        genusLatinName = d.Value(genusLatinName),
        speciesLatinName = d.Value(speciesLatinName),
        commonNameEn = d.Value(commonNameEn),
        commonNameFr = d.Value(commonNameFr);
  static d.Insertable<TreeGenusData> custom({
    d.Expression<String>? genusCode,
    d.Expression<String>? speciesCode,
    d.Expression<String>? genusLatinName,
    d.Expression<String>? speciesLatinName,
    d.Expression<String>? commonNameEn,
    d.Expression<String>? commonNameFr,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (genusCode != null) 'genus_code': genusCode,
      if (speciesCode != null) 'species_code': speciesCode,
      if (genusLatinName != null) 'genus_latin_name': genusLatinName,
      if (speciesLatinName != null) 'species_latin_name': speciesLatinName,
      if (commonNameEn != null) 'common_name_en': commonNameEn,
      if (commonNameFr != null) 'common_name_fr': commonNameFr,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TreeGenusCompanion copyWith(
      {d.Value<String>? genusCode,
      d.Value<String>? speciesCode,
      d.Value<String>? genusLatinName,
      d.Value<String>? speciesLatinName,
      d.Value<String>? commonNameEn,
      d.Value<String>? commonNameFr,
      d.Value<int>? rowid}) {
    return TreeGenusCompanion(
      genusCode: genusCode ?? this.genusCode,
      speciesCode: speciesCode ?? this.speciesCode,
      genusLatinName: genusLatinName ?? this.genusLatinName,
      speciesLatinName: speciesLatinName ?? this.speciesLatinName,
      commonNameEn: commonNameEn ?? this.commonNameEn,
      commonNameFr: commonNameFr ?? this.commonNameFr,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (genusCode.present) {
      map['genus_code'] = d.Variable<String>(genusCode.value);
    }
    if (speciesCode.present) {
      map['species_code'] = d.Variable<String>(speciesCode.value);
    }
    if (genusLatinName.present) {
      map['genus_latin_name'] = d.Variable<String>(genusLatinName.value);
    }
    if (speciesLatinName.present) {
      map['species_latin_name'] = d.Variable<String>(speciesLatinName.value);
    }
    if (commonNameEn.present) {
      map['common_name_en'] = d.Variable<String>(commonNameEn.value);
    }
    if (commonNameFr.present) {
      map['common_name_fr'] = d.Variable<String>(commonNameFr.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TreeGenusCompanion(')
          ..write('genusCode: $genusCode, ')
          ..write('speciesCode: $speciesCode, ')
          ..write('genusLatinName: $genusLatinName, ')
          ..write('speciesLatinName: $speciesLatinName, ')
          ..write('commonNameEn: $commonNameEn, ')
          ..write('commonNameFr: $commonNameFr, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SubstrateTypeTable extends SubstrateType
    with d.TableInfo<$SubstrateTypeTable, SubstrateTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SubstrateTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _typeCodeMeta =
      const d.VerificationMeta('typeCode');
  @override
  late final d.GeneratedColumn<String> typeCode = d.GeneratedColumn<String>(
      'type_code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nameEnMeta =
      const d.VerificationMeta('nameEn');
  @override
  late final d.GeneratedColumn<String> nameEn = d.GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameFrMeta =
      const d.VerificationMeta('nameFr');
  @override
  late final d.GeneratedColumn<String> nameFr = d.GeneratedColumn<String>(
      'name_fr', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _hasDepthMeta =
      const d.VerificationMeta('hasDepth');
  @override
  late final d.GeneratedColumn<bool> hasDepth = d.GeneratedColumn<bool>(
      'has_depth', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("has_depth" IN (0, 1))'));
  @override
  List<d.GeneratedColumn> get $columns => [typeCode, nameEn, nameFr, hasDepth];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'substrate_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SubstrateTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('type_code')) {
      context.handle(_typeCodeMeta,
          typeCode.isAcceptableOrUnknown(data['type_code']!, _typeCodeMeta));
    } else if (isInserting) {
      context.missing(_typeCodeMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('name_fr')) {
      context.handle(_nameFrMeta,
          nameFr.isAcceptableOrUnknown(data['name_fr']!, _nameFrMeta));
    } else if (isInserting) {
      context.missing(_nameFrMeta);
    }
    if (data.containsKey('has_depth')) {
      context.handle(_hasDepthMeta,
          hasDepth.isAcceptableOrUnknown(data['has_depth']!, _hasDepthMeta));
    } else if (isInserting) {
      context.missing(_hasDepthMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {typeCode};
  @override
  SubstrateTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SubstrateTypeData(
      typeCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type_code'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      nameFr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_fr'])!,
      hasDepth: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}has_depth'])!,
    );
  }

  @override
  $SubstrateTypeTable createAlias(String alias) {
    return $SubstrateTypeTable(attachedDatabase, alias);
  }
}

class SubstrateTypeData extends d.DataClass
    implements d.Insertable<SubstrateTypeData> {
  final String typeCode;
  final String nameEn;
  final String nameFr;
  final bool hasDepth;
  const SubstrateTypeData(
      {required this.typeCode,
      required this.nameEn,
      required this.nameFr,
      required this.hasDepth});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['type_code'] = d.Variable<String>(typeCode);
    map['name_en'] = d.Variable<String>(nameEn);
    map['name_fr'] = d.Variable<String>(nameFr);
    map['has_depth'] = d.Variable<bool>(hasDepth);
    return map;
  }

  SubstrateTypeCompanion toCompanion(bool nullToAbsent) {
    return SubstrateTypeCompanion(
      typeCode: d.Value(typeCode),
      nameEn: d.Value(nameEn),
      nameFr: d.Value(nameFr),
      hasDepth: d.Value(hasDepth),
    );
  }

  factory SubstrateTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SubstrateTypeData(
      typeCode: serializer.fromJson<String>(json['typeCode']),
      nameEn: serializer.fromJson<String>(json['nameEn']),
      nameFr: serializer.fromJson<String>(json['nameFr']),
      hasDepth: serializer.fromJson<bool>(json['hasDepth']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'typeCode': serializer.toJson<String>(typeCode),
      'nameEn': serializer.toJson<String>(nameEn),
      'nameFr': serializer.toJson<String>(nameFr),
      'hasDepth': serializer.toJson<bool>(hasDepth),
    };
  }

  SubstrateTypeData copyWith(
          {String? typeCode, String? nameEn, String? nameFr, bool? hasDepth}) =>
      SubstrateTypeData(
        typeCode: typeCode ?? this.typeCode,
        nameEn: nameEn ?? this.nameEn,
        nameFr: nameFr ?? this.nameFr,
        hasDepth: hasDepth ?? this.hasDepth,
      );
  @override
  String toString() {
    return (StringBuffer('SubstrateTypeData(')
          ..write('typeCode: $typeCode, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr, ')
          ..write('hasDepth: $hasDepth')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(typeCode, nameEn, nameFr, hasDepth);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SubstrateTypeData &&
          other.typeCode == this.typeCode &&
          other.nameEn == this.nameEn &&
          other.nameFr == this.nameFr &&
          other.hasDepth == this.hasDepth);
}

class SubstrateTypeCompanion extends d.UpdateCompanion<SubstrateTypeData> {
  final d.Value<String> typeCode;
  final d.Value<String> nameEn;
  final d.Value<String> nameFr;
  final d.Value<bool> hasDepth;
  final d.Value<int> rowid;
  const SubstrateTypeCompanion({
    this.typeCode = const d.Value.absent(),
    this.nameEn = const d.Value.absent(),
    this.nameFr = const d.Value.absent(),
    this.hasDepth = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SubstrateTypeCompanion.insert({
    required String typeCode,
    required String nameEn,
    required String nameFr,
    required bool hasDepth,
    this.rowid = const d.Value.absent(),
  })  : typeCode = d.Value(typeCode),
        nameEn = d.Value(nameEn),
        nameFr = d.Value(nameFr),
        hasDepth = d.Value(hasDepth);
  static d.Insertable<SubstrateTypeData> custom({
    d.Expression<String>? typeCode,
    d.Expression<String>? nameEn,
    d.Expression<String>? nameFr,
    d.Expression<bool>? hasDepth,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (typeCode != null) 'type_code': typeCode,
      if (nameEn != null) 'name_en': nameEn,
      if (nameFr != null) 'name_fr': nameFr,
      if (hasDepth != null) 'has_depth': hasDepth,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SubstrateTypeCompanion copyWith(
      {d.Value<String>? typeCode,
      d.Value<String>? nameEn,
      d.Value<String>? nameFr,
      d.Value<bool>? hasDepth,
      d.Value<int>? rowid}) {
    return SubstrateTypeCompanion(
      typeCode: typeCode ?? this.typeCode,
      nameEn: nameEn ?? this.nameEn,
      nameFr: nameFr ?? this.nameFr,
      hasDepth: hasDepth ?? this.hasDepth,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (typeCode.present) {
      map['type_code'] = d.Variable<String>(typeCode.value);
    }
    if (nameEn.present) {
      map['name_en'] = d.Variable<String>(nameEn.value);
    }
    if (nameFr.present) {
      map['name_fr'] = d.Variable<String>(nameFr.value);
    }
    if (hasDepth.present) {
      map['has_depth'] = d.Variable<bool>(hasDepth.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SubstrateTypeCompanion(')
          ..write('typeCode: $typeCode, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr, ')
          ..write('hasDepth: $hasDepth, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SsDepthLimitTable extends SsDepthLimit
    with d.TableInfo<$SsDepthLimitTable, SsDepthLimitData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SsDepthLimitTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<int> code = d.GeneratedColumn<int>(
      'code', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const d.VerificationMeta _nameEnMeta =
      const d.VerificationMeta('nameEn');
  @override
  late final d.GeneratedColumn<String> nameEn = d.GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameFrMeta =
      const d.VerificationMeta('nameFr');
  @override
  late final d.GeneratedColumn<String> nameFr = d.GeneratedColumn<String>(
      'name_fr', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, nameEn, nameFr];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ss_depth_limit';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SsDepthLimitData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('name_fr')) {
      context.handle(_nameFrMeta,
          nameFr.isAcceptableOrUnknown(data['name_fr']!, _nameFrMeta));
    } else if (isInserting) {
      context.missing(_nameFrMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SsDepthLimitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SsDepthLimitData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}code'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      nameFr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_fr'])!,
    );
  }

  @override
  $SsDepthLimitTable createAlias(String alias) {
    return $SsDepthLimitTable(attachedDatabase, alias);
  }
}

class SsDepthLimitData extends d.DataClass
    implements d.Insertable<SsDepthLimitData> {
  final int code;
  final String nameEn;
  final String nameFr;
  const SsDepthLimitData(
      {required this.code, required this.nameEn, required this.nameFr});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<int>(code);
    map['name_en'] = d.Variable<String>(nameEn);
    map['name_fr'] = d.Variable<String>(nameFr);
    return map;
  }

  SsDepthLimitCompanion toCompanion(bool nullToAbsent) {
    return SsDepthLimitCompanion(
      code: d.Value(code),
      nameEn: d.Value(nameEn),
      nameFr: d.Value(nameFr),
    );
  }

  factory SsDepthLimitData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SsDepthLimitData(
      code: serializer.fromJson<int>(json['code']),
      nameEn: serializer.fromJson<String>(json['nameEn']),
      nameFr: serializer.fromJson<String>(json['nameFr']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<int>(code),
      'nameEn': serializer.toJson<String>(nameEn),
      'nameFr': serializer.toJson<String>(nameFr),
    };
  }

  SsDepthLimitData copyWith({int? code, String? nameEn, String? nameFr}) =>
      SsDepthLimitData(
        code: code ?? this.code,
        nameEn: nameEn ?? this.nameEn,
        nameFr: nameFr ?? this.nameFr,
      );
  @override
  String toString() {
    return (StringBuffer('SsDepthLimitData(')
          ..write('code: $code, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, nameEn, nameFr);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SsDepthLimitData &&
          other.code == this.code &&
          other.nameEn == this.nameEn &&
          other.nameFr == this.nameFr);
}

class SsDepthLimitCompanion extends d.UpdateCompanion<SsDepthLimitData> {
  final d.Value<int> code;
  final d.Value<String> nameEn;
  final d.Value<String> nameFr;
  final d.Value<int> rowid;
  const SsDepthLimitCompanion({
    this.code = const d.Value.absent(),
    this.nameEn = const d.Value.absent(),
    this.nameFr = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SsDepthLimitCompanion.insert({
    required int code,
    required String nameEn,
    required String nameFr,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        nameEn = d.Value(nameEn),
        nameFr = d.Value(nameFr);
  static d.Insertable<SsDepthLimitData> custom({
    d.Expression<int>? code,
    d.Expression<String>? nameEn,
    d.Expression<String>? nameFr,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (nameEn != null) 'name_en': nameEn,
      if (nameFr != null) 'name_fr': nameFr,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SsDepthLimitCompanion copyWith(
      {d.Value<int>? code,
      d.Value<String>? nameEn,
      d.Value<String>? nameFr,
      d.Value<int>? rowid}) {
    return SsDepthLimitCompanion(
      code: code ?? this.code,
      nameEn: nameEn ?? this.nameEn,
      nameFr: nameFr ?? this.nameFr,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<int>(code.value);
    }
    if (nameEn.present) {
      map['name_en'] = d.Variable<String>(nameEn.value);
    }
    if (nameFr.present) {
      map['name_fr'] = d.Variable<String>(nameFr.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SsDepthLimitCompanion(')
          ..write('code: $code, ')
          ..write('nameEn: $nameEn, ')
          ..write('nameFr: $nameFr, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EcpGenusTable extends EcpGenus
    with d.TableInfo<$EcpGenusTable, EcpGenusData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpGenusTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _genusMeta =
      const d.VerificationMeta('genus');
  @override
  late final d.GeneratedColumn<String> genus = d.GeneratedColumn<String>(
      'genus', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _speciesMeta =
      const d.VerificationMeta('species');
  @override
  late final d.GeneratedColumn<String> species = d.GeneratedColumn<String>(
      'species', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _varietyMeta =
      const d.VerificationMeta('variety');
  @override
  late final d.GeneratedColumn<String> variety = d.GeneratedColumn<String>(
      'variety', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [genus, species, variety];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_genus';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<EcpGenusData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('genus')) {
      context.handle(
          _genusMeta, genus.isAcceptableOrUnknown(data['genus']!, _genusMeta));
    } else if (isInserting) {
      context.missing(_genusMeta);
    }
    if (data.containsKey('species')) {
      context.handle(_speciesMeta,
          species.isAcceptableOrUnknown(data['species']!, _speciesMeta));
    } else if (isInserting) {
      context.missing(_speciesMeta);
    }
    if (data.containsKey('variety')) {
      context.handle(_varietyMeta,
          variety.isAcceptableOrUnknown(data['variety']!, _varietyMeta));
    } else if (isInserting) {
      context.missing(_varietyMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  EcpGenusData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpGenusData(
      genus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus'])!,
      species: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species'])!,
      variety: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variety'])!,
    );
  }

  @override
  $EcpGenusTable createAlias(String alias) {
    return $EcpGenusTable(attachedDatabase, alias);
  }
}

class EcpGenusData extends d.DataClass implements d.Insertable<EcpGenusData> {
  final String genus;
  final String species;
  final String variety;
  const EcpGenusData(
      {required this.genus, required this.species, required this.variety});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['genus'] = d.Variable<String>(genus);
    map['species'] = d.Variable<String>(species);
    map['variety'] = d.Variable<String>(variety);
    return map;
  }

  EcpGenusCompanion toCompanion(bool nullToAbsent) {
    return EcpGenusCompanion(
      genus: d.Value(genus),
      species: d.Value(species),
      variety: d.Value(variety),
    );
  }

  factory EcpGenusData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpGenusData(
      genus: serializer.fromJson<String>(json['genus']),
      species: serializer.fromJson<String>(json['species']),
      variety: serializer.fromJson<String>(json['variety']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'genus': serializer.toJson<String>(genus),
      'species': serializer.toJson<String>(species),
      'variety': serializer.toJson<String>(variety),
    };
  }

  EcpGenusData copyWith({String? genus, String? species, String? variety}) =>
      EcpGenusData(
        genus: genus ?? this.genus,
        species: species ?? this.species,
        variety: variety ?? this.variety,
      );
  @override
  String toString() {
    return (StringBuffer('EcpGenusData(')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(genus, species, variety);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpGenusData &&
          other.genus == this.genus &&
          other.species == this.species &&
          other.variety == this.variety);
}

class EcpGenusCompanion extends d.UpdateCompanion<EcpGenusData> {
  final d.Value<String> genus;
  final d.Value<String> species;
  final d.Value<String> variety;
  final d.Value<int> rowid;
  const EcpGenusCompanion({
    this.genus = const d.Value.absent(),
    this.species = const d.Value.absent(),
    this.variety = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  EcpGenusCompanion.insert({
    required String genus,
    required String species,
    required String variety,
    this.rowid = const d.Value.absent(),
  })  : genus = d.Value(genus),
        species = d.Value(species),
        variety = d.Value(variety);
  static d.Insertable<EcpGenusData> custom({
    d.Expression<String>? genus,
    d.Expression<String>? species,
    d.Expression<String>? variety,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (genus != null) 'genus': genus,
      if (species != null) 'species': species,
      if (variety != null) 'variety': variety,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EcpGenusCompanion copyWith(
      {d.Value<String>? genus,
      d.Value<String>? species,
      d.Value<String>? variety,
      d.Value<int>? rowid}) {
    return EcpGenusCompanion(
      genus: genus ?? this.genus,
      species: species ?? this.species,
      variety: variety ?? this.variety,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (genus.present) {
      map['genus'] = d.Variable<String>(genus.value);
    }
    if (species.present) {
      map['species'] = d.Variable<String>(species.value);
    }
    if (variety.present) {
      map['variety'] = d.Variable<String>(variety.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpGenusCompanion(')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EcpLayerTable extends EcpLayer
    with d.TableInfo<$EcpLayerTable, EcpLayerData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpLayerTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_layer';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<EcpLayerData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  EcpLayerData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpLayerData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $EcpLayerTable createAlias(String alias) {
    return $EcpLayerTable(attachedDatabase, alias);
  }
}

class EcpLayerData extends d.DataClass implements d.Insertable<EcpLayerData> {
  final String code;
  final String name;
  const EcpLayerData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  EcpLayerCompanion toCompanion(bool nullToAbsent) {
    return EcpLayerCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory EcpLayerData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpLayerData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  EcpLayerData copyWith({String? code, String? name}) => EcpLayerData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('EcpLayerData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpLayerData &&
          other.code == this.code &&
          other.name == this.name);
}

class EcpLayerCompanion extends d.UpdateCompanion<EcpLayerData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const EcpLayerCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  EcpLayerCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<EcpLayerData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EcpLayerCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return EcpLayerCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpLayerCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EcpPlotTypeTable extends EcpPlotType
    with d.TableInfo<$EcpPlotTypeTable, EcpPlotTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpPlotTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_plot_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<EcpPlotTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  EcpPlotTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpPlotTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $EcpPlotTypeTable createAlias(String alias) {
    return $EcpPlotTypeTable(attachedDatabase, alias);
  }
}

class EcpPlotTypeData extends d.DataClass
    implements d.Insertable<EcpPlotTypeData> {
  final String code;
  final String name;
  const EcpPlotTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  EcpPlotTypeCompanion toCompanion(bool nullToAbsent) {
    return EcpPlotTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory EcpPlotTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpPlotTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  EcpPlotTypeData copyWith({String? code, String? name}) => EcpPlotTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('EcpPlotTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpPlotTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class EcpPlotTypeCompanion extends d.UpdateCompanion<EcpPlotTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const EcpPlotTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  EcpPlotTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<EcpPlotTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EcpPlotTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return EcpPlotTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpPlotTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilPitClassificationTable extends SoilPitClassification
    with d.TableInfo<$SoilPitClassificationTable, SoilPitClassificationData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitClassificationTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _orderMeta =
      const d.VerificationMeta('order');
  @override
  late final d.GeneratedColumn<String> order = d.GeneratedColumn<String>(
      'order', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _greatGroupMeta =
      const d.VerificationMeta('greatGroup');
  @override
  late final d.GeneratedColumn<String> greatGroup = d.GeneratedColumn<String>(
      'great_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _subGroupMeta =
      const d.VerificationMeta('subGroup');
  @override
  late final d.GeneratedColumn<String> subGroup = d.GeneratedColumn<String>(
      'sub_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, order, greatGroup, subGroup];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_classification';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilPitClassificationData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('order')) {
      context.handle(
          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
    } else if (isInserting) {
      context.missing(_orderMeta);
    }
    if (data.containsKey('great_group')) {
      context.handle(
          _greatGroupMeta,
          greatGroup.isAcceptableOrUnknown(
              data['great_group']!, _greatGroupMeta));
    } else if (isInserting) {
      context.missing(_greatGroupMeta);
    }
    if (data.containsKey('sub_group')) {
      context.handle(_subGroupMeta,
          subGroup.isAcceptableOrUnknown(data['sub_group']!, _subGroupMeta));
    } else if (isInserting) {
      context.missing(_subGroupMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilPitClassificationData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilPitClassificationData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      order: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order'])!,
      greatGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}great_group'])!,
      subGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sub_group'])!,
    );
  }

  @override
  $SoilPitClassificationTable createAlias(String alias) {
    return $SoilPitClassificationTable(attachedDatabase, alias);
  }
}

class SoilPitClassificationData extends d.DataClass
    implements d.Insertable<SoilPitClassificationData> {
  final String code;
  final String order;
  final String greatGroup;
  final String subGroup;
  const SoilPitClassificationData(
      {required this.code,
      required this.order,
      required this.greatGroup,
      required this.subGroup});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['order'] = d.Variable<String>(order);
    map['great_group'] = d.Variable<String>(greatGroup);
    map['sub_group'] = d.Variable<String>(subGroup);
    return map;
  }

  SoilPitClassificationCompanion toCompanion(bool nullToAbsent) {
    return SoilPitClassificationCompanion(
      code: d.Value(code),
      order: d.Value(order),
      greatGroup: d.Value(greatGroup),
      subGroup: d.Value(subGroup),
    );
  }

  factory SoilPitClassificationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilPitClassificationData(
      code: serializer.fromJson<String>(json['code']),
      order: serializer.fromJson<String>(json['order']),
      greatGroup: serializer.fromJson<String>(json['greatGroup']),
      subGroup: serializer.fromJson<String>(json['subGroup']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'order': serializer.toJson<String>(order),
      'greatGroup': serializer.toJson<String>(greatGroup),
      'subGroup': serializer.toJson<String>(subGroup),
    };
  }

  SoilPitClassificationData copyWith(
          {String? code,
          String? order,
          String? greatGroup,
          String? subGroup}) =>
      SoilPitClassificationData(
        code: code ?? this.code,
        order: order ?? this.order,
        greatGroup: greatGroup ?? this.greatGroup,
        subGroup: subGroup ?? this.subGroup,
      );
  @override
  String toString() {
    return (StringBuffer('SoilPitClassificationData(')
          ..write('code: $code, ')
          ..write('order: $order, ')
          ..write('greatGroup: $greatGroup, ')
          ..write('subGroup: $subGroup')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, order, greatGroup, subGroup);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilPitClassificationData &&
          other.code == this.code &&
          other.order == this.order &&
          other.greatGroup == this.greatGroup &&
          other.subGroup == this.subGroup);
}

class SoilPitClassificationCompanion
    extends d.UpdateCompanion<SoilPitClassificationData> {
  final d.Value<String> code;
  final d.Value<String> order;
  final d.Value<String> greatGroup;
  final d.Value<String> subGroup;
  final d.Value<int> rowid;
  const SoilPitClassificationCompanion({
    this.code = const d.Value.absent(),
    this.order = const d.Value.absent(),
    this.greatGroup = const d.Value.absent(),
    this.subGroup = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilPitClassificationCompanion.insert({
    required String code,
    required String order,
    required String greatGroup,
    required String subGroup,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        order = d.Value(order),
        greatGroup = d.Value(greatGroup),
        subGroup = d.Value(subGroup);
  static d.Insertable<SoilPitClassificationData> custom({
    d.Expression<String>? code,
    d.Expression<String>? order,
    d.Expression<String>? greatGroup,
    d.Expression<String>? subGroup,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (order != null) 'order': order,
      if (greatGroup != null) 'great_group': greatGroup,
      if (subGroup != null) 'sub_group': subGroup,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilPitClassificationCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? order,
      d.Value<String>? greatGroup,
      d.Value<String>? subGroup,
      d.Value<int>? rowid}) {
    return SoilPitClassificationCompanion(
      code: code ?? this.code,
      order: order ?? this.order,
      greatGroup: greatGroup ?? this.greatGroup,
      subGroup: subGroup ?? this.subGroup,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (order.present) {
      map['order'] = d.Variable<String>(order.value);
    }
    if (greatGroup.present) {
      map['great_group'] = d.Variable<String>(greatGroup.value);
    }
    if (subGroup.present) {
      map['sub_group'] = d.Variable<String>(subGroup.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitClassificationCompanion(')
          ..write('code: $code, ')
          ..write('order: $order, ')
          ..write('greatGroup: $greatGroup, ')
          ..write('subGroup: $subGroup, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilDrainageClassTable extends SoilDrainageClass
    with d.TableInfo<$SoilDrainageClassTable, SoilDrainageClassData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilDrainageClassTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<int> code = d.GeneratedColumn<int>(
      'code', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_drainage_class';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilDrainageClassData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilDrainageClassData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilDrainageClassData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilDrainageClassTable createAlias(String alias) {
    return $SoilDrainageClassTable(attachedDatabase, alias);
  }
}

class SoilDrainageClassData extends d.DataClass
    implements d.Insertable<SoilDrainageClassData> {
  final int code;
  final String name;
  const SoilDrainageClassData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<int>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilDrainageClassCompanion toCompanion(bool nullToAbsent) {
    return SoilDrainageClassCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilDrainageClassData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilDrainageClassData(
      code: serializer.fromJson<int>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<int>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilDrainageClassData copyWith({int? code, String? name}) =>
      SoilDrainageClassData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilDrainageClassData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilDrainageClassData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilDrainageClassCompanion
    extends d.UpdateCompanion<SoilDrainageClassData> {
  final d.Value<int> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilDrainageClassCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilDrainageClassCompanion.insert({
    required int code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilDrainageClassData> custom({
    d.Expression<int>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilDrainageClassCompanion copyWith(
      {d.Value<int>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilDrainageClassCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<int>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilDrainageClassCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilMoistureClassTable extends SoilMoistureClass
    with d.TableInfo<$SoilMoistureClassTable, SoilMositureClassData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilMoistureClassTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<int> code = d.GeneratedColumn<int>(
      'code', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_moisture_class';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilMositureClassData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilMositureClassData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilMositureClassData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilMoistureClassTable createAlias(String alias) {
    return $SoilMoistureClassTable(attachedDatabase, alias);
  }
}

class SoilMositureClassData extends d.DataClass
    implements d.Insertable<SoilMositureClassData> {
  final int code;
  final String name;
  const SoilMositureClassData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<int>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilMoistureClassCompanion toCompanion(bool nullToAbsent) {
    return SoilMoistureClassCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilMositureClassData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilMositureClassData(
      code: serializer.fromJson<int>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<int>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilMositureClassData copyWith({int? code, String? name}) =>
      SoilMositureClassData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilMositureClassData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilMositureClassData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilMoistureClassCompanion
    extends d.UpdateCompanion<SoilMositureClassData> {
  final d.Value<int> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilMoistureClassCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilMoistureClassCompanion.insert({
    required int code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilMositureClassData> custom({
    d.Expression<int>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilMoistureClassCompanion copyWith(
      {d.Value<int>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilMoistureClassCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<int>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilMoistureClassCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilDepositionTable extends SoilDeposition
    with d.TableInfo<$SoilDepositionTable, SoilDepositionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilDepositionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_deposition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilDepositionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilDepositionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilDepositionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilDepositionTable createAlias(String alias) {
    return $SoilDepositionTable(attachedDatabase, alias);
  }
}

class SoilDepositionData extends d.DataClass
    implements d.Insertable<SoilDepositionData> {
  final String code;
  final String name;
  const SoilDepositionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilDepositionCompanion toCompanion(bool nullToAbsent) {
    return SoilDepositionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilDepositionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilDepositionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilDepositionData copyWith({String? code, String? name}) =>
      SoilDepositionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilDepositionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilDepositionData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilDepositionCompanion extends d.UpdateCompanion<SoilDepositionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilDepositionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilDepositionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilDepositionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilDepositionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilDepositionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilDepositionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilHumusFormTable extends SoilHumusForm
    with d.TableInfo<$SoilHumusFormTable, SoilHumusFormData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilHumusFormTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_humus_form';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilHumusFormData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilHumusFormData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilHumusFormData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilHumusFormTable createAlias(String alias) {
    return $SoilHumusFormTable(attachedDatabase, alias);
  }
}

class SoilHumusFormData extends d.DataClass
    implements d.Insertable<SoilHumusFormData> {
  final String code;
  final String name;
  const SoilHumusFormData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilHumusFormCompanion toCompanion(bool nullToAbsent) {
    return SoilHumusFormCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilHumusFormData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilHumusFormData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilHumusFormData copyWith({String? code, String? name}) => SoilHumusFormData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilHumusFormData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilHumusFormData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilHumusFormCompanion extends d.UpdateCompanion<SoilHumusFormData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilHumusFormCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilHumusFormCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilHumusFormData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilHumusFormCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilHumusFormCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilHumusFormCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilPitCodeTable extends SoilPitCode
    with d.TableInfo<$SoilPitCodeTable, SoilPitCodeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitCodeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_code';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilPitCodeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilPitCodeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilPitCodeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilPitCodeTable createAlias(String alias) {
    return $SoilPitCodeTable(attachedDatabase, alias);
  }
}

class SoilPitCodeData extends d.DataClass
    implements d.Insertable<SoilPitCodeData> {
  final String code;
  final String name;
  const SoilPitCodeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilPitCodeCompanion toCompanion(bool nullToAbsent) {
    return SoilPitCodeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilPitCodeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilPitCodeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilPitCodeData copyWith({String? code, String? name}) => SoilPitCodeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilPitCodeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilPitCodeData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilPitCodeCompanion extends d.UpdateCompanion<SoilPitCodeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilPitCodeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilPitCodeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilPitCodeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilPitCodeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilPitCodeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitCodeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilPitFeatureClassTable extends SoilPitFeatureClass
    with d.TableInfo<$SoilPitFeatureClassTable, SoilFeatureClassData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitFeatureClassTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_feature_class';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilFeatureClassData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilFeatureClassData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilFeatureClassData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilPitFeatureClassTable createAlias(String alias) {
    return $SoilPitFeatureClassTable(attachedDatabase, alias);
  }
}

class SoilFeatureClassData extends d.DataClass
    implements d.Insertable<SoilFeatureClassData> {
  final String code;
  final String name;
  const SoilFeatureClassData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilPitFeatureClassCompanion toCompanion(bool nullToAbsent) {
    return SoilPitFeatureClassCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilFeatureClassData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilFeatureClassData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilFeatureClassData copyWith({String? code, String? name}) =>
      SoilFeatureClassData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilFeatureClassData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilFeatureClassData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilPitFeatureClassCompanion
    extends d.UpdateCompanion<SoilFeatureClassData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilPitFeatureClassCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilPitFeatureClassCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilFeatureClassData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilPitFeatureClassCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilPitFeatureClassCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitFeatureClassCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilHorizonDesignationTable extends SoilHorizonDesignation
    with d.TableInfo<$SoilHorizonDesignationTable, SoilHorizonDesignationData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilHorizonDesignationTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_horizon_designation';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilHorizonDesignationData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilHorizonDesignationData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilHorizonDesignationData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilHorizonDesignationTable createAlias(String alias) {
    return $SoilHorizonDesignationTable(attachedDatabase, alias);
  }
}

class SoilHorizonDesignationData extends d.DataClass
    implements d.Insertable<SoilHorizonDesignationData> {
  final String code;
  final String name;
  const SoilHorizonDesignationData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilHorizonDesignationCompanion toCompanion(bool nullToAbsent) {
    return SoilHorizonDesignationCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilHorizonDesignationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilHorizonDesignationData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilHorizonDesignationData copyWith({String? code, String? name}) =>
      SoilHorizonDesignationData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilHorizonDesignationData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilHorizonDesignationData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilHorizonDesignationCompanion
    extends d.UpdateCompanion<SoilHorizonDesignationData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilHorizonDesignationCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilHorizonDesignationCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilHorizonDesignationData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilHorizonDesignationCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilHorizonDesignationCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilHorizonDesignationCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilColorTable extends SoilColor
    with d.TableInfo<$SoilColorTable, SoilColorData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilColorTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_color';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<SoilColorData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilColorData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilColorData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilColorTable createAlias(String alias) {
    return $SoilColorTable(attachedDatabase, alias);
  }
}

class SoilColorData extends d.DataClass implements d.Insertable<SoilColorData> {
  final String code;
  final String name;
  const SoilColorData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilColorCompanion toCompanion(bool nullToAbsent) {
    return SoilColorCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilColorData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilColorData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilColorData copyWith({String? code, String? name}) => SoilColorData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilColorData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilColorData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilColorCompanion extends d.UpdateCompanion<SoilColorData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilColorCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilColorCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilColorData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilColorCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilColorCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilColorCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SoilTextureTable extends SoilTexture
    with d.TableInfo<$SoilTextureTable, SoilTextureData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilTextureTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_texture';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilTextureData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  SoilTextureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilTextureData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $SoilTextureTable createAlias(String alias) {
    return $SoilTextureTable(attachedDatabase, alias);
  }
}

class SoilTextureData extends d.DataClass
    implements d.Insertable<SoilTextureData> {
  final String code;
  final String name;
  const SoilTextureData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  SoilTextureCompanion toCompanion(bool nullToAbsent) {
    return SoilTextureCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory SoilTextureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilTextureData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  SoilTextureData copyWith({String? code, String? name}) => SoilTextureData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('SoilTextureData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilTextureData &&
          other.code == this.code &&
          other.name == this.name);
}

class SoilTextureCompanion extends d.UpdateCompanion<SoilTextureData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const SoilTextureCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  SoilTextureCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<SoilTextureData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SoilTextureCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return SoilTextureCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilTextureCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StpTypeTable extends StpType
    with d.TableInfo<$StpTypeTable, StpTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_type';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<StpTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StpTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StpTypeTable createAlias(String alias) {
    return $StpTypeTable(attachedDatabase, alias);
  }
}

class StpTypeData extends d.DataClass implements d.Insertable<StpTypeData> {
  final String code;
  final String name;
  const StpTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StpTypeCompanion toCompanion(bool nullToAbsent) {
    return StpTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StpTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StpTypeData copyWith({String? code, String? name}) => StpTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StpTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class StpTypeCompanion extends d.UpdateCompanion<StpTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StpTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StpTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StpTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StpTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StpTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StpOrigPlotAreaTable extends StpOrigPlotArea
    with d.TableInfo<$StpOrigPlotAreaTable, StpOrigPlotAreaData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpOrigPlotAreaTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_orig_plot_area';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StpOrigPlotAreaData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StpOrigPlotAreaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpOrigPlotAreaData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StpOrigPlotAreaTable createAlias(String alias) {
    return $StpOrigPlotAreaTable(attachedDatabase, alias);
  }
}

class StpOrigPlotAreaData extends d.DataClass
    implements d.Insertable<StpOrigPlotAreaData> {
  final String code;
  final String name;
  const StpOrigPlotAreaData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StpOrigPlotAreaCompanion toCompanion(bool nullToAbsent) {
    return StpOrigPlotAreaCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StpOrigPlotAreaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpOrigPlotAreaData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StpOrigPlotAreaData copyWith({String? code, String? name}) =>
      StpOrigPlotAreaData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StpOrigPlotAreaData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpOrigPlotAreaData &&
          other.code == this.code &&
          other.name == this.name);
}

class StpOrigPlotAreaCompanion extends d.UpdateCompanion<StpOrigPlotAreaData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StpOrigPlotAreaCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StpOrigPlotAreaCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StpOrigPlotAreaData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StpOrigPlotAreaCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StpOrigPlotAreaCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpOrigPlotAreaCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StpStatusFieldTable extends StpStatusField
    with d.TableInfo<$StpStatusFieldTable, StpStatusFieldData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpStatusFieldTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _descriptionMeta =
      const d.VerificationMeta('description');
  @override
  late final d.GeneratedColumn<String> description = d.GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, description];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_status_field';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StpStatusFieldData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StpStatusFieldData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpStatusFieldData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
    );
  }

  @override
  $StpStatusFieldTable createAlias(String alias) {
    return $StpStatusFieldTable(attachedDatabase, alias);
  }
}

class StpStatusFieldData extends d.DataClass
    implements d.Insertable<StpStatusFieldData> {
  final String code;
  final String name;
  final String description;
  const StpStatusFieldData(
      {required this.code, required this.name, required this.description});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    map['description'] = d.Variable<String>(description);
    return map;
  }

  StpStatusFieldCompanion toCompanion(bool nullToAbsent) {
    return StpStatusFieldCompanion(
      code: d.Value(code),
      name: d.Value(name),
      description: d.Value(description),
    );
  }

  factory StpStatusFieldData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpStatusFieldData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String>(json['description']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String>(description),
    };
  }

  StpStatusFieldData copyWith(
          {String? code, String? name, String? description}) =>
      StpStatusFieldData(
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
      );
  @override
  String toString() {
    return (StringBuffer('StpStatusFieldData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, description);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpStatusFieldData &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description);
}

class StpStatusFieldCompanion extends d.UpdateCompanion<StpStatusFieldData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String> description;
  final d.Value<int> rowid;
  const StpStatusFieldCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.description = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StpStatusFieldCompanion.insert({
    required String code,
    required String name,
    required String description,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name),
        description = d.Value(description);
  static d.Insertable<StpStatusFieldData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? description,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StpStatusFieldCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String>? description,
      d.Value<int>? rowid}) {
    return StpStatusFieldCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = d.Variable<String>(description.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpStatusFieldCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StpHeightTable extends StpHeight
    with d.TableInfo<$StpHeightTable, StpHeightData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpHeightTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_height';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<StpHeightData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StpHeightData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpHeightData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StpHeightTable createAlias(String alias) {
    return $StpHeightTable(attachedDatabase, alias);
  }
}

class StpHeightData extends d.DataClass implements d.Insertable<StpHeightData> {
  final String code;
  final String name;
  const StpHeightData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StpHeightCompanion toCompanion(bool nullToAbsent) {
    return StpHeightCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StpHeightData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpHeightData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StpHeightData copyWith({String? code, String? name}) => StpHeightData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StpHeightData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpHeightData &&
          other.code == this.code &&
          other.name == this.name);
}

class StpHeightCompanion extends d.UpdateCompanion<StpHeightData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StpHeightCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StpHeightCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StpHeightData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StpHeightCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StpHeightCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpHeightCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StpStemConditionTable extends StpStemCondition
    with d.TableInfo<$StpStemConditionTable, StpStemConditionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpStemConditionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_stem_condition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StpStemConditionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StpStemConditionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpStemConditionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StpStemConditionTable createAlias(String alias) {
    return $StpStemConditionTable(attachedDatabase, alias);
  }
}

class StpStemConditionData extends d.DataClass
    implements d.Insertable<StpStemConditionData> {
  final String code;
  final String name;
  const StpStemConditionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StpStemConditionCompanion toCompanion(bool nullToAbsent) {
    return StpStemConditionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StpStemConditionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpStemConditionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StpStemConditionData copyWith({String? code, String? name}) =>
      StpStemConditionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StpStemConditionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpStemConditionData &&
          other.code == this.code &&
          other.name == this.name);
}

class StpStemConditionCompanion
    extends d.UpdateCompanion<StpStemConditionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StpStemConditionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StpStemConditionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StpStemConditionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StpStemConditionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StpStemConditionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpStemConditionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShrubPlotTypeTable extends ShrubPlotType
    with d.TableInfo<$ShrubPlotTypeTable, ShrubPlotTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShrubPlotTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shrub_plot_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<ShrubPlotTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  ShrubPlotTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShrubPlotTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $ShrubPlotTypeTable createAlias(String alias) {
    return $ShrubPlotTypeTable(attachedDatabase, alias);
  }
}

class ShrubPlotTypeData extends d.DataClass
    implements d.Insertable<ShrubPlotTypeData> {
  final String code;
  final String name;
  const ShrubPlotTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  ShrubPlotTypeCompanion toCompanion(bool nullToAbsent) {
    return ShrubPlotTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory ShrubPlotTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return ShrubPlotTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  ShrubPlotTypeData copyWith({String? code, String? name}) => ShrubPlotTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('ShrubPlotTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShrubPlotTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class ShrubPlotTypeCompanion extends d.UpdateCompanion<ShrubPlotTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const ShrubPlotTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  ShrubPlotTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<ShrubPlotTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShrubPlotTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return ShrubPlotTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShrubPlotTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShrubStatusFieldTable extends ShrubStatusField
    with d.TableInfo<$ShrubStatusFieldTable, ShrubStatusFieldData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShrubStatusFieldTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shrub_status_field';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<ShrubStatusFieldData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  ShrubStatusFieldData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShrubStatusFieldData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $ShrubStatusFieldTable createAlias(String alias) {
    return $ShrubStatusFieldTable(attachedDatabase, alias);
  }
}

class ShrubStatusFieldData extends d.DataClass
    implements d.Insertable<ShrubStatusFieldData> {
  final String code;
  final String name;
  const ShrubStatusFieldData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  ShrubStatusFieldCompanion toCompanion(bool nullToAbsent) {
    return ShrubStatusFieldCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory ShrubStatusFieldData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return ShrubStatusFieldData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  ShrubStatusFieldData copyWith({String? code, String? name}) =>
      ShrubStatusFieldData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('ShrubStatusFieldData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShrubStatusFieldData &&
          other.code == this.code &&
          other.name == this.name);
}

class ShrubStatusFieldCompanion
    extends d.UpdateCompanion<ShrubStatusFieldData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const ShrubStatusFieldCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  ShrubStatusFieldCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<ShrubStatusFieldData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShrubStatusFieldCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return ShrubStatusFieldCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShrubStatusFieldCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShrubBasalDiameterTable extends ShrubBasalDiameter
    with d.TableInfo<$ShrubBasalDiameterTable, ShrubBasalDiameterData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShrubBasalDiameterTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shrub_basal_diameter';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<ShrubBasalDiameterData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  ShrubBasalDiameterData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShrubBasalDiameterData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $ShrubBasalDiameterTable createAlias(String alias) {
    return $ShrubBasalDiameterTable(attachedDatabase, alias);
  }
}

class ShrubBasalDiameterData extends d.DataClass
    implements d.Insertable<ShrubBasalDiameterData> {
  final String code;
  final String name;
  const ShrubBasalDiameterData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  ShrubBasalDiameterCompanion toCompanion(bool nullToAbsent) {
    return ShrubBasalDiameterCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory ShrubBasalDiameterData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return ShrubBasalDiameterData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  ShrubBasalDiameterData copyWith({String? code, String? name}) =>
      ShrubBasalDiameterData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('ShrubBasalDiameterData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShrubBasalDiameterData &&
          other.code == this.code &&
          other.name == this.name);
}

class ShrubBasalDiameterCompanion
    extends d.UpdateCompanion<ShrubBasalDiameterData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const ShrubBasalDiameterCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  ShrubBasalDiameterCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<ShrubBasalDiameterData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShrubBasalDiameterCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return ShrubBasalDiameterCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShrubBasalDiameterCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StumpPlotTypeTable extends StumpPlotType
    with d.TableInfo<$StumpPlotTypeTable, StumpPlotTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StumpPlotTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stump_plot_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StumpPlotTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StumpPlotTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StumpPlotTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StumpPlotTypeTable createAlias(String alias) {
    return $StumpPlotTypeTable(attachedDatabase, alias);
  }
}

class StumpPlotTypeData extends d.DataClass
    implements d.Insertable<StumpPlotTypeData> {
  final String code;
  final String name;
  const StumpPlotTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StumpPlotTypeCompanion toCompanion(bool nullToAbsent) {
    return StumpPlotTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StumpPlotTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StumpPlotTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StumpPlotTypeData copyWith({String? code, String? name}) => StumpPlotTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StumpPlotTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StumpPlotTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class StumpPlotTypeCompanion extends d.UpdateCompanion<StumpPlotTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StumpPlotTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StumpPlotTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StumpPlotTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StumpPlotTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StumpPlotTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StumpPlotTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $StumpOrigPlotAreaTable extends StumpOrigPlotArea
    with d.TableInfo<$StumpOrigPlotAreaTable, StumpOrigPlotAreaData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StumpOrigPlotAreaTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stump_orig_plot_area';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StumpOrigPlotAreaData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  StumpOrigPlotAreaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StumpOrigPlotAreaData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $StumpOrigPlotAreaTable createAlias(String alias) {
    return $StumpOrigPlotAreaTable(attachedDatabase, alias);
  }
}

class StumpOrigPlotAreaData extends d.DataClass
    implements d.Insertable<StumpOrigPlotAreaData> {
  final String code;
  final String name;
  const StumpOrigPlotAreaData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  StumpOrigPlotAreaCompanion toCompanion(bool nullToAbsent) {
    return StumpOrigPlotAreaCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory StumpOrigPlotAreaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StumpOrigPlotAreaData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  StumpOrigPlotAreaData copyWith({String? code, String? name}) =>
      StumpOrigPlotAreaData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('StumpOrigPlotAreaData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StumpOrigPlotAreaData &&
          other.code == this.code &&
          other.name == this.name);
}

class StumpOrigPlotAreaCompanion
    extends d.UpdateCompanion<StumpOrigPlotAreaData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const StumpOrigPlotAreaCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  StumpOrigPlotAreaCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<StumpOrigPlotAreaData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  StumpOrigPlotAreaCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return StumpOrigPlotAreaCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StumpOrigPlotAreaCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpPlotTypeTable extends LtpPlotType
    with d.TableInfo<$LtpPlotTypeTable, LtpPlotTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpPlotTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_plot_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpPlotTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpPlotTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpPlotTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpPlotTypeTable createAlias(String alias) {
    return $LtpPlotTypeTable(attachedDatabase, alias);
  }
}

class LtpPlotTypeData extends d.DataClass
    implements d.Insertable<LtpPlotTypeData> {
  final String code;
  final String name;
  const LtpPlotTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpPlotTypeCompanion toCompanion(bool nullToAbsent) {
    return LtpPlotTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpPlotTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpPlotTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpPlotTypeData copyWith({String? code, String? name}) => LtpPlotTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpPlotTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpPlotTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpPlotTypeCompanion extends d.UpdateCompanion<LtpPlotTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpPlotTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpPlotTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpPlotTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpPlotTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpPlotTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpPlotTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpPlotSplitTable extends LtpPlotSplit
    with d.TableInfo<$LtpPlotSplitTable, LtpPlotSplitData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpPlotSplitTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_plot_split';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpPlotSplitData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpPlotSplitData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpPlotSplitData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpPlotSplitTable createAlias(String alias) {
    return $LtpPlotSplitTable(attachedDatabase, alias);
  }
}

class LtpPlotSplitData extends d.DataClass
    implements d.Insertable<LtpPlotSplitData> {
  final String code;
  final String name;
  const LtpPlotSplitData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpPlotSplitCompanion toCompanion(bool nullToAbsent) {
    return LtpPlotSplitCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpPlotSplitData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpPlotSplitData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpPlotSplitData copyWith({String? code, String? name}) => LtpPlotSplitData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpPlotSplitData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpPlotSplitData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpPlotSplitCompanion extends d.UpdateCompanion<LtpPlotSplitData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpPlotSplitCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpPlotSplitCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpPlotSplitData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpPlotSplitCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpPlotSplitCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpPlotSplitCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpOrigPlotAreaTable extends LtpOrigPlotArea
    with d.TableInfo<$LtpOrigPlotAreaTable, LtpOrigPlotAreaData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpOrigPlotAreaTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_orig_plot_area';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpOrigPlotAreaData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpOrigPlotAreaData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpOrigPlotAreaData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpOrigPlotAreaTable createAlias(String alias) {
    return $LtpOrigPlotAreaTable(attachedDatabase, alias);
  }
}

class LtpOrigPlotAreaData extends d.DataClass
    implements d.Insertable<LtpOrigPlotAreaData> {
  final String code;
  final String name;
  const LtpOrigPlotAreaData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpOrigPlotAreaCompanion toCompanion(bool nullToAbsent) {
    return LtpOrigPlotAreaCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpOrigPlotAreaData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpOrigPlotAreaData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpOrigPlotAreaData copyWith({String? code, String? name}) =>
      LtpOrigPlotAreaData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpOrigPlotAreaData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpOrigPlotAreaData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpOrigPlotAreaCompanion extends d.UpdateCompanion<LtpOrigPlotAreaData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpOrigPlotAreaCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpOrigPlotAreaCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpOrigPlotAreaData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpOrigPlotAreaCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpOrigPlotAreaCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpOrigPlotAreaCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpStatusFieldTable extends LtpStatusField
    with d.TableInfo<$LtpStatusFieldTable, LtpStatusFieldData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpStatusFieldTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _descriptionMeta =
      const d.VerificationMeta('description');
  @override
  late final d.GeneratedColumn<String> description = d.GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, description];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_status_field';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpStatusFieldData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpStatusFieldData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpStatusFieldData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
    );
  }

  @override
  $LtpStatusFieldTable createAlias(String alias) {
    return $LtpStatusFieldTable(attachedDatabase, alias);
  }
}

class LtpStatusFieldData extends d.DataClass
    implements d.Insertable<LtpStatusFieldData> {
  final String code;
  final String name;
  final String description;
  const LtpStatusFieldData(
      {required this.code, required this.name, required this.description});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    map['description'] = d.Variable<String>(description);
    return map;
  }

  LtpStatusFieldCompanion toCompanion(bool nullToAbsent) {
    return LtpStatusFieldCompanion(
      code: d.Value(code),
      name: d.Value(name),
      description: d.Value(description),
    );
  }

  factory LtpStatusFieldData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpStatusFieldData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String>(json['description']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String>(description),
    };
  }

  LtpStatusFieldData copyWith(
          {String? code, String? name, String? description}) =>
      LtpStatusFieldData(
        code: code ?? this.code,
        name: name ?? this.name,
        description: description ?? this.description,
      );
  @override
  String toString() {
    return (StringBuffer('LtpStatusFieldData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, description);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpStatusFieldData &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description);
}

class LtpStatusFieldCompanion extends d.UpdateCompanion<LtpStatusFieldData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String> description;
  final d.Value<int> rowid;
  const LtpStatusFieldCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.description = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpStatusFieldCompanion.insert({
    required String code,
    required String name,
    required String description,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name),
        description = d.Value(description);
  static d.Insertable<LtpStatusFieldData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? description,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpStatusFieldCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String>? description,
      d.Value<int>? rowid}) {
    return LtpStatusFieldCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = d.Variable<String>(description.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpStatusFieldCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpGenusTable extends LtpGenus
    with d.TableInfo<$LtpGenusTable, LtpGenusData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpGenusTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _genusLatinNameMeta =
      const d.VerificationMeta('genusLatinName');
  @override
  late final d.GeneratedColumn<String> genusLatinName =
      d.GeneratedColumn<String>('genus_latin_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _speciesLatinNameMeta =
      const d.VerificationMeta('speciesLatinName');
  @override
  late final d.GeneratedColumn<String> speciesLatinName =
      d.GeneratedColumn<String>('species_latin_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _varietyLatinNameMeta =
      const d.VerificationMeta('varietyLatinName');
  @override
  late final d.GeneratedColumn<String> varietyLatinName =
      d.GeneratedColumn<String>('variety_latin_name', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _genusCodeMeta =
      const d.VerificationMeta('genusCode');
  @override
  late final d.GeneratedColumn<String> genusCode = d.GeneratedColumn<String>(
      'genus_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _speciesCodeMeta =
      const d.VerificationMeta('speciesCode');
  @override
  late final d.GeneratedColumn<String> speciesCode = d.GeneratedColumn<String>(
      'species_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _varietyCodeMeta =
      const d.VerificationMeta('varietyCode');
  @override
  late final d.GeneratedColumn<String> varietyCode = d.GeneratedColumn<String>(
      'variety_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        genusLatinName,
        speciesLatinName,
        varietyLatinName,
        genusCode,
        speciesCode,
        varietyCode
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_genus';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<LtpGenusData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('genus_latin_name')) {
      context.handle(
          _genusLatinNameMeta,
          genusLatinName.isAcceptableOrUnknown(
              data['genus_latin_name']!, _genusLatinNameMeta));
    } else if (isInserting) {
      context.missing(_genusLatinNameMeta);
    }
    if (data.containsKey('species_latin_name')) {
      context.handle(
          _speciesLatinNameMeta,
          speciesLatinName.isAcceptableOrUnknown(
              data['species_latin_name']!, _speciesLatinNameMeta));
    } else if (isInserting) {
      context.missing(_speciesLatinNameMeta);
    }
    if (data.containsKey('variety_latin_name')) {
      context.handle(
          _varietyLatinNameMeta,
          varietyLatinName.isAcceptableOrUnknown(
              data['variety_latin_name']!, _varietyLatinNameMeta));
    } else if (isInserting) {
      context.missing(_varietyLatinNameMeta);
    }
    if (data.containsKey('genus_code')) {
      context.handle(_genusCodeMeta,
          genusCode.isAcceptableOrUnknown(data['genus_code']!, _genusCodeMeta));
    } else if (isInserting) {
      context.missing(_genusCodeMeta);
    }
    if (data.containsKey('species_code')) {
      context.handle(
          _speciesCodeMeta,
          speciesCode.isAcceptableOrUnknown(
              data['species_code']!, _speciesCodeMeta));
    } else if (isInserting) {
      context.missing(_speciesCodeMeta);
    }
    if (data.containsKey('variety_code')) {
      context.handle(
          _varietyCodeMeta,
          varietyCode.isAcceptableOrUnknown(
              data['variety_code']!, _varietyCodeMeta));
    } else if (isInserting) {
      context.missing(_varietyCodeMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpGenusData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpGenusData(
      genusLatinName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}genus_latin_name'])!,
      speciesLatinName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}species_latin_name'])!,
      varietyLatinName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}variety_latin_name'])!,
      genusCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus_code'])!,
      speciesCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species_code'])!,
      varietyCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variety_code'])!,
    );
  }

  @override
  $LtpGenusTable createAlias(String alias) {
    return $LtpGenusTable(attachedDatabase, alias);
  }
}

class LtpGenusData extends d.DataClass implements d.Insertable<LtpGenusData> {
  final String genusLatinName;
  final String speciesLatinName;
  final String varietyLatinName;
  final String genusCode;
  final String speciesCode;
  final String varietyCode;
  const LtpGenusData(
      {required this.genusLatinName,
      required this.speciesLatinName,
      required this.varietyLatinName,
      required this.genusCode,
      required this.speciesCode,
      required this.varietyCode});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['genus_latin_name'] = d.Variable<String>(genusLatinName);
    map['species_latin_name'] = d.Variable<String>(speciesLatinName);
    map['variety_latin_name'] = d.Variable<String>(varietyLatinName);
    map['genus_code'] = d.Variable<String>(genusCode);
    map['species_code'] = d.Variable<String>(speciesCode);
    map['variety_code'] = d.Variable<String>(varietyCode);
    return map;
  }

  LtpGenusCompanion toCompanion(bool nullToAbsent) {
    return LtpGenusCompanion(
      genusLatinName: d.Value(genusLatinName),
      speciesLatinName: d.Value(speciesLatinName),
      varietyLatinName: d.Value(varietyLatinName),
      genusCode: d.Value(genusCode),
      speciesCode: d.Value(speciesCode),
      varietyCode: d.Value(varietyCode),
    );
  }

  factory LtpGenusData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpGenusData(
      genusLatinName: serializer.fromJson<String>(json['genusLatinName']),
      speciesLatinName: serializer.fromJson<String>(json['speciesLatinName']),
      varietyLatinName: serializer.fromJson<String>(json['varietyLatinName']),
      genusCode: serializer.fromJson<String>(json['genusCode']),
      speciesCode: serializer.fromJson<String>(json['speciesCode']),
      varietyCode: serializer.fromJson<String>(json['varietyCode']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'genusLatinName': serializer.toJson<String>(genusLatinName),
      'speciesLatinName': serializer.toJson<String>(speciesLatinName),
      'varietyLatinName': serializer.toJson<String>(varietyLatinName),
      'genusCode': serializer.toJson<String>(genusCode),
      'speciesCode': serializer.toJson<String>(speciesCode),
      'varietyCode': serializer.toJson<String>(varietyCode),
    };
  }

  LtpGenusData copyWith(
          {String? genusLatinName,
          String? speciesLatinName,
          String? varietyLatinName,
          String? genusCode,
          String? speciesCode,
          String? varietyCode}) =>
      LtpGenusData(
        genusLatinName: genusLatinName ?? this.genusLatinName,
        speciesLatinName: speciesLatinName ?? this.speciesLatinName,
        varietyLatinName: varietyLatinName ?? this.varietyLatinName,
        genusCode: genusCode ?? this.genusCode,
        speciesCode: speciesCode ?? this.speciesCode,
        varietyCode: varietyCode ?? this.varietyCode,
      );
  @override
  String toString() {
    return (StringBuffer('LtpGenusData(')
          ..write('genusLatinName: $genusLatinName, ')
          ..write('speciesLatinName: $speciesLatinName, ')
          ..write('varietyLatinName: $varietyLatinName, ')
          ..write('genusCode: $genusCode, ')
          ..write('speciesCode: $speciesCode, ')
          ..write('varietyCode: $varietyCode')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(genusLatinName, speciesLatinName,
      varietyLatinName, genusCode, speciesCode, varietyCode);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpGenusData &&
          other.genusLatinName == this.genusLatinName &&
          other.speciesLatinName == this.speciesLatinName &&
          other.varietyLatinName == this.varietyLatinName &&
          other.genusCode == this.genusCode &&
          other.speciesCode == this.speciesCode &&
          other.varietyCode == this.varietyCode);
}

class LtpGenusCompanion extends d.UpdateCompanion<LtpGenusData> {
  final d.Value<String> genusLatinName;
  final d.Value<String> speciesLatinName;
  final d.Value<String> varietyLatinName;
  final d.Value<String> genusCode;
  final d.Value<String> speciesCode;
  final d.Value<String> varietyCode;
  final d.Value<int> rowid;
  const LtpGenusCompanion({
    this.genusLatinName = const d.Value.absent(),
    this.speciesLatinName = const d.Value.absent(),
    this.varietyLatinName = const d.Value.absent(),
    this.genusCode = const d.Value.absent(),
    this.speciesCode = const d.Value.absent(),
    this.varietyCode = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpGenusCompanion.insert({
    required String genusLatinName,
    required String speciesLatinName,
    required String varietyLatinName,
    required String genusCode,
    required String speciesCode,
    required String varietyCode,
    this.rowid = const d.Value.absent(),
  })  : genusLatinName = d.Value(genusLatinName),
        speciesLatinName = d.Value(speciesLatinName),
        varietyLatinName = d.Value(varietyLatinName),
        genusCode = d.Value(genusCode),
        speciesCode = d.Value(speciesCode),
        varietyCode = d.Value(varietyCode);
  static d.Insertable<LtpGenusData> custom({
    d.Expression<String>? genusLatinName,
    d.Expression<String>? speciesLatinName,
    d.Expression<String>? varietyLatinName,
    d.Expression<String>? genusCode,
    d.Expression<String>? speciesCode,
    d.Expression<String>? varietyCode,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (genusLatinName != null) 'genus_latin_name': genusLatinName,
      if (speciesLatinName != null) 'species_latin_name': speciesLatinName,
      if (varietyLatinName != null) 'variety_latin_name': varietyLatinName,
      if (genusCode != null) 'genus_code': genusCode,
      if (speciesCode != null) 'species_code': speciesCode,
      if (varietyCode != null) 'variety_code': varietyCode,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpGenusCompanion copyWith(
      {d.Value<String>? genusLatinName,
      d.Value<String>? speciesLatinName,
      d.Value<String>? varietyLatinName,
      d.Value<String>? genusCode,
      d.Value<String>? speciesCode,
      d.Value<String>? varietyCode,
      d.Value<int>? rowid}) {
    return LtpGenusCompanion(
      genusLatinName: genusLatinName ?? this.genusLatinName,
      speciesLatinName: speciesLatinName ?? this.speciesLatinName,
      varietyLatinName: varietyLatinName ?? this.varietyLatinName,
      genusCode: genusCode ?? this.genusCode,
      speciesCode: speciesCode ?? this.speciesCode,
      varietyCode: varietyCode ?? this.varietyCode,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (genusLatinName.present) {
      map['genus_latin_name'] = d.Variable<String>(genusLatinName.value);
    }
    if (speciesLatinName.present) {
      map['species_latin_name'] = d.Variable<String>(speciesLatinName.value);
    }
    if (varietyLatinName.present) {
      map['variety_latin_name'] = d.Variable<String>(varietyLatinName.value);
    }
    if (genusCode.present) {
      map['genus_code'] = d.Variable<String>(genusCode.value);
    }
    if (speciesCode.present) {
      map['species_code'] = d.Variable<String>(speciesCode.value);
    }
    if (varietyCode.present) {
      map['variety_code'] = d.Variable<String>(varietyCode.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpGenusCompanion(')
          ..write('genusLatinName: $genusLatinName, ')
          ..write('speciesLatinName: $speciesLatinName, ')
          ..write('varietyLatinName: $varietyLatinName, ')
          ..write('genusCode: $genusCode, ')
          ..write('speciesCode: $speciesCode, ')
          ..write('varietyCode: $varietyCode, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpCrownClassFieldTable extends LtpCrownClassField
    with d.TableInfo<$LtpCrownClassFieldTable, LtpCrownClassFieldData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpCrownClassFieldTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_crown_class_field';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpCrownClassFieldData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpCrownClassFieldData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpCrownClassFieldData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpCrownClassFieldTable createAlias(String alias) {
    return $LtpCrownClassFieldTable(attachedDatabase, alias);
  }
}

class LtpCrownClassFieldData extends d.DataClass
    implements d.Insertable<LtpCrownClassFieldData> {
  final String code;
  final String name;
  const LtpCrownClassFieldData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpCrownClassFieldCompanion toCompanion(bool nullToAbsent) {
    return LtpCrownClassFieldCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpCrownClassFieldData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpCrownClassFieldData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpCrownClassFieldData copyWith({String? code, String? name}) =>
      LtpCrownClassFieldData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpCrownClassFieldData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpCrownClassFieldData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpCrownClassFieldCompanion
    extends d.UpdateCompanion<LtpCrownClassFieldData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpCrownClassFieldCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpCrownClassFieldCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpCrownClassFieldData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpCrownClassFieldCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpCrownClassFieldCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpCrownClassFieldCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpBarkConditionTable extends LtpBarkCondition
    with d.TableInfo<$LtpBarkConditionTable, LtpBarkConditionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpBarkConditionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_bark_condition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpBarkConditionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpBarkConditionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpBarkConditionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpBarkConditionTable createAlias(String alias) {
    return $LtpBarkConditionTable(attachedDatabase, alias);
  }
}

class LtpBarkConditionData extends d.DataClass
    implements d.Insertable<LtpBarkConditionData> {
  final String code;
  final String name;
  const LtpBarkConditionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpBarkConditionCompanion toCompanion(bool nullToAbsent) {
    return LtpBarkConditionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpBarkConditionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpBarkConditionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpBarkConditionData copyWith({String? code, String? name}) =>
      LtpBarkConditionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpBarkConditionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpBarkConditionData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpBarkConditionCompanion
    extends d.UpdateCompanion<LtpBarkConditionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpBarkConditionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpBarkConditionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpBarkConditionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpBarkConditionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpBarkConditionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpBarkConditionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpCrownConditionTable extends LtpCrownCondition
    with d.TableInfo<$LtpCrownConditionTable, LtpCrownConditionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpCrownConditionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_crown_condition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpCrownConditionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpCrownConditionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpCrownConditionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpCrownConditionTable createAlias(String alias) {
    return $LtpCrownConditionTable(attachedDatabase, alias);
  }
}

class LtpCrownConditionData extends d.DataClass
    implements d.Insertable<LtpCrownConditionData> {
  final String code;
  final String name;
  const LtpCrownConditionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpCrownConditionCompanion toCompanion(bool nullToAbsent) {
    return LtpCrownConditionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpCrownConditionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpCrownConditionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpCrownConditionData copyWith({String? code, String? name}) =>
      LtpCrownConditionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpCrownConditionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpCrownConditionData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpCrownConditionCompanion
    extends d.UpdateCompanion<LtpCrownConditionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpCrownConditionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpCrownConditionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpCrownConditionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpCrownConditionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpCrownConditionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpCrownConditionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpStemConditionTable extends LtpStemCondition
    with d.TableInfo<$LtpStemConditionTable, LtpStemConditionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpStemConditionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_stem_condition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpStemConditionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpStemConditionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpStemConditionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpStemConditionTable createAlias(String alias) {
    return $LtpStemConditionTable(attachedDatabase, alias);
  }
}

class LtpStemConditionData extends d.DataClass
    implements d.Insertable<LtpStemConditionData> {
  final String code;
  final String name;
  const LtpStemConditionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpStemConditionCompanion toCompanion(bool nullToAbsent) {
    return LtpStemConditionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpStemConditionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpStemConditionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpStemConditionData copyWith({String? code, String? name}) =>
      LtpStemConditionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpStemConditionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpStemConditionData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpStemConditionCompanion
    extends d.UpdateCompanion<LtpStemConditionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpStemConditionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpStemConditionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpStemConditionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpStemConditionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpStemConditionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpStemConditionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpWoodConditionTable extends LtpWoodCondition
    with d.TableInfo<$LtpWoodConditionTable, LtpWoodConditionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpWoodConditionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_wood_condition';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpWoodConditionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpWoodConditionData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpWoodConditionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpWoodConditionTable createAlias(String alias) {
    return $LtpWoodConditionTable(attachedDatabase, alias);
  }
}

class LtpWoodConditionData extends d.DataClass
    implements d.Insertable<LtpWoodConditionData> {
  final String code;
  final String name;
  const LtpWoodConditionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpWoodConditionCompanion toCompanion(bool nullToAbsent) {
    return LtpWoodConditionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpWoodConditionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpWoodConditionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpWoodConditionData copyWith({String? code, String? name}) =>
      LtpWoodConditionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpWoodConditionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpWoodConditionData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpWoodConditionCompanion
    extends d.UpdateCompanion<LtpWoodConditionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpWoodConditionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpWoodConditionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpWoodConditionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpWoodConditionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpWoodConditionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpWoodConditionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpQuadrantTable extends LtpQuadrant
    with d.TableInfo<$LtpQuadrantTable, LtpQuadrantData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpQuadrantTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_quadrant';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpQuadrantData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpQuadrantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpQuadrantData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpQuadrantTable createAlias(String alias) {
    return $LtpQuadrantTable(attachedDatabase, alias);
  }
}

class LtpQuadrantData extends d.DataClass
    implements d.Insertable<LtpQuadrantData> {
  final String code;
  final String name;
  const LtpQuadrantData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpQuadrantCompanion toCompanion(bool nullToAbsent) {
    return LtpQuadrantCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpQuadrantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpQuadrantData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpQuadrantData copyWith({String? code, String? name}) => LtpQuadrantData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpQuadrantData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpQuadrantData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpQuadrantCompanion extends d.UpdateCompanion<LtpQuadrantData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpQuadrantCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpQuadrantCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpQuadrantData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpQuadrantCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpQuadrantCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpQuadrantCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeTypeTable extends LtpTreeType
    with d.TableInfo<$LtpTreeTypeTable, LtpTreeTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpTreeTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpTreeTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpTreeTypeTable createAlias(String alias) {
    return $LtpTreeTypeTable(attachedDatabase, alias);
  }
}

class LtpTreeTypeData extends d.DataClass
    implements d.Insertable<LtpTreeTypeData> {
  final String code;
  final String name;
  const LtpTreeTypeData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpTreeTypeCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpTreeTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpTreeTypeData copyWith({String? code, String? name}) => LtpTreeTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeTypeData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeTypeData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpTreeTypeCompanion extends d.UpdateCompanion<LtpTreeTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpTreeTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpTreeTypeCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpTreeTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpTreeTypeCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpTreeTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpSiteHeightSuitabilityTable extends LtpSiteHeightSuitability
    with
        d.TableInfo<$LtpSiteHeightSuitabilityTable,
            LtpSiteHeightSuitabilityData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpSiteHeightSuitabilityTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_site_height_suitability';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpSiteHeightSuitabilityData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpSiteHeightSuitabilityData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpSiteHeightSuitabilityData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpSiteHeightSuitabilityTable createAlias(String alias) {
    return $LtpSiteHeightSuitabilityTable(attachedDatabase, alias);
  }
}

class LtpSiteHeightSuitabilityData extends d.DataClass
    implements d.Insertable<LtpSiteHeightSuitabilityData> {
  final String code;
  final String name;
  const LtpSiteHeightSuitabilityData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpSiteHeightSuitabilityCompanion toCompanion(bool nullToAbsent) {
    return LtpSiteHeightSuitabilityCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpSiteHeightSuitabilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpSiteHeightSuitabilityData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpSiteHeightSuitabilityData copyWith({String? code, String? name}) =>
      LtpSiteHeightSuitabilityData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpSiteHeightSuitabilityData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpSiteHeightSuitabilityData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpSiteHeightSuitabilityCompanion
    extends d.UpdateCompanion<LtpSiteHeightSuitabilityData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpSiteHeightSuitabilityCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpSiteHeightSuitabilityCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpSiteHeightSuitabilityData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpSiteHeightSuitabilityCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpSiteHeightSuitabilityCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpSiteHeightSuitabilityCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpSiteAgeSuitabilityTable extends LtpSiteAgeSuitability
    with d.TableInfo<$LtpSiteAgeSuitabilityTable, LtpSiteAgeSuitabilityData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpSiteAgeSuitabilityTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_site_age_suitability';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpSiteAgeSuitabilityData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpSiteAgeSuitabilityData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpSiteAgeSuitabilityData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpSiteAgeSuitabilityTable createAlias(String alias) {
    return $LtpSiteAgeSuitabilityTable(attachedDatabase, alias);
  }
}

class LtpSiteAgeSuitabilityData extends d.DataClass
    implements d.Insertable<LtpSiteAgeSuitabilityData> {
  final String code;
  final String name;
  const LtpSiteAgeSuitabilityData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpSiteAgeSuitabilityCompanion toCompanion(bool nullToAbsent) {
    return LtpSiteAgeSuitabilityCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpSiteAgeSuitabilityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpSiteAgeSuitabilityData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpSiteAgeSuitabilityData copyWith({String? code, String? name}) =>
      LtpSiteAgeSuitabilityData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpSiteAgeSuitabilityData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpSiteAgeSuitabilityData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpSiteAgeSuitabilityCompanion
    extends d.UpdateCompanion<LtpSiteAgeSuitabilityData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpSiteAgeSuitabilityCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpSiteAgeSuitabilityCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpSiteAgeSuitabilityData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpSiteAgeSuitabilityCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpSiteAgeSuitabilityCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpSiteAgeSuitabilityCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LtpProrateTable extends LtpProrate
    with d.TableInfo<$LtpProrateTable, LtpProrateData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpProrateTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_prorate';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<LtpProrateData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  LtpProrateData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpProrateData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $LtpProrateTable createAlias(String alias) {
    return $LtpProrateTable(attachedDatabase, alias);
  }
}

class LtpProrateData extends d.DataClass
    implements d.Insertable<LtpProrateData> {
  final String code;
  final String name;
  const LtpProrateData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  LtpProrateCompanion toCompanion(bool nullToAbsent) {
    return LtpProrateCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory LtpProrateData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpProrateData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  LtpProrateData copyWith({String? code, String? name}) => LtpProrateData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('LtpProrateData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpProrateData &&
          other.code == this.code &&
          other.name == this.name);
}

class LtpProrateCompanion extends d.UpdateCompanion<LtpProrateData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const LtpProrateCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  LtpProrateCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<LtpProrateData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LtpProrateCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return LtpProrateCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpProrateCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoStandStructureTable extends GpSiteInfoStandStructure
    with
        d.TableInfo<$GpSiteInfoStandStructureTable,
            GpSiteInfoStandStructureData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoStandStructureTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _coverMeta =
      const d.VerificationMeta('cover');
  @override
  late final d.GeneratedColumn<String> cover = d.GeneratedColumn<String>(
      'cover', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, cover];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_stand_structure';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoStandStructureData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('cover')) {
      context.handle(
          _coverMeta, cover.isAcceptableOrUnknown(data['cover']!, _coverMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoStandStructureData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoStandStructureData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      cover: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cover']),
    );
  }

  @override
  $GpSiteInfoStandStructureTable createAlias(String alias) {
    return $GpSiteInfoStandStructureTable(attachedDatabase, alias);
  }
}

class GpSiteInfoStandStructureData extends d.DataClass
    implements d.Insertable<GpSiteInfoStandStructureData> {
  final String code;
  final String name;
  final String? cover;
  const GpSiteInfoStandStructureData(
      {required this.code, required this.name, this.cover});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    if (!nullToAbsent || cover != null) {
      map['cover'] = d.Variable<String>(cover);
    }
    return map;
  }

  GpSiteInfoStandStructureCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoStandStructureCompanion(
      code: d.Value(code),
      name: d.Value(name),
      cover: cover == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(cover),
    );
  }

  factory GpSiteInfoStandStructureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoStandStructureData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      cover: serializer.fromJson<String?>(json['cover']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'cover': serializer.toJson<String?>(cover),
    };
  }

  GpSiteInfoStandStructureData copyWith(
          {String? code,
          String? name,
          d.Value<String?> cover = const d.Value.absent()}) =>
      GpSiteInfoStandStructureData(
        code: code ?? this.code,
        name: name ?? this.name,
        cover: cover.present ? cover.value : this.cover,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoStandStructureData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('cover: $cover')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, cover);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoStandStructureData &&
          other.code == this.code &&
          other.name == this.name &&
          other.cover == this.cover);
}

class GpSiteInfoStandStructureCompanion
    extends d.UpdateCompanion<GpSiteInfoStandStructureData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String?> cover;
  final d.Value<int> rowid;
  const GpSiteInfoStandStructureCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.cover = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoStandStructureCompanion.insert({
    required String code,
    required String name,
    this.cover = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoStandStructureData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? cover,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (cover != null) 'cover': cover,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoStandStructureCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String?>? cover,
      d.Value<int>? rowid}) {
    return GpSiteInfoStandStructureCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      cover: cover ?? this.cover,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (cover.present) {
      map['cover'] = d.Variable<String>(cover.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoStandStructureCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('cover: $cover, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoSuccessionStageTable extends GpSiteInfoSuccessionStage
    with
        d.TableInfo<$GpSiteInfoSuccessionStageTable,
            GpSiteInfoSuccessionStageData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoSuccessionStageTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_succession_stage';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoSuccessionStageData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoSuccessionStageData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoSuccessionStageData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoSuccessionStageTable createAlias(String alias) {
    return $GpSiteInfoSuccessionStageTable(attachedDatabase, alias);
  }
}

class GpSiteInfoSuccessionStageData extends d.DataClass
    implements d.Insertable<GpSiteInfoSuccessionStageData> {
  final String code;
  final String name;
  const GpSiteInfoSuccessionStageData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoSuccessionStageCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoSuccessionStageCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoSuccessionStageData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoSuccessionStageData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoSuccessionStageData copyWith({String? code, String? name}) =>
      GpSiteInfoSuccessionStageData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoSuccessionStageData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoSuccessionStageData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoSuccessionStageCompanion
    extends d.UpdateCompanion<GpSiteInfoSuccessionStageData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoSuccessionStageCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoSuccessionStageCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoSuccessionStageData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoSuccessionStageCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoSuccessionStageCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoSuccessionStageCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoUtmZoneTable extends GpSiteInfoUtmZone
    with d.TableInfo<$GpSiteInfoUtmZoneTable, GpSiteInfoUtmZoneData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoUtmZoneTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<int> code = d.GeneratedColumn<int>(
      'code', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_utm_zone';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoUtmZoneData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoUtmZoneData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoUtmZoneData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoUtmZoneTable createAlias(String alias) {
    return $GpSiteInfoUtmZoneTable(attachedDatabase, alias);
  }
}

class GpSiteInfoUtmZoneData extends d.DataClass
    implements d.Insertable<GpSiteInfoUtmZoneData> {
  final int code;
  final String name;
  const GpSiteInfoUtmZoneData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<int>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoUtmZoneCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoUtmZoneCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoUtmZoneData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoUtmZoneData(
      code: serializer.fromJson<int>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<int>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoUtmZoneData copyWith({int? code, String? name}) =>
      GpSiteInfoUtmZoneData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoUtmZoneData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoUtmZoneData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoUtmZoneCompanion
    extends d.UpdateCompanion<GpSiteInfoUtmZoneData> {
  final d.Value<int> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoUtmZoneCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoUtmZoneCompanion.insert({
    required int code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoUtmZoneData> custom({
    d.Expression<int>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoUtmZoneCompanion copyWith(
      {d.Value<int>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoUtmZoneCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<int>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoUtmZoneCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoVegTypeTable extends GpSiteInfoVegType
    with d.TableInfo<$GpSiteInfoVegTypeTable, GpSiteInfoVegTypeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoVegTypeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _coverMeta =
      const d.VerificationMeta('cover');
  @override
  late final d.GeneratedColumn<String> cover = d.GeneratedColumn<String>(
      'cover', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _baseMeta = const d.VerificationMeta('base');
  @override
  late final d.GeneratedColumn<String> base = d.GeneratedColumn<String>(
      'base', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, cover, base];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_veg_type';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoVegTypeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('cover')) {
      context.handle(
          _coverMeta, cover.isAcceptableOrUnknown(data['cover']!, _coverMeta));
    } else if (isInserting) {
      context.missing(_coverMeta);
    }
    if (data.containsKey('base')) {
      context.handle(
          _baseMeta, base.isAcceptableOrUnknown(data['base']!, _baseMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoVegTypeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoVegTypeData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      cover: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cover'])!,
      base: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}base']),
    );
  }

  @override
  $GpSiteInfoVegTypeTable createAlias(String alias) {
    return $GpSiteInfoVegTypeTable(attachedDatabase, alias);
  }
}

class GpSiteInfoVegTypeData extends d.DataClass
    implements d.Insertable<GpSiteInfoVegTypeData> {
  final String code;
  final String name;
  final String cover;
  final String? base;
  const GpSiteInfoVegTypeData(
      {required this.code, required this.name, required this.cover, this.base});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    map['cover'] = d.Variable<String>(cover);
    if (!nullToAbsent || base != null) {
      map['base'] = d.Variable<String>(base);
    }
    return map;
  }

  GpSiteInfoVegTypeCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoVegTypeCompanion(
      code: d.Value(code),
      name: d.Value(name),
      cover: d.Value(cover),
      base:
          base == null && nullToAbsent ? const d.Value.absent() : d.Value(base),
    );
  }

  factory GpSiteInfoVegTypeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoVegTypeData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      cover: serializer.fromJson<String>(json['cover']),
      base: serializer.fromJson<String?>(json['base']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'cover': serializer.toJson<String>(cover),
      'base': serializer.toJson<String?>(base),
    };
  }

  GpSiteInfoVegTypeData copyWith(
          {String? code,
          String? name,
          String? cover,
          d.Value<String?> base = const d.Value.absent()}) =>
      GpSiteInfoVegTypeData(
        code: code ?? this.code,
        name: name ?? this.name,
        cover: cover ?? this.cover,
        base: base.present ? base.value : this.base,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoVegTypeData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('cover: $cover, ')
          ..write('base: $base')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, cover, base);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoVegTypeData &&
          other.code == this.code &&
          other.name == this.name &&
          other.cover == this.cover &&
          other.base == this.base);
}

class GpSiteInfoVegTypeCompanion
    extends d.UpdateCompanion<GpSiteInfoVegTypeData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String> cover;
  final d.Value<String?> base;
  final d.Value<int> rowid;
  const GpSiteInfoVegTypeCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.cover = const d.Value.absent(),
    this.base = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoVegTypeCompanion.insert({
    required String code,
    required String name,
    required String cover,
    this.base = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name),
        cover = d.Value(cover);
  static d.Insertable<GpSiteInfoVegTypeData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? cover,
    d.Expression<String>? base,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (cover != null) 'cover': cover,
      if (base != null) 'base': base,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoVegTypeCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String>? cover,
      d.Value<String?>? base,
      d.Value<int>? rowid}) {
    return GpSiteInfoVegTypeCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      cover: cover ?? this.cover,
      base: base ?? this.base,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (cover.present) {
      map['cover'] = d.Variable<String>(cover.value);
    }
    if (base.present) {
      map['base'] = d.Variable<String>(base.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoVegTypeCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('cover: $cover, ')
          ..write('base: $base, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoWetlandTable extends GpSiteInfoWetland
    with d.TableInfo<$GpSiteInfoWetlandTable, GpSiteInfoWetlandData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoWetlandTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_wetland';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoWetlandData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoWetlandData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoWetlandData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoWetlandTable createAlias(String alias) {
    return $GpSiteInfoWetlandTable(attachedDatabase, alias);
  }
}

class GpSiteInfoWetlandData extends d.DataClass
    implements d.Insertable<GpSiteInfoWetlandData> {
  final String code;
  final String name;
  const GpSiteInfoWetlandData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoWetlandCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoWetlandCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoWetlandData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoWetlandData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoWetlandData copyWith({String? code, String? name}) =>
      GpSiteInfoWetlandData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoWetlandData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoWetlandData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoWetlandCompanion
    extends d.UpdateCompanion<GpSiteInfoWetlandData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoWetlandCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoWetlandCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoWetlandData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoWetlandCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoWetlandCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoWetlandCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoEcozoneTable extends GpSiteInfoEcozone
    with d.TableInfo<$GpSiteInfoEcozoneTable, GpSiteInfoEcozoneData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoEcozoneTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<int> code = d.GeneratedColumn<int>(
      'code', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_ecozone';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoEcozoneData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoEcozoneData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoEcozoneData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoEcozoneTable createAlias(String alias) {
    return $GpSiteInfoEcozoneTable(attachedDatabase, alias);
  }
}

class GpSiteInfoEcozoneData extends d.DataClass
    implements d.Insertable<GpSiteInfoEcozoneData> {
  final int code;
  final String name;
  const GpSiteInfoEcozoneData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<int>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoEcozoneCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoEcozoneCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoEcozoneData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoEcozoneData(
      code: serializer.fromJson<int>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<int>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoEcozoneData copyWith({int? code, String? name}) =>
      GpSiteInfoEcozoneData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoEcozoneData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoEcozoneData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoEcozoneCompanion
    extends d.UpdateCompanion<GpSiteInfoEcozoneData> {
  final d.Value<int> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoEcozoneCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoEcozoneCompanion.insert({
    required int code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoEcozoneData> custom({
    d.Expression<int>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoEcozoneCompanion copyWith(
      {d.Value<int>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoEcozoneCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<int>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoEcozoneCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoPlotCompletionTable extends GpSiteInfoPlotCompletion
    with
        d.TableInfo<$GpSiteInfoPlotCompletionTable,
            GpSiteInfoPlotCompletionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoPlotCompletionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_plot_completion';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoPlotCompletionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoPlotCompletionData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoPlotCompletionData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoPlotCompletionTable createAlias(String alias) {
    return $GpSiteInfoPlotCompletionTable(attachedDatabase, alias);
  }
}

class GpSiteInfoPlotCompletionData extends d.DataClass
    implements d.Insertable<GpSiteInfoPlotCompletionData> {
  final String code;
  final String name;
  const GpSiteInfoPlotCompletionData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoPlotCompletionCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoPlotCompletionCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoPlotCompletionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoPlotCompletionData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoPlotCompletionData copyWith({String? code, String? name}) =>
      GpSiteInfoPlotCompletionData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPlotCompletionData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoPlotCompletionData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoPlotCompletionCompanion
    extends d.UpdateCompanion<GpSiteInfoPlotCompletionData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoPlotCompletionCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoPlotCompletionCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoPlotCompletionData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoPlotCompletionCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoPlotCompletionCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPlotCompletionCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoDensityTable extends GpSiteInfoDensity
    with d.TableInfo<$GpSiteInfoDensityTable, GpSiteInfoDensityData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoDensityTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _baseMeta = const d.VerificationMeta('base');
  @override
  late final d.GeneratedColumn<String> base = d.GeneratedColumn<String>(
      'base', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _vegMeta = const d.VerificationMeta('veg');
  @override
  late final d.GeneratedColumn<String> veg = d.GeneratedColumn<String>(
      'veg', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, base, veg];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_density';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoDensityData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('base')) {
      context.handle(
          _baseMeta, base.isAcceptableOrUnknown(data['base']!, _baseMeta));
    }
    if (data.containsKey('veg')) {
      context.handle(
          _vegMeta, veg.isAcceptableOrUnknown(data['veg']!, _vegMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoDensityData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoDensityData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      base: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}base']),
      veg: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}veg']),
    );
  }

  @override
  $GpSiteInfoDensityTable createAlias(String alias) {
    return $GpSiteInfoDensityTable(attachedDatabase, alias);
  }
}

class GpSiteInfoDensityData extends d.DataClass
    implements d.Insertable<GpSiteInfoDensityData> {
  final String code;
  final String name;
  final String? base;
  final String? veg;
  const GpSiteInfoDensityData(
      {required this.code, required this.name, this.base, this.veg});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    if (!nullToAbsent || base != null) {
      map['base'] = d.Variable<String>(base);
    }
    if (!nullToAbsent || veg != null) {
      map['veg'] = d.Variable<String>(veg);
    }
    return map;
  }

  GpSiteInfoDensityCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoDensityCompanion(
      code: d.Value(code),
      name: d.Value(name),
      base:
          base == null && nullToAbsent ? const d.Value.absent() : d.Value(base),
      veg: veg == null && nullToAbsent ? const d.Value.absent() : d.Value(veg),
    );
  }

  factory GpSiteInfoDensityData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoDensityData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      base: serializer.fromJson<String?>(json['base']),
      veg: serializer.fromJson<String?>(json['veg']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'base': serializer.toJson<String?>(base),
      'veg': serializer.toJson<String?>(veg),
    };
  }

  GpSiteInfoDensityData copyWith(
          {String? code,
          String? name,
          d.Value<String?> base = const d.Value.absent(),
          d.Value<String?> veg = const d.Value.absent()}) =>
      GpSiteInfoDensityData(
        code: code ?? this.code,
        name: name ?? this.name,
        base: base.present ? base.value : this.base,
        veg: veg.present ? veg.value : this.veg,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoDensityData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('base: $base, ')
          ..write('veg: $veg')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, base, veg);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoDensityData &&
          other.code == this.code &&
          other.name == this.name &&
          other.base == this.base &&
          other.veg == this.veg);
}

class GpSiteInfoDensityCompanion
    extends d.UpdateCompanion<GpSiteInfoDensityData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String?> base;
  final d.Value<String?> veg;
  final d.Value<int> rowid;
  const GpSiteInfoDensityCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.base = const d.Value.absent(),
    this.veg = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoDensityCompanion.insert({
    required String code,
    required String name,
    this.base = const d.Value.absent(),
    this.veg = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoDensityData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? base,
    d.Expression<String>? veg,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (base != null) 'base': base,
      if (veg != null) 'veg': veg,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoDensityCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String?>? base,
      d.Value<String?>? veg,
      d.Value<int>? rowid}) {
    return GpSiteInfoDensityCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      base: base ?? this.base,
      veg: veg ?? this.veg,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (base.present) {
      map['base'] = d.Variable<String>(base.value);
    }
    if (veg.present) {
      map['veg'] = d.Variable<String>(veg.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoDensityCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('base: $base, ')
          ..write('veg: $veg, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoLandBaseTable extends GpSiteInfoLandBase
    with d.TableInfo<$GpSiteInfoLandBaseTable, GpSiteInfoLandBaseData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoLandBaseTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _completionMeta =
      const d.VerificationMeta('completion');
  @override
  late final d.GeneratedColumn<String> completion = d.GeneratedColumn<String>(
      'completion', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, completion];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_land_base';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoLandBaseData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('completion')) {
      context.handle(
          _completionMeta,
          completion.isAcceptableOrUnknown(
              data['completion']!, _completionMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoLandBaseData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoLandBaseData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      completion: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}completion']),
    );
  }

  @override
  $GpSiteInfoLandBaseTable createAlias(String alias) {
    return $GpSiteInfoLandBaseTable(attachedDatabase, alias);
  }
}

class GpSiteInfoLandBaseData extends d.DataClass
    implements d.Insertable<GpSiteInfoLandBaseData> {
  final String code;
  final String name;
  final String? completion;
  const GpSiteInfoLandBaseData(
      {required this.code, required this.name, this.completion});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    if (!nullToAbsent || completion != null) {
      map['completion'] = d.Variable<String>(completion);
    }
    return map;
  }

  GpSiteInfoLandBaseCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoLandBaseCompanion(
      code: d.Value(code),
      name: d.Value(name),
      completion: completion == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(completion),
    );
  }

  factory GpSiteInfoLandBaseData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoLandBaseData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      completion: serializer.fromJson<String?>(json['completion']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'completion': serializer.toJson<String?>(completion),
    };
  }

  GpSiteInfoLandBaseData copyWith(
          {String? code,
          String? name,
          d.Value<String?> completion = const d.Value.absent()}) =>
      GpSiteInfoLandBaseData(
        code: code ?? this.code,
        name: name ?? this.name,
        completion: completion.present ? completion.value : this.completion,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandBaseData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('completion: $completion')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, completion);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoLandBaseData &&
          other.code == this.code &&
          other.name == this.name &&
          other.completion == this.completion);
}

class GpSiteInfoLandBaseCompanion
    extends d.UpdateCompanion<GpSiteInfoLandBaseData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String?> completion;
  final d.Value<int> rowid;
  const GpSiteInfoLandBaseCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.completion = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoLandBaseCompanion.insert({
    required String code,
    required String name,
    this.completion = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoLandBaseData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? completion,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (completion != null) 'completion': completion,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoLandBaseCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String?>? completion,
      d.Value<int>? rowid}) {
    return GpSiteInfoLandBaseCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      completion: completion ?? this.completion,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (completion.present) {
      map['completion'] = d.Variable<String>(completion.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandBaseCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('completion: $completion, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoLandCoverTable extends GpSiteInfoLandCover
    with d.TableInfo<$GpSiteInfoLandCoverTable, GpSiteInfoLandCoverData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoLandCoverTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _baseMeta = const d.VerificationMeta('base');
  @override
  late final d.GeneratedColumn<String> base = d.GeneratedColumn<String>(
      'base', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [code, name, base];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_land_cover';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoLandCoverData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('base')) {
      context.handle(
          _baseMeta, base.isAcceptableOrUnknown(data['base']!, _baseMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoLandCoverData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoLandCoverData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      base: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}base']),
    );
  }

  @override
  $GpSiteInfoLandCoverTable createAlias(String alias) {
    return $GpSiteInfoLandCoverTable(attachedDatabase, alias);
  }
}

class GpSiteInfoLandCoverData extends d.DataClass
    implements d.Insertable<GpSiteInfoLandCoverData> {
  final String code;
  final String name;
  final String? base;
  const GpSiteInfoLandCoverData(
      {required this.code, required this.name, this.base});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    if (!nullToAbsent || base != null) {
      map['base'] = d.Variable<String>(base);
    }
    return map;
  }

  GpSiteInfoLandCoverCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoLandCoverCompanion(
      code: d.Value(code),
      name: d.Value(name),
      base:
          base == null && nullToAbsent ? const d.Value.absent() : d.Value(base),
    );
  }

  factory GpSiteInfoLandCoverData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoLandCoverData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      base: serializer.fromJson<String?>(json['base']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'base': serializer.toJson<String?>(base),
    };
  }

  GpSiteInfoLandCoverData copyWith(
          {String? code,
          String? name,
          d.Value<String?> base = const d.Value.absent()}) =>
      GpSiteInfoLandCoverData(
        code: code ?? this.code,
        name: name ?? this.name,
        base: base.present ? base.value : this.base,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandCoverData(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('base: $base')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name, base);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoLandCoverData &&
          other.code == this.code &&
          other.name == this.name &&
          other.base == this.base);
}

class GpSiteInfoLandCoverCompanion
    extends d.UpdateCompanion<GpSiteInfoLandCoverData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<String?> base;
  final d.Value<int> rowid;
  const GpSiteInfoLandCoverCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.base = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoLandCoverCompanion.insert({
    required String code,
    required String name,
    this.base = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoLandCoverData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<String>? base,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (base != null) 'base': base,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoLandCoverCompanion copyWith(
      {d.Value<String>? code,
      d.Value<String>? name,
      d.Value<String?>? base,
      d.Value<int>? rowid}) {
    return GpSiteInfoLandCoverCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      base: base ?? this.base,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (base.present) {
      map['base'] = d.Variable<String>(base.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandCoverCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('base: $base, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoLandPosTable extends GpSiteInfoLandPos
    with d.TableInfo<$GpSiteInfoLandPosTable, GpSiteInfoLandPo> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoLandPosTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_land_pos';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoLandPo> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoLandPo map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoLandPo(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoLandPosTable createAlias(String alias) {
    return $GpSiteInfoLandPosTable(attachedDatabase, alias);
  }
}

class GpSiteInfoLandPo extends d.DataClass
    implements d.Insertable<GpSiteInfoLandPo> {
  final String code;
  final String name;
  const GpSiteInfoLandPo({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoLandPosCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoLandPosCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoLandPo.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoLandPo(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoLandPo copyWith({String? code, String? name}) => GpSiteInfoLandPo(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandPo(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoLandPo &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoLandPosCompanion extends d.UpdateCompanion<GpSiteInfoLandPo> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoLandPosCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoLandPosCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoLandPo> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoLandPosCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoLandPosCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoLandPosCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoPostProcessingTable extends GpSiteInfoPostProcessing
    with
        d.TableInfo<$GpSiteInfoPostProcessingTable,
            GpSiteInfoPostProcessingData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoPostProcessingTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_post_processing';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoPostProcessingData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoPostProcessingData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoPostProcessingData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoPostProcessingTable createAlias(String alias) {
    return $GpSiteInfoPostProcessingTable(attachedDatabase, alias);
  }
}

class GpSiteInfoPostProcessingData extends d.DataClass
    implements d.Insertable<GpSiteInfoPostProcessingData> {
  final String code;
  final String name;
  const GpSiteInfoPostProcessingData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoPostProcessingCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoPostProcessingCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoPostProcessingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoPostProcessingData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoPostProcessingData copyWith({String? code, String? name}) =>
      GpSiteInfoPostProcessingData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPostProcessingData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoPostProcessingData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoPostProcessingCompanion
    extends d.UpdateCompanion<GpSiteInfoPostProcessingData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoPostProcessingCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoPostProcessingCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoPostProcessingData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoPostProcessingCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoPostProcessingCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPostProcessingCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoPlotIncompleteReasonTable
    extends GpSiteInfoPlotIncompleteReason
    with
        d.TableInfo<$GpSiteInfoPlotIncompleteReasonTable,
            GpSiteInfoPlotIncompleteReasonData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoPlotIncompleteReasonTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info_plot_incomplete_reason';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpSiteInfoPlotIncompleteReasonData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpSiteInfoPlotIncompleteReasonData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoPlotIncompleteReasonData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpSiteInfoPlotIncompleteReasonTable createAlias(String alias) {
    return $GpSiteInfoPlotIncompleteReasonTable(attachedDatabase, alias);
  }
}

class GpSiteInfoPlotIncompleteReasonData extends d.DataClass
    implements d.Insertable<GpSiteInfoPlotIncompleteReasonData> {
  final String code;
  final String name;
  const GpSiteInfoPlotIncompleteReasonData(
      {required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpSiteInfoPlotIncompleteReasonCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoPlotIncompleteReasonCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpSiteInfoPlotIncompleteReasonData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoPlotIncompleteReasonData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpSiteInfoPlotIncompleteReasonData copyWith({String? code, String? name}) =>
      GpSiteInfoPlotIncompleteReasonData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPlotIncompleteReasonData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoPlotIncompleteReasonData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpSiteInfoPlotIncompleteReasonCompanion
    extends d.UpdateCompanion<GpSiteInfoPlotIncompleteReasonData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpSiteInfoPlotIncompleteReasonCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpSiteInfoPlotIncompleteReasonCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpSiteInfoPlotIncompleteReasonData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpSiteInfoPlotIncompleteReasonCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpSiteInfoPlotIncompleteReasonCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoPlotIncompleteReasonCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GpDistAgentTable extends GpDistAgent
    with d.TableInfo<$GpDistAgentTable, GpDistAgentData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpDistAgentTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _codeMeta = const d.VerificationMeta('code');
  @override
  late final d.GeneratedColumn<String> code = d.GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _nameMeta = const d.VerificationMeta('name');
  @override
  late final d.GeneratedColumn<String> name = d.GeneratedColumn<String>(
      'name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [code, name];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_dist_agent';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpDistAgentData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => const {};
  @override
  GpDistAgentData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpDistAgentData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
    );
  }

  @override
  $GpDistAgentTable createAlias(String alias) {
    return $GpDistAgentTable(attachedDatabase, alias);
  }
}

class GpDistAgentData extends d.DataClass
    implements d.Insertable<GpDistAgentData> {
  final String code;
  final String name;
  const GpDistAgentData({required this.code, required this.name});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['code'] = d.Variable<String>(code);
    map['name'] = d.Variable<String>(name);
    return map;
  }

  GpDistAgentCompanion toCompanion(bool nullToAbsent) {
    return GpDistAgentCompanion(
      code: d.Value(code),
      name: d.Value(name),
    );
  }

  factory GpDistAgentData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpDistAgentData(
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
    };
  }

  GpDistAgentData copyWith({String? code, String? name}) => GpDistAgentData(
        code: code ?? this.code,
        name: name ?? this.name,
      );
  @override
  String toString() {
    return (StringBuffer('GpDistAgentData(')
          ..write('code: $code, ')
          ..write('name: $name')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(code, name);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpDistAgentData &&
          other.code == this.code &&
          other.name == this.name);
}

class GpDistAgentCompanion extends d.UpdateCompanion<GpDistAgentData> {
  final d.Value<String> code;
  final d.Value<String> name;
  final d.Value<int> rowid;
  const GpDistAgentCompanion({
    this.code = const d.Value.absent(),
    this.name = const d.Value.absent(),
    this.rowid = const d.Value.absent(),
  });
  GpDistAgentCompanion.insert({
    required String code,
    required String name,
    this.rowid = const d.Value.absent(),
  })  : code = d.Value(code),
        name = d.Value(name);
  static d.Insertable<GpDistAgentData> custom({
    d.Expression<String>? code,
    d.Expression<String>? name,
    d.Expression<int>? rowid,
  }) {
    return d.RawValuesInsertable({
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GpDistAgentCompanion copyWith(
      {d.Value<String>? code, d.Value<String>? name, d.Value<int>? rowid}) {
    return GpDistAgentCompanion(
      code: code ?? this.code,
      name: name ?? this.name,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (code.present) {
      map['code'] = d.Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = d.Variable<String>(name.value);
    }
    if (rowid.present) {
      map['rowid'] = d.Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpDistAgentCompanion(')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SurveyHeadersTable extends SurveyHeaders
    with d.TableInfo<$SurveyHeadersTable, SurveyHeader> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveyHeadersTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _nfiPlotMeta =
      const d.VerificationMeta('nfiPlot');
  @override
  late final d.GeneratedColumn<int> nfiPlot = d.GeneratedColumn<int>(
      'nfi_plot', aliasedName, false,
      check: () =>
          nfiPlot.isBetweenValues(1, 1600000) |
          nfiPlot.isBetweenValues(2000000, 2399999),
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES plots (nfi_plot)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _measNumMeta =
      const d.VerificationMeta('measNum');
  @override
  late final d.GeneratedColumn<int> measNum = d.GeneratedColumn<int>(
      'meas_num', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _provinceMeta =
      const d.VerificationMeta('province');
  @override
  late final d.GeneratedColumn<String> province = d.GeneratedColumn<String>(
      'province', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES jurisdictions (code)'));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, nfiPlot, measDate, measNum, province, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_headers';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<SurveyHeader> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('nfi_plot')) {
      context.handle(_nfiPlotMeta,
          nfiPlot.isAcceptableOrUnknown(data['nfi_plot']!, _nfiPlotMeta));
    } else if (isInserting) {
      context.missing(_nfiPlotMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('meas_num')) {
      context.handle(_measNumMeta,
          measNum.isAcceptableOrUnknown(data['meas_num']!, _measNumMeta));
    } else if (isInserting) {
      context.missing(_measNumMeta);
    }
    if (data.containsKey('province')) {
      context.handle(_provinceMeta,
          province.isAcceptableOrUnknown(data['province']!, _provinceMeta));
    } else if (isInserting) {
      context.missing(_provinceMeta);
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveyHeader map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveyHeader(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      nfiPlot: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}nfi_plot'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      measNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}meas_num'])!,
      province: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}province'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $SurveyHeadersTable createAlias(String alias) {
    return $SurveyHeadersTable(attachedDatabase, alias);
  }
}

class SurveyHeader extends d.DataClass implements d.Insertable<SurveyHeader> {
  final int id;
  final int nfiPlot;
  final DateTime measDate;
  final int measNum;
  final String province;
  final bool complete;
  const SurveyHeader(
      {required this.id,
      required this.nfiPlot,
      required this.measDate,
      required this.measNum,
      required this.province,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['nfi_plot'] = d.Variable<int>(nfiPlot);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['meas_num'] = d.Variable<int>(measNum);
    map['province'] = d.Variable<String>(province);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  SurveyHeadersCompanion toCompanion(bool nullToAbsent) {
    return SurveyHeadersCompanion(
      id: d.Value(id),
      nfiPlot: d.Value(nfiPlot),
      measDate: d.Value(measDate),
      measNum: d.Value(measNum),
      province: d.Value(province),
      complete: d.Value(complete),
    );
  }

  factory SurveyHeader.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveyHeader(
      id: serializer.fromJson<int>(json['id']),
      nfiPlot: serializer.fromJson<int>(json['nfiPlot']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      measNum: serializer.fromJson<int>(json['measNum']),
      province: serializer.fromJson<String>(json['province']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'nfiPlot': serializer.toJson<int>(nfiPlot),
      'measDate': serializer.toJson<DateTime>(measDate),
      'measNum': serializer.toJson<int>(measNum),
      'province': serializer.toJson<String>(province),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  SurveyHeader copyWith(
          {int? id,
          int? nfiPlot,
          DateTime? measDate,
          int? measNum,
          String? province,
          bool? complete}) =>
      SurveyHeader(
        id: id ?? this.id,
        nfiPlot: nfiPlot ?? this.nfiPlot,
        measDate: measDate ?? this.measDate,
        measNum: measNum ?? this.measNum,
        province: province ?? this.province,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('SurveyHeader(')
          ..write('id: $id, ')
          ..write('nfiPlot: $nfiPlot, ')
          ..write('measDate: $measDate, ')
          ..write('measNum: $measNum, ')
          ..write('province: $province, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, nfiPlot, measDate, measNum, province, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveyHeader &&
          other.id == this.id &&
          other.nfiPlot == this.nfiPlot &&
          other.measDate == this.measDate &&
          other.measNum == this.measNum &&
          other.province == this.province &&
          other.complete == this.complete);
}

class SurveyHeadersCompanion extends d.UpdateCompanion<SurveyHeader> {
  final d.Value<int> id;
  final d.Value<int> nfiPlot;
  final d.Value<DateTime> measDate;
  final d.Value<int> measNum;
  final d.Value<String> province;
  final d.Value<bool> complete;
  const SurveyHeadersCompanion({
    this.id = const d.Value.absent(),
    this.nfiPlot = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.measNum = const d.Value.absent(),
    this.province = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  SurveyHeadersCompanion.insert({
    this.id = const d.Value.absent(),
    required int nfiPlot,
    required DateTime measDate,
    required int measNum,
    required String province,
    this.complete = const d.Value.absent(),
  })  : nfiPlot = d.Value(nfiPlot),
        measDate = d.Value(measDate),
        measNum = d.Value(measNum),
        province = d.Value(province);
  static d.Insertable<SurveyHeader> custom({
    d.Expression<int>? id,
    d.Expression<int>? nfiPlot,
    d.Expression<DateTime>? measDate,
    d.Expression<int>? measNum,
    d.Expression<String>? province,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (nfiPlot != null) 'nfi_plot': nfiPlot,
      if (measDate != null) 'meas_date': measDate,
      if (measNum != null) 'meas_num': measNum,
      if (province != null) 'province': province,
      if (complete != null) 'complete': complete,
    });
  }

  SurveyHeadersCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? nfiPlot,
      d.Value<DateTime>? measDate,
      d.Value<int>? measNum,
      d.Value<String>? province,
      d.Value<bool>? complete}) {
    return SurveyHeadersCompanion(
      id: id ?? this.id,
      nfiPlot: nfiPlot ?? this.nfiPlot,
      measDate: measDate ?? this.measDate,
      measNum: measNum ?? this.measNum,
      province: province ?? this.province,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (nfiPlot.present) {
      map['nfi_plot'] = d.Variable<int>(nfiPlot.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (measNum.present) {
      map['meas_num'] = d.Variable<int>(measNum.value);
    }
    if (province.present) {
      map['province'] = d.Variable<String>(province.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveyHeadersCompanion(')
          ..write('id: $id, ')
          ..write('nfiPlot: $nfiPlot, ')
          ..write('measDate: $measDate, ')
          ..write('measNum: $measNum, ')
          ..write('province: $province, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $MetaCommentTable extends MetaComment
    with d.TableInfo<$MetaCommentTable, MetaCommentData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MetaCommentTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _surveyCategoryMeta =
      const d.VerificationMeta('surveyCategory');
  @override
  late final d.GeneratedColumn<int> surveyCategory = d.GeneratedColumn<int>(
      'survey_category', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _commentTextMeta =
      const d.VerificationMeta('commentText');
  @override
  late final d.GeneratedColumn<String> commentText = d.GeneratedColumn<String>(
      'comment_text', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, surveyCategory, commentText];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'meta_comment';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<MetaCommentData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('survey_category')) {
      context.handle(
          _surveyCategoryMeta,
          surveyCategory.isAcceptableOrUnknown(
              data['survey_category']!, _surveyCategoryMeta));
    } else if (isInserting) {
      context.missing(_surveyCategoryMeta);
    }
    if (data.containsKey('comment_text')) {
      context.handle(
          _commentTextMeta,
          commentText.isAcceptableOrUnknown(
              data['comment_text']!, _commentTextMeta));
    } else if (isInserting) {
      context.missing(_commentTextMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  MetaCommentData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MetaCommentData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      surveyCategory: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_category'])!,
      commentText: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comment_text'])!,
    );
  }

  @override
  $MetaCommentTable createAlias(String alias) {
    return $MetaCommentTable(attachedDatabase, alias);
  }
}

class MetaCommentData extends d.DataClass
    implements d.Insertable<MetaCommentData> {
  final int id;
  final int surveyId;
  final int surveyCategory;
  final String commentText;
  const MetaCommentData(
      {required this.id,
      required this.surveyId,
      required this.surveyCategory,
      required this.commentText});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['survey_category'] = d.Variable<int>(surveyCategory);
    map['comment_text'] = d.Variable<String>(commentText);
    return map;
  }

  MetaCommentCompanion toCompanion(bool nullToAbsent) {
    return MetaCommentCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      surveyCategory: d.Value(surveyCategory),
      commentText: d.Value(commentText),
    );
  }

  factory MetaCommentData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return MetaCommentData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      surveyCategory: serializer.fromJson<int>(json['surveyCategory']),
      commentText: serializer.fromJson<String>(json['commentText']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'surveyCategory': serializer.toJson<int>(surveyCategory),
      'commentText': serializer.toJson<String>(commentText),
    };
  }

  MetaCommentData copyWith(
          {int? id, int? surveyId, int? surveyCategory, String? commentText}) =>
      MetaCommentData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        surveyCategory: surveyCategory ?? this.surveyCategory,
        commentText: commentText ?? this.commentText,
      );
  @override
  String toString() {
    return (StringBuffer('MetaCommentData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('surveyCategory: $surveyCategory, ')
          ..write('commentText: $commentText')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, surveyCategory, commentText);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MetaCommentData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.surveyCategory == this.surveyCategory &&
          other.commentText == this.commentText);
}

class MetaCommentCompanion extends d.UpdateCompanion<MetaCommentData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<int> surveyCategory;
  final d.Value<String> commentText;
  const MetaCommentCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.surveyCategory = const d.Value.absent(),
    this.commentText = const d.Value.absent(),
  });
  MetaCommentCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required int surveyCategory,
    required String commentText,
  })  : surveyId = d.Value(surveyId),
        surveyCategory = d.Value(surveyCategory),
        commentText = d.Value(commentText);
  static d.Insertable<MetaCommentData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<int>? surveyCategory,
    d.Expression<String>? commentText,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (surveyCategory != null) 'survey_category': surveyCategory,
      if (commentText != null) 'comment_text': commentText,
    });
  }

  MetaCommentCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<int>? surveyCategory,
      d.Value<String>? commentText}) {
    return MetaCommentCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      surveyCategory: surveyCategory ?? this.surveyCategory,
      commentText: commentText ?? this.commentText,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (surveyCategory.present) {
      map['survey_category'] = d.Variable<int>(surveyCategory.value);
    }
    if (commentText.present) {
      map['comment_text'] = d.Variable<String>(commentText.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MetaCommentCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('surveyCategory: $surveyCategory, ')
          ..write('commentText: $commentText')
          ..write(')'))
        .toString();
  }
}

class $SurveySummaryTable extends SurveySummary
    with d.TableInfo<$SurveySummaryTable, SurveySummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveySummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _referenceTreeMeta =
      const d.VerificationMeta('referenceTree');
  @override
  late final d.GeneratedColumn<int> referenceTree = d.GeneratedColumn<int>(
      'reference_tree', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const d.VerificationMeta _crewOneMeta =
      const d.VerificationMeta('crewOne');
  @override
  late final d.GeneratedColumn<String> crewOne = d.GeneratedColumn<String>(
      'crew_one', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _crewTwoMeta =
      const d.VerificationMeta('crewTwo');
  @override
  late final d.GeneratedColumn<String> crewTwo = d.GeneratedColumn<String>(
      'crew_two', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _crewThreeMeta =
      const d.VerificationMeta('crewThree');
  @override
  late final d.GeneratedColumn<String> crewThree = d.GeneratedColumn<String>(
      'crew_three', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _numberPhotosMeta =
      const d.VerificationMeta('numberPhotos');
  @override
  late final d.GeneratedColumn<int> numberPhotos = d.GeneratedColumn<int>(
      'number_photos', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const d.Constant(0));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        notAssessed,
        complete,
        referenceTree,
        crewOne,
        crewTwo,
        crewThree,
        numberPhotos
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurveySummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    if (data.containsKey('reference_tree')) {
      context.handle(
          _referenceTreeMeta,
          referenceTree.isAcceptableOrUnknown(
              data['reference_tree']!, _referenceTreeMeta));
    }
    if (data.containsKey('crew_one')) {
      context.handle(_crewOneMeta,
          crewOne.isAcceptableOrUnknown(data['crew_one']!, _crewOneMeta));
    }
    if (data.containsKey('crew_two')) {
      context.handle(_crewTwoMeta,
          crewTwo.isAcceptableOrUnknown(data['crew_two']!, _crewTwoMeta));
    }
    if (data.containsKey('crew_three')) {
      context.handle(_crewThreeMeta,
          crewThree.isAcceptableOrUnknown(data['crew_three']!, _crewThreeMeta));
    }
    if (data.containsKey('number_photos')) {
      context.handle(
          _numberPhotosMeta,
          numberPhotos.isAcceptableOrUnknown(
              data['number_photos']!, _numberPhotosMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveySummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveySummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
      referenceTree: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}reference_tree']),
      crewOne: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}crew_one']),
      crewTwo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}crew_two']),
      crewThree: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}crew_three']),
      numberPhotos: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}number_photos']),
    );
  }

  @override
  $SurveySummaryTable createAlias(String alias) {
    return $SurveySummaryTable(attachedDatabase, alias);
  }
}

class SurveySummaryData extends d.DataClass
    implements d.Insertable<SurveySummaryData> {
  final int id;
  final int surveyId;
  final bool notAssessed;
  final bool complete;
  final int? referenceTree;
  final String? crewOne;
  final String? crewTwo;
  final String? crewThree;
  final int? numberPhotos;
  const SurveySummaryData(
      {required this.id,
      required this.surveyId,
      required this.notAssessed,
      required this.complete,
      this.referenceTree,
      this.crewOne,
      this.crewTwo,
      this.crewThree,
      this.numberPhotos});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    if (!nullToAbsent || referenceTree != null) {
      map['reference_tree'] = d.Variable<int>(referenceTree);
    }
    if (!nullToAbsent || crewOne != null) {
      map['crew_one'] = d.Variable<String>(crewOne);
    }
    if (!nullToAbsent || crewTwo != null) {
      map['crew_two'] = d.Variable<String>(crewTwo);
    }
    if (!nullToAbsent || crewThree != null) {
      map['crew_three'] = d.Variable<String>(crewThree);
    }
    if (!nullToAbsent || numberPhotos != null) {
      map['number_photos'] = d.Variable<int>(numberPhotos);
    }
    return map;
  }

  SurveySummaryCompanion toCompanion(bool nullToAbsent) {
    return SurveySummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
      referenceTree: referenceTree == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(referenceTree),
      crewOne: crewOne == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(crewOne),
      crewTwo: crewTwo == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(crewTwo),
      crewThree: crewThree == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(crewThree),
      numberPhotos: numberPhotos == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(numberPhotos),
    );
  }

  factory SurveySummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveySummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
      referenceTree: serializer.fromJson<int?>(json['referenceTree']),
      crewOne: serializer.fromJson<String?>(json['crewOne']),
      crewTwo: serializer.fromJson<String?>(json['crewTwo']),
      crewThree: serializer.fromJson<String?>(json['crewThree']),
      numberPhotos: serializer.fromJson<int?>(json['numberPhotos']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
      'referenceTree': serializer.toJson<int?>(referenceTree),
      'crewOne': serializer.toJson<String?>(crewOne),
      'crewTwo': serializer.toJson<String?>(crewTwo),
      'crewThree': serializer.toJson<String?>(crewThree),
      'numberPhotos': serializer.toJson<int?>(numberPhotos),
    };
  }

  SurveySummaryData copyWith(
          {int? id,
          int? surveyId,
          bool? notAssessed,
          bool? complete,
          d.Value<int?> referenceTree = const d.Value.absent(),
          d.Value<String?> crewOne = const d.Value.absent(),
          d.Value<String?> crewTwo = const d.Value.absent(),
          d.Value<String?> crewThree = const d.Value.absent(),
          d.Value<int?> numberPhotos = const d.Value.absent()}) =>
      SurveySummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
        referenceTree:
            referenceTree.present ? referenceTree.value : this.referenceTree,
        crewOne: crewOne.present ? crewOne.value : this.crewOne,
        crewTwo: crewTwo.present ? crewTwo.value : this.crewTwo,
        crewThree: crewThree.present ? crewThree.value : this.crewThree,
        numberPhotos:
            numberPhotos.present ? numberPhotos.value : this.numberPhotos,
      );
  @override
  String toString() {
    return (StringBuffer('SurveySummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete, ')
          ..write('referenceTree: $referenceTree, ')
          ..write('crewOne: $crewOne, ')
          ..write('crewTwo: $crewTwo, ')
          ..write('crewThree: $crewThree, ')
          ..write('numberPhotos: $numberPhotos')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, notAssessed, complete,
      referenceTree, crewOne, crewTwo, crewThree, numberPhotos);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveySummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete &&
          other.referenceTree == this.referenceTree &&
          other.crewOne == this.crewOne &&
          other.crewTwo == this.crewTwo &&
          other.crewThree == this.crewThree &&
          other.numberPhotos == this.numberPhotos);
}

class SurveySummaryCompanion extends d.UpdateCompanion<SurveySummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  final d.Value<int?> referenceTree;
  final d.Value<String?> crewOne;
  final d.Value<String?> crewTwo;
  final d.Value<String?> crewThree;
  final d.Value<int?> numberPhotos;
  const SurveySummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
    this.referenceTree = const d.Value.absent(),
    this.crewOne = const d.Value.absent(),
    this.crewTwo = const d.Value.absent(),
    this.crewThree = const d.Value.absent(),
    this.numberPhotos = const d.Value.absent(),
  });
  SurveySummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
    this.referenceTree = const d.Value.absent(),
    this.crewOne = const d.Value.absent(),
    this.crewTwo = const d.Value.absent(),
    this.crewThree = const d.Value.absent(),
    this.numberPhotos = const d.Value.absent(),
  }) : surveyId = d.Value(surveyId);
  static d.Insertable<SurveySummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
    d.Expression<int>? referenceTree,
    d.Expression<String>? crewOne,
    d.Expression<String>? crewTwo,
    d.Expression<String>? crewThree,
    d.Expression<int>? numberPhotos,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
      if (referenceTree != null) 'reference_tree': referenceTree,
      if (crewOne != null) 'crew_one': crewOne,
      if (crewTwo != null) 'crew_two': crewTwo,
      if (crewThree != null) 'crew_three': crewThree,
      if (numberPhotos != null) 'number_photos': numberPhotos,
    });
  }

  SurveySummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete,
      d.Value<int?>? referenceTree,
      d.Value<String?>? crewOne,
      d.Value<String?>? crewTwo,
      d.Value<String?>? crewThree,
      d.Value<int?>? numberPhotos}) {
    return SurveySummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
      referenceTree: referenceTree ?? this.referenceTree,
      crewOne: crewOne ?? this.crewOne,
      crewTwo: crewTwo ?? this.crewTwo,
      crewThree: crewThree ?? this.crewThree,
      numberPhotos: numberPhotos ?? this.numberPhotos,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    if (referenceTree.present) {
      map['reference_tree'] = d.Variable<int>(referenceTree.value);
    }
    if (crewOne.present) {
      map['crew_one'] = d.Variable<String>(crewOne.value);
    }
    if (crewTwo.present) {
      map['crew_two'] = d.Variable<String>(crewTwo.value);
    }
    if (crewThree.present) {
      map['crew_three'] = d.Variable<String>(crewThree.value);
    }
    if (numberPhotos.present) {
      map['number_photos'] = d.Variable<int>(numberPhotos.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveySummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete, ')
          ..write('referenceTree: $referenceTree, ')
          ..write('crewOne: $crewOne, ')
          ..write('crewTwo: $crewTwo, ')
          ..write('crewThree: $crewThree, ')
          ..write('numberPhotos: $numberPhotos')
          ..write(')'))
        .toString();
  }
}

class $SurveyHeaderGroundPhotoTable extends SurveyHeaderGroundPhoto
    with
        d
        .TableInfo<$SurveyHeaderGroundPhotoTable, SurveyHeaderGroundPhotoData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveyHeaderGroundPhotoTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _plotPinMeta =
      const d.VerificationMeta('plotPin');
  @override
  late final d.GeneratedColumn<bool> plotPin = d.GeneratedColumn<bool>(
      'plot_pin', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("plot_pin" IN (0, 1))'));
  static const d.VerificationMeta _transectOneFifteenUnderMeta =
      const d.VerificationMeta('transectOneFifteenUnder');
  @override
  late final d.GeneratedColumn<bool> transectOneFifteenUnder =
      d.GeneratedColumn<bool>('transect_one_fifteen_under', aliasedName, true,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("transect_one_fifteen_under" IN (0, 1))'));
  static const d.VerificationMeta _transectOneFifteenOverMeta =
      const d.VerificationMeta('transectOneFifteenOver');
  @override
  late final d.GeneratedColumn<bool> transectOneFifteenOver =
      d.GeneratedColumn<bool>('transect_one_fifteen_over', aliasedName, true,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("transect_one_fifteen_over" IN (0, 1))'));
  static const d.VerificationMeta _transectTwoFifteenUnderMeta =
      const d.VerificationMeta('transectTwoFifteenUnder');
  @override
  late final d.GeneratedColumn<bool> transectTwoFifteenUnder =
      d.GeneratedColumn<bool>('transect_two_fifteen_under', aliasedName, true,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("transect_two_fifteen_under" IN (0, 1))'));
  static const d.VerificationMeta _transectTwoFifteenOverMeta =
      const d.VerificationMeta('transectTwoFifteenOver');
  @override
  late final d.GeneratedColumn<bool> transectTwoFifteenOver =
      d.GeneratedColumn<bool>('transect_two_fifteen_over', aliasedName, true,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("transect_two_fifteen_over" IN (0, 1))'));
  static const d.VerificationMeta _horizontalMeta =
      const d.VerificationMeta('horizontal');
  @override
  late final d.GeneratedColumn<bool> horizontal = d.GeneratedColumn<bool>(
      'horizontal', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("horizontal" IN (0, 1))'));
  static const d.VerificationMeta _canopyMeta =
      const d.VerificationMeta('canopy');
  @override
  late final d.GeneratedColumn<bool> canopy = d.GeneratedColumn<bool>(
      'canopy', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("canopy" IN (0, 1))'));
  static const d.VerificationMeta _soilProfileMeta =
      const d.VerificationMeta('soilProfile');
  @override
  late final d.GeneratedColumn<bool> soilProfile = d.GeneratedColumn<bool>(
      'soil_profile', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("soil_profile" IN (0, 1))'));
  static const d.VerificationMeta _otherOneMeta =
      const d.VerificationMeta('otherOne');
  @override
  late final d.GeneratedColumn<bool> otherOne = d.GeneratedColumn<bool>(
      'other_one', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("other_one" IN (0, 1))'));
  static const d.VerificationMeta _otherTwoMeta =
      const d.VerificationMeta('otherTwo');
  @override
  late final d.GeneratedColumn<bool> otherTwo = d.GeneratedColumn<bool>(
      'other_two', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("other_two" IN (0, 1))'));
  static const d.VerificationMeta _otherThreeMeta =
      const d.VerificationMeta('otherThree');
  @override
  late final d.GeneratedColumn<bool> otherThree = d.GeneratedColumn<bool>(
      'other_three', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("other_three" IN (0, 1))'));
  static const d.VerificationMeta _otherFourMeta =
      const d.VerificationMeta('otherFour');
  @override
  late final d.GeneratedColumn<bool> otherFour = d.GeneratedColumn<bool>(
      'other_four', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("other_four" IN (0, 1))'));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        plotPin,
        transectOneFifteenUnder,
        transectOneFifteenOver,
        transectTwoFifteenUnder,
        transectTwoFifteenOver,
        horizontal,
        canopy,
        soilProfile,
        otherOne,
        otherTwo,
        otherThree,
        otherFour
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_header_ground_photo';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurveyHeaderGroundPhotoData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('plot_pin')) {
      context.handle(_plotPinMeta,
          plotPin.isAcceptableOrUnknown(data['plot_pin']!, _plotPinMeta));
    }
    if (data.containsKey('transect_one_fifteen_under')) {
      context.handle(
          _transectOneFifteenUnderMeta,
          transectOneFifteenUnder.isAcceptableOrUnknown(
              data['transect_one_fifteen_under']!,
              _transectOneFifteenUnderMeta));
    }
    if (data.containsKey('transect_one_fifteen_over')) {
      context.handle(
          _transectOneFifteenOverMeta,
          transectOneFifteenOver.isAcceptableOrUnknown(
              data['transect_one_fifteen_over']!, _transectOneFifteenOverMeta));
    }
    if (data.containsKey('transect_two_fifteen_under')) {
      context.handle(
          _transectTwoFifteenUnderMeta,
          transectTwoFifteenUnder.isAcceptableOrUnknown(
              data['transect_two_fifteen_under']!,
              _transectTwoFifteenUnderMeta));
    }
    if (data.containsKey('transect_two_fifteen_over')) {
      context.handle(
          _transectTwoFifteenOverMeta,
          transectTwoFifteenOver.isAcceptableOrUnknown(
              data['transect_two_fifteen_over']!, _transectTwoFifteenOverMeta));
    }
    if (data.containsKey('horizontal')) {
      context.handle(
          _horizontalMeta,
          horizontal.isAcceptableOrUnknown(
              data['horizontal']!, _horizontalMeta));
    }
    if (data.containsKey('canopy')) {
      context.handle(_canopyMeta,
          canopy.isAcceptableOrUnknown(data['canopy']!, _canopyMeta));
    }
    if (data.containsKey('soil_profile')) {
      context.handle(
          _soilProfileMeta,
          soilProfile.isAcceptableOrUnknown(
              data['soil_profile']!, _soilProfileMeta));
    }
    if (data.containsKey('other_one')) {
      context.handle(_otherOneMeta,
          otherOne.isAcceptableOrUnknown(data['other_one']!, _otherOneMeta));
    }
    if (data.containsKey('other_two')) {
      context.handle(_otherTwoMeta,
          otherTwo.isAcceptableOrUnknown(data['other_two']!, _otherTwoMeta));
    }
    if (data.containsKey('other_three')) {
      context.handle(
          _otherThreeMeta,
          otherThree.isAcceptableOrUnknown(
              data['other_three']!, _otherThreeMeta));
    }
    if (data.containsKey('other_four')) {
      context.handle(_otherFourMeta,
          otherFour.isAcceptableOrUnknown(data['other_four']!, _otherFourMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveyHeaderGroundPhotoData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveyHeaderGroundPhotoData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      plotPin: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}plot_pin']),
      transectOneFifteenUnder: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}transect_one_fifteen_under']),
      transectOneFifteenOver: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}transect_one_fifteen_over']),
      transectTwoFifteenUnder: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}transect_two_fifteen_under']),
      transectTwoFifteenOver: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}transect_two_fifteen_over']),
      horizontal: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}horizontal']),
      canopy: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}canopy']),
      soilProfile: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}soil_profile']),
      otherOne: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}other_one']),
      otherTwo: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}other_two']),
      otherThree: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}other_three']),
      otherFour: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}other_four']),
    );
  }

  @override
  $SurveyHeaderGroundPhotoTable createAlias(String alias) {
    return $SurveyHeaderGroundPhotoTable(attachedDatabase, alias);
  }
}

class SurveyHeaderGroundPhotoData extends d.DataClass
    implements d.Insertable<SurveyHeaderGroundPhotoData> {
  final int id;
  final int surveyId;
  final bool? plotPin;
  final bool? transectOneFifteenUnder;
  final bool? transectOneFifteenOver;
  final bool? transectTwoFifteenUnder;
  final bool? transectTwoFifteenOver;
  final bool? horizontal;
  final bool? canopy;
  final bool? soilProfile;
  final bool? otherOne;
  final bool? otherTwo;
  final bool? otherThree;
  final bool? otherFour;
  const SurveyHeaderGroundPhotoData(
      {required this.id,
      required this.surveyId,
      this.plotPin,
      this.transectOneFifteenUnder,
      this.transectOneFifteenOver,
      this.transectTwoFifteenUnder,
      this.transectTwoFifteenOver,
      this.horizontal,
      this.canopy,
      this.soilProfile,
      this.otherOne,
      this.otherTwo,
      this.otherThree,
      this.otherFour});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    if (!nullToAbsent || plotPin != null) {
      map['plot_pin'] = d.Variable<bool>(plotPin);
    }
    if (!nullToAbsent || transectOneFifteenUnder != null) {
      map['transect_one_fifteen_under'] =
          d.Variable<bool>(transectOneFifteenUnder);
    }
    if (!nullToAbsent || transectOneFifteenOver != null) {
      map['transect_one_fifteen_over'] =
          d.Variable<bool>(transectOneFifteenOver);
    }
    if (!nullToAbsent || transectTwoFifteenUnder != null) {
      map['transect_two_fifteen_under'] =
          d.Variable<bool>(transectTwoFifteenUnder);
    }
    if (!nullToAbsent || transectTwoFifteenOver != null) {
      map['transect_two_fifteen_over'] =
          d.Variable<bool>(transectTwoFifteenOver);
    }
    if (!nullToAbsent || horizontal != null) {
      map['horizontal'] = d.Variable<bool>(horizontal);
    }
    if (!nullToAbsent || canopy != null) {
      map['canopy'] = d.Variable<bool>(canopy);
    }
    if (!nullToAbsent || soilProfile != null) {
      map['soil_profile'] = d.Variable<bool>(soilProfile);
    }
    if (!nullToAbsent || otherOne != null) {
      map['other_one'] = d.Variable<bool>(otherOne);
    }
    if (!nullToAbsent || otherTwo != null) {
      map['other_two'] = d.Variable<bool>(otherTwo);
    }
    if (!nullToAbsent || otherThree != null) {
      map['other_three'] = d.Variable<bool>(otherThree);
    }
    if (!nullToAbsent || otherFour != null) {
      map['other_four'] = d.Variable<bool>(otherFour);
    }
    return map;
  }

  SurveyHeaderGroundPhotoCompanion toCompanion(bool nullToAbsent) {
    return SurveyHeaderGroundPhotoCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      plotPin: plotPin == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(plotPin),
      transectOneFifteenUnder: transectOneFifteenUnder == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transectOneFifteenUnder),
      transectOneFifteenOver: transectOneFifteenOver == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transectOneFifteenOver),
      transectTwoFifteenUnder: transectTwoFifteenUnder == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transectTwoFifteenUnder),
      transectTwoFifteenOver: transectTwoFifteenOver == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transectTwoFifteenOver),
      horizontal: horizontal == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(horizontal),
      canopy: canopy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(canopy),
      soilProfile: soilProfile == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(soilProfile),
      otherOne: otherOne == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(otherOne),
      otherTwo: otherTwo == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(otherTwo),
      otherThree: otherThree == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(otherThree),
      otherFour: otherFour == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(otherFour),
    );
  }

  factory SurveyHeaderGroundPhotoData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveyHeaderGroundPhotoData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      plotPin: serializer.fromJson<bool?>(json['plotPin']),
      transectOneFifteenUnder:
          serializer.fromJson<bool?>(json['transectOneFifteenUnder']),
      transectOneFifteenOver:
          serializer.fromJson<bool?>(json['transectOneFifteenOver']),
      transectTwoFifteenUnder:
          serializer.fromJson<bool?>(json['transectTwoFifteenUnder']),
      transectTwoFifteenOver:
          serializer.fromJson<bool?>(json['transectTwoFifteenOver']),
      horizontal: serializer.fromJson<bool?>(json['horizontal']),
      canopy: serializer.fromJson<bool?>(json['canopy']),
      soilProfile: serializer.fromJson<bool?>(json['soilProfile']),
      otherOne: serializer.fromJson<bool?>(json['otherOne']),
      otherTwo: serializer.fromJson<bool?>(json['otherTwo']),
      otherThree: serializer.fromJson<bool?>(json['otherThree']),
      otherFour: serializer.fromJson<bool?>(json['otherFour']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'plotPin': serializer.toJson<bool?>(plotPin),
      'transectOneFifteenUnder':
          serializer.toJson<bool?>(transectOneFifteenUnder),
      'transectOneFifteenOver':
          serializer.toJson<bool?>(transectOneFifteenOver),
      'transectTwoFifteenUnder':
          serializer.toJson<bool?>(transectTwoFifteenUnder),
      'transectTwoFifteenOver':
          serializer.toJson<bool?>(transectTwoFifteenOver),
      'horizontal': serializer.toJson<bool?>(horizontal),
      'canopy': serializer.toJson<bool?>(canopy),
      'soilProfile': serializer.toJson<bool?>(soilProfile),
      'otherOne': serializer.toJson<bool?>(otherOne),
      'otherTwo': serializer.toJson<bool?>(otherTwo),
      'otherThree': serializer.toJson<bool?>(otherThree),
      'otherFour': serializer.toJson<bool?>(otherFour),
    };
  }

  SurveyHeaderGroundPhotoData copyWith(
          {int? id,
          int? surveyId,
          d.Value<bool?> plotPin = const d.Value.absent(),
          d.Value<bool?> transectOneFifteenUnder = const d.Value.absent(),
          d.Value<bool?> transectOneFifteenOver = const d.Value.absent(),
          d.Value<bool?> transectTwoFifteenUnder = const d.Value.absent(),
          d.Value<bool?> transectTwoFifteenOver = const d.Value.absent(),
          d.Value<bool?> horizontal = const d.Value.absent(),
          d.Value<bool?> canopy = const d.Value.absent(),
          d.Value<bool?> soilProfile = const d.Value.absent(),
          d.Value<bool?> otherOne = const d.Value.absent(),
          d.Value<bool?> otherTwo = const d.Value.absent(),
          d.Value<bool?> otherThree = const d.Value.absent(),
          d.Value<bool?> otherFour = const d.Value.absent()}) =>
      SurveyHeaderGroundPhotoData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        plotPin: plotPin.present ? plotPin.value : this.plotPin,
        transectOneFifteenUnder: transectOneFifteenUnder.present
            ? transectOneFifteenUnder.value
            : this.transectOneFifteenUnder,
        transectOneFifteenOver: transectOneFifteenOver.present
            ? transectOneFifteenOver.value
            : this.transectOneFifteenOver,
        transectTwoFifteenUnder: transectTwoFifteenUnder.present
            ? transectTwoFifteenUnder.value
            : this.transectTwoFifteenUnder,
        transectTwoFifteenOver: transectTwoFifteenOver.present
            ? transectTwoFifteenOver.value
            : this.transectTwoFifteenOver,
        horizontal: horizontal.present ? horizontal.value : this.horizontal,
        canopy: canopy.present ? canopy.value : this.canopy,
        soilProfile: soilProfile.present ? soilProfile.value : this.soilProfile,
        otherOne: otherOne.present ? otherOne.value : this.otherOne,
        otherTwo: otherTwo.present ? otherTwo.value : this.otherTwo,
        otherThree: otherThree.present ? otherThree.value : this.otherThree,
        otherFour: otherFour.present ? otherFour.value : this.otherFour,
      );
  @override
  String toString() {
    return (StringBuffer('SurveyHeaderGroundPhotoData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('plotPin: $plotPin, ')
          ..write('transectOneFifteenUnder: $transectOneFifteenUnder, ')
          ..write('transectOneFifteenOver: $transectOneFifteenOver, ')
          ..write('transectTwoFifteenUnder: $transectTwoFifteenUnder, ')
          ..write('transectTwoFifteenOver: $transectTwoFifteenOver, ')
          ..write('horizontal: $horizontal, ')
          ..write('canopy: $canopy, ')
          ..write('soilProfile: $soilProfile, ')
          ..write('otherOne: $otherOne, ')
          ..write('otherTwo: $otherTwo, ')
          ..write('otherThree: $otherThree, ')
          ..write('otherFour: $otherFour')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      surveyId,
      plotPin,
      transectOneFifteenUnder,
      transectOneFifteenOver,
      transectTwoFifteenUnder,
      transectTwoFifteenOver,
      horizontal,
      canopy,
      soilProfile,
      otherOne,
      otherTwo,
      otherThree,
      otherFour);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveyHeaderGroundPhotoData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.plotPin == this.plotPin &&
          other.transectOneFifteenUnder == this.transectOneFifteenUnder &&
          other.transectOneFifteenOver == this.transectOneFifteenOver &&
          other.transectTwoFifteenUnder == this.transectTwoFifteenUnder &&
          other.transectTwoFifteenOver == this.transectTwoFifteenOver &&
          other.horizontal == this.horizontal &&
          other.canopy == this.canopy &&
          other.soilProfile == this.soilProfile &&
          other.otherOne == this.otherOne &&
          other.otherTwo == this.otherTwo &&
          other.otherThree == this.otherThree &&
          other.otherFour == this.otherFour);
}

class SurveyHeaderGroundPhotoCompanion
    extends d.UpdateCompanion<SurveyHeaderGroundPhotoData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<bool?> plotPin;
  final d.Value<bool?> transectOneFifteenUnder;
  final d.Value<bool?> transectOneFifteenOver;
  final d.Value<bool?> transectTwoFifteenUnder;
  final d.Value<bool?> transectTwoFifteenOver;
  final d.Value<bool?> horizontal;
  final d.Value<bool?> canopy;
  final d.Value<bool?> soilProfile;
  final d.Value<bool?> otherOne;
  final d.Value<bool?> otherTwo;
  final d.Value<bool?> otherThree;
  final d.Value<bool?> otherFour;
  const SurveyHeaderGroundPhotoCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.plotPin = const d.Value.absent(),
    this.transectOneFifteenUnder = const d.Value.absent(),
    this.transectOneFifteenOver = const d.Value.absent(),
    this.transectTwoFifteenUnder = const d.Value.absent(),
    this.transectTwoFifteenOver = const d.Value.absent(),
    this.horizontal = const d.Value.absent(),
    this.canopy = const d.Value.absent(),
    this.soilProfile = const d.Value.absent(),
    this.otherOne = const d.Value.absent(),
    this.otherTwo = const d.Value.absent(),
    this.otherThree = const d.Value.absent(),
    this.otherFour = const d.Value.absent(),
  });
  SurveyHeaderGroundPhotoCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    this.plotPin = const d.Value.absent(),
    this.transectOneFifteenUnder = const d.Value.absent(),
    this.transectOneFifteenOver = const d.Value.absent(),
    this.transectTwoFifteenUnder = const d.Value.absent(),
    this.transectTwoFifteenOver = const d.Value.absent(),
    this.horizontal = const d.Value.absent(),
    this.canopy = const d.Value.absent(),
    this.soilProfile = const d.Value.absent(),
    this.otherOne = const d.Value.absent(),
    this.otherTwo = const d.Value.absent(),
    this.otherThree = const d.Value.absent(),
    this.otherFour = const d.Value.absent(),
  }) : surveyId = d.Value(surveyId);
  static d.Insertable<SurveyHeaderGroundPhotoData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<bool>? plotPin,
    d.Expression<bool>? transectOneFifteenUnder,
    d.Expression<bool>? transectOneFifteenOver,
    d.Expression<bool>? transectTwoFifteenUnder,
    d.Expression<bool>? transectTwoFifteenOver,
    d.Expression<bool>? horizontal,
    d.Expression<bool>? canopy,
    d.Expression<bool>? soilProfile,
    d.Expression<bool>? otherOne,
    d.Expression<bool>? otherTwo,
    d.Expression<bool>? otherThree,
    d.Expression<bool>? otherFour,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (plotPin != null) 'plot_pin': plotPin,
      if (transectOneFifteenUnder != null)
        'transect_one_fifteen_under': transectOneFifteenUnder,
      if (transectOneFifteenOver != null)
        'transect_one_fifteen_over': transectOneFifteenOver,
      if (transectTwoFifteenUnder != null)
        'transect_two_fifteen_under': transectTwoFifteenUnder,
      if (transectTwoFifteenOver != null)
        'transect_two_fifteen_over': transectTwoFifteenOver,
      if (horizontal != null) 'horizontal': horizontal,
      if (canopy != null) 'canopy': canopy,
      if (soilProfile != null) 'soil_profile': soilProfile,
      if (otherOne != null) 'other_one': otherOne,
      if (otherTwo != null) 'other_two': otherTwo,
      if (otherThree != null) 'other_three': otherThree,
      if (otherFour != null) 'other_four': otherFour,
    });
  }

  SurveyHeaderGroundPhotoCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<bool?>? plotPin,
      d.Value<bool?>? transectOneFifteenUnder,
      d.Value<bool?>? transectOneFifteenOver,
      d.Value<bool?>? transectTwoFifteenUnder,
      d.Value<bool?>? transectTwoFifteenOver,
      d.Value<bool?>? horizontal,
      d.Value<bool?>? canopy,
      d.Value<bool?>? soilProfile,
      d.Value<bool?>? otherOne,
      d.Value<bool?>? otherTwo,
      d.Value<bool?>? otherThree,
      d.Value<bool?>? otherFour}) {
    return SurveyHeaderGroundPhotoCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      plotPin: plotPin ?? this.plotPin,
      transectOneFifteenUnder:
          transectOneFifteenUnder ?? this.transectOneFifteenUnder,
      transectOneFifteenOver:
          transectOneFifteenOver ?? this.transectOneFifteenOver,
      transectTwoFifteenUnder:
          transectTwoFifteenUnder ?? this.transectTwoFifteenUnder,
      transectTwoFifteenOver:
          transectTwoFifteenOver ?? this.transectTwoFifteenOver,
      horizontal: horizontal ?? this.horizontal,
      canopy: canopy ?? this.canopy,
      soilProfile: soilProfile ?? this.soilProfile,
      otherOne: otherOne ?? this.otherOne,
      otherTwo: otherTwo ?? this.otherTwo,
      otherThree: otherThree ?? this.otherThree,
      otherFour: otherFour ?? this.otherFour,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (plotPin.present) {
      map['plot_pin'] = d.Variable<bool>(plotPin.value);
    }
    if (transectOneFifteenUnder.present) {
      map['transect_one_fifteen_under'] =
          d.Variable<bool>(transectOneFifteenUnder.value);
    }
    if (transectOneFifteenOver.present) {
      map['transect_one_fifteen_over'] =
          d.Variable<bool>(transectOneFifteenOver.value);
    }
    if (transectTwoFifteenUnder.present) {
      map['transect_two_fifteen_under'] =
          d.Variable<bool>(transectTwoFifteenUnder.value);
    }
    if (transectTwoFifteenOver.present) {
      map['transect_two_fifteen_over'] =
          d.Variable<bool>(transectTwoFifteenOver.value);
    }
    if (horizontal.present) {
      map['horizontal'] = d.Variable<bool>(horizontal.value);
    }
    if (canopy.present) {
      map['canopy'] = d.Variable<bool>(canopy.value);
    }
    if (soilProfile.present) {
      map['soil_profile'] = d.Variable<bool>(soilProfile.value);
    }
    if (otherOne.present) {
      map['other_one'] = d.Variable<bool>(otherOne.value);
    }
    if (otherTwo.present) {
      map['other_two'] = d.Variable<bool>(otherTwo.value);
    }
    if (otherThree.present) {
      map['other_three'] = d.Variable<bool>(otherThree.value);
    }
    if (otherFour.present) {
      map['other_four'] = d.Variable<bool>(otherFour.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveyHeaderGroundPhotoCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('plotPin: $plotPin, ')
          ..write('transectOneFifteenUnder: $transectOneFifteenUnder, ')
          ..write('transectOneFifteenOver: $transectOneFifteenOver, ')
          ..write('transectTwoFifteenUnder: $transectTwoFifteenUnder, ')
          ..write('transectTwoFifteenOver: $transectTwoFifteenOver, ')
          ..write('horizontal: $horizontal, ')
          ..write('canopy: $canopy, ')
          ..write('soilProfile: $soilProfile, ')
          ..write('otherOne: $otherOne, ')
          ..write('otherTwo: $otherTwo, ')
          ..write('otherThree: $otherThree, ')
          ..write('otherFour: $otherFour')
          ..write(')'))
        .toString();
  }
}

class $SurveyHeaderTreeTable extends SurveyHeaderTree
    with d.TableInfo<$SurveyHeaderTreeTable, SurveyHeaderTreeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveyHeaderTreeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _fieldResponsibilityMeta =
      const d.VerificationMeta('fieldResponsibility');
  @override
  late final d.GeneratedColumn<String> fieldResponsibility =
      d.GeneratedColumn<String>('field_responsibility', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldCheckByMeta =
      const d.VerificationMeta('fieldCheckBy');
  @override
  late final d.GeneratedColumn<String> fieldCheckBy = d.GeneratedColumn<String>(
      'field_check_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldDateMeta =
      const d.VerificationMeta('fieldDate');
  @override
  late final d.GeneratedColumn<DateTime> fieldDate =
      d.GeneratedColumn<DateTime>('field_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const d.VerificationMeta _officeCheckByMeta =
      const d.VerificationMeta('officeCheckBy');
  @override
  late final d.GeneratedColumn<String> officeCheckBy =
      d.GeneratedColumn<String>('office_check_by', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _officeDateMeta =
      const d.VerificationMeta('officeDate');
  @override
  late final d.GeneratedColumn<DateTime> officeDate =
      d.GeneratedColumn<DateTime>('office_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        fieldResponsibility,
        fieldCheckBy,
        fieldDate,
        officeCheckBy,
        officeDate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_header_tree';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurveyHeaderTreeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('field_responsibility')) {
      context.handle(
          _fieldResponsibilityMeta,
          fieldResponsibility.isAcceptableOrUnknown(
              data['field_responsibility']!, _fieldResponsibilityMeta));
    }
    if (data.containsKey('field_check_by')) {
      context.handle(
          _fieldCheckByMeta,
          fieldCheckBy.isAcceptableOrUnknown(
              data['field_check_by']!, _fieldCheckByMeta));
    }
    if (data.containsKey('field_date')) {
      context.handle(_fieldDateMeta,
          fieldDate.isAcceptableOrUnknown(data['field_date']!, _fieldDateMeta));
    }
    if (data.containsKey('office_check_by')) {
      context.handle(
          _officeCheckByMeta,
          officeCheckBy.isAcceptableOrUnknown(
              data['office_check_by']!, _officeCheckByMeta));
    }
    if (data.containsKey('office_date')) {
      context.handle(
          _officeDateMeta,
          officeDate.isAcceptableOrUnknown(
              data['office_date']!, _officeDateMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveyHeaderTreeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveyHeaderTreeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      fieldResponsibility: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}field_responsibility']),
      fieldCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}field_check_by']),
      fieldDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}field_date']),
      officeCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}office_check_by']),
      officeDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}office_date']),
    );
  }

  @override
  $SurveyHeaderTreeTable createAlias(String alias) {
    return $SurveyHeaderTreeTable(attachedDatabase, alias);
  }
}

class SurveyHeaderTreeData extends d.DataClass
    implements d.Insertable<SurveyHeaderTreeData> {
  final int id;
  final int surveyId;
  final String? fieldResponsibility;
  final String? fieldCheckBy;
  final DateTime? fieldDate;
  final String? officeCheckBy;
  final DateTime? officeDate;
  const SurveyHeaderTreeData(
      {required this.id,
      required this.surveyId,
      this.fieldResponsibility,
      this.fieldCheckBy,
      this.fieldDate,
      this.officeCheckBy,
      this.officeDate});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    if (!nullToAbsent || fieldResponsibility != null) {
      map['field_responsibility'] = d.Variable<String>(fieldResponsibility);
    }
    if (!nullToAbsent || fieldCheckBy != null) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy);
    }
    if (!nullToAbsent || fieldDate != null) {
      map['field_date'] = d.Variable<DateTime>(fieldDate);
    }
    if (!nullToAbsent || officeCheckBy != null) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy);
    }
    if (!nullToAbsent || officeDate != null) {
      map['office_date'] = d.Variable<DateTime>(officeDate);
    }
    return map;
  }

  SurveyHeaderTreeCompanion toCompanion(bool nullToAbsent) {
    return SurveyHeaderTreeCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      fieldResponsibility: fieldResponsibility == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldResponsibility),
      fieldCheckBy: fieldCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldCheckBy),
      fieldDate: fieldDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldDate),
      officeCheckBy: officeCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeCheckBy),
      officeDate: officeDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeDate),
    );
  }

  factory SurveyHeaderTreeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveyHeaderTreeData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      fieldResponsibility:
          serializer.fromJson<String?>(json['fieldResponsibility']),
      fieldCheckBy: serializer.fromJson<String?>(json['fieldCheckBy']),
      fieldDate: serializer.fromJson<DateTime?>(json['fieldDate']),
      officeCheckBy: serializer.fromJson<String?>(json['officeCheckBy']),
      officeDate: serializer.fromJson<DateTime?>(json['officeDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'fieldResponsibility': serializer.toJson<String?>(fieldResponsibility),
      'fieldCheckBy': serializer.toJson<String?>(fieldCheckBy),
      'fieldDate': serializer.toJson<DateTime?>(fieldDate),
      'officeCheckBy': serializer.toJson<String?>(officeCheckBy),
      'officeDate': serializer.toJson<DateTime?>(officeDate),
    };
  }

  SurveyHeaderTreeData copyWith(
          {int? id,
          int? surveyId,
          d.Value<String?> fieldResponsibility = const d.Value.absent(),
          d.Value<String?> fieldCheckBy = const d.Value.absent(),
          d.Value<DateTime?> fieldDate = const d.Value.absent(),
          d.Value<String?> officeCheckBy = const d.Value.absent(),
          d.Value<DateTime?> officeDate = const d.Value.absent()}) =>
      SurveyHeaderTreeData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        fieldResponsibility: fieldResponsibility.present
            ? fieldResponsibility.value
            : this.fieldResponsibility,
        fieldCheckBy:
            fieldCheckBy.present ? fieldCheckBy.value : this.fieldCheckBy,
        fieldDate: fieldDate.present ? fieldDate.value : this.fieldDate,
        officeCheckBy:
            officeCheckBy.present ? officeCheckBy.value : this.officeCheckBy,
        officeDate: officeDate.present ? officeDate.value : this.officeDate,
      );
  @override
  String toString() {
    return (StringBuffer('SurveyHeaderTreeData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, fieldResponsibility,
      fieldCheckBy, fieldDate, officeCheckBy, officeDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveyHeaderTreeData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.fieldResponsibility == this.fieldResponsibility &&
          other.fieldCheckBy == this.fieldCheckBy &&
          other.fieldDate == this.fieldDate &&
          other.officeCheckBy == this.officeCheckBy &&
          other.officeDate == this.officeDate);
}

class SurveyHeaderTreeCompanion
    extends d.UpdateCompanion<SurveyHeaderTreeData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<String?> fieldResponsibility;
  final d.Value<String?> fieldCheckBy;
  final d.Value<DateTime?> fieldDate;
  final d.Value<String?> officeCheckBy;
  final d.Value<DateTime?> officeDate;
  const SurveyHeaderTreeCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  });
  SurveyHeaderTreeCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  }) : surveyId = d.Value(surveyId);
  static d.Insertable<SurveyHeaderTreeData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<String>? fieldResponsibility,
    d.Expression<String>? fieldCheckBy,
    d.Expression<DateTime>? fieldDate,
    d.Expression<String>? officeCheckBy,
    d.Expression<DateTime>? officeDate,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (fieldResponsibility != null)
        'field_responsibility': fieldResponsibility,
      if (fieldCheckBy != null) 'field_check_by': fieldCheckBy,
      if (fieldDate != null) 'field_date': fieldDate,
      if (officeCheckBy != null) 'office_check_by': officeCheckBy,
      if (officeDate != null) 'office_date': officeDate,
    });
  }

  SurveyHeaderTreeCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<String?>? fieldResponsibility,
      d.Value<String?>? fieldCheckBy,
      d.Value<DateTime?>? fieldDate,
      d.Value<String?>? officeCheckBy,
      d.Value<DateTime?>? officeDate}) {
    return SurveyHeaderTreeCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      fieldResponsibility: fieldResponsibility ?? this.fieldResponsibility,
      fieldCheckBy: fieldCheckBy ?? this.fieldCheckBy,
      fieldDate: fieldDate ?? this.fieldDate,
      officeCheckBy: officeCheckBy ?? this.officeCheckBy,
      officeDate: officeDate ?? this.officeDate,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (fieldResponsibility.present) {
      map['field_responsibility'] =
          d.Variable<String>(fieldResponsibility.value);
    }
    if (fieldCheckBy.present) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy.value);
    }
    if (fieldDate.present) {
      map['field_date'] = d.Variable<DateTime>(fieldDate.value);
    }
    if (officeCheckBy.present) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy.value);
    }
    if (officeDate.present) {
      map['office_date'] = d.Variable<DateTime>(officeDate.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveyHeaderTreeCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }
}

class $SurveyHeaderEcologicalTable extends SurveyHeaderEcological
    with d.TableInfo<$SurveyHeaderEcologicalTable, SurveyHeaderEcologicalData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveyHeaderEcologicalTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _fieldResponsibilityMeta =
      const d.VerificationMeta('fieldResponsibility');
  @override
  late final d.GeneratedColumn<String> fieldResponsibility =
      d.GeneratedColumn<String>('field_responsibility', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldCheckByMeta =
      const d.VerificationMeta('fieldCheckBy');
  @override
  late final d.GeneratedColumn<String> fieldCheckBy = d.GeneratedColumn<String>(
      'field_check_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldDateMeta =
      const d.VerificationMeta('fieldDate');
  @override
  late final d.GeneratedColumn<DateTime> fieldDate =
      d.GeneratedColumn<DateTime>('field_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const d.VerificationMeta _officeCheckByMeta =
      const d.VerificationMeta('officeCheckBy');
  @override
  late final d.GeneratedColumn<String> officeCheckBy =
      d.GeneratedColumn<String>('office_check_by', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _officeDateMeta =
      const d.VerificationMeta('officeDate');
  @override
  late final d.GeneratedColumn<DateTime> officeDate =
      d.GeneratedColumn<DateTime>('office_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        fieldResponsibility,
        fieldCheckBy,
        fieldDate,
        officeCheckBy,
        officeDate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_header_ecological';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurveyHeaderEcologicalData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('field_responsibility')) {
      context.handle(
          _fieldResponsibilityMeta,
          fieldResponsibility.isAcceptableOrUnknown(
              data['field_responsibility']!, _fieldResponsibilityMeta));
    }
    if (data.containsKey('field_check_by')) {
      context.handle(
          _fieldCheckByMeta,
          fieldCheckBy.isAcceptableOrUnknown(
              data['field_check_by']!, _fieldCheckByMeta));
    }
    if (data.containsKey('field_date')) {
      context.handle(_fieldDateMeta,
          fieldDate.isAcceptableOrUnknown(data['field_date']!, _fieldDateMeta));
    }
    if (data.containsKey('office_check_by')) {
      context.handle(
          _officeCheckByMeta,
          officeCheckBy.isAcceptableOrUnknown(
              data['office_check_by']!, _officeCheckByMeta));
    }
    if (data.containsKey('office_date')) {
      context.handle(
          _officeDateMeta,
          officeDate.isAcceptableOrUnknown(
              data['office_date']!, _officeDateMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveyHeaderEcologicalData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveyHeaderEcologicalData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      fieldResponsibility: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}field_responsibility']),
      fieldCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}field_check_by']),
      fieldDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}field_date']),
      officeCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}office_check_by']),
      officeDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}office_date']),
    );
  }

  @override
  $SurveyHeaderEcologicalTable createAlias(String alias) {
    return $SurveyHeaderEcologicalTable(attachedDatabase, alias);
  }
}

class SurveyHeaderEcologicalData extends d.DataClass
    implements d.Insertable<SurveyHeaderEcologicalData> {
  final int id;
  final int surveyId;
  final String? fieldResponsibility;
  final String? fieldCheckBy;
  final DateTime? fieldDate;
  final String? officeCheckBy;
  final DateTime? officeDate;
  const SurveyHeaderEcologicalData(
      {required this.id,
      required this.surveyId,
      this.fieldResponsibility,
      this.fieldCheckBy,
      this.fieldDate,
      this.officeCheckBy,
      this.officeDate});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    if (!nullToAbsent || fieldResponsibility != null) {
      map['field_responsibility'] = d.Variable<String>(fieldResponsibility);
    }
    if (!nullToAbsent || fieldCheckBy != null) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy);
    }
    if (!nullToAbsent || fieldDate != null) {
      map['field_date'] = d.Variable<DateTime>(fieldDate);
    }
    if (!nullToAbsent || officeCheckBy != null) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy);
    }
    if (!nullToAbsent || officeDate != null) {
      map['office_date'] = d.Variable<DateTime>(officeDate);
    }
    return map;
  }

  SurveyHeaderEcologicalCompanion toCompanion(bool nullToAbsent) {
    return SurveyHeaderEcologicalCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      fieldResponsibility: fieldResponsibility == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldResponsibility),
      fieldCheckBy: fieldCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldCheckBy),
      fieldDate: fieldDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldDate),
      officeCheckBy: officeCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeCheckBy),
      officeDate: officeDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeDate),
    );
  }

  factory SurveyHeaderEcologicalData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveyHeaderEcologicalData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      fieldResponsibility:
          serializer.fromJson<String?>(json['fieldResponsibility']),
      fieldCheckBy: serializer.fromJson<String?>(json['fieldCheckBy']),
      fieldDate: serializer.fromJson<DateTime?>(json['fieldDate']),
      officeCheckBy: serializer.fromJson<String?>(json['officeCheckBy']),
      officeDate: serializer.fromJson<DateTime?>(json['officeDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'fieldResponsibility': serializer.toJson<String?>(fieldResponsibility),
      'fieldCheckBy': serializer.toJson<String?>(fieldCheckBy),
      'fieldDate': serializer.toJson<DateTime?>(fieldDate),
      'officeCheckBy': serializer.toJson<String?>(officeCheckBy),
      'officeDate': serializer.toJson<DateTime?>(officeDate),
    };
  }

  SurveyHeaderEcologicalData copyWith(
          {int? id,
          int? surveyId,
          d.Value<String?> fieldResponsibility = const d.Value.absent(),
          d.Value<String?> fieldCheckBy = const d.Value.absent(),
          d.Value<DateTime?> fieldDate = const d.Value.absent(),
          d.Value<String?> officeCheckBy = const d.Value.absent(),
          d.Value<DateTime?> officeDate = const d.Value.absent()}) =>
      SurveyHeaderEcologicalData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        fieldResponsibility: fieldResponsibility.present
            ? fieldResponsibility.value
            : this.fieldResponsibility,
        fieldCheckBy:
            fieldCheckBy.present ? fieldCheckBy.value : this.fieldCheckBy,
        fieldDate: fieldDate.present ? fieldDate.value : this.fieldDate,
        officeCheckBy:
            officeCheckBy.present ? officeCheckBy.value : this.officeCheckBy,
        officeDate: officeDate.present ? officeDate.value : this.officeDate,
      );
  @override
  String toString() {
    return (StringBuffer('SurveyHeaderEcologicalData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, fieldResponsibility,
      fieldCheckBy, fieldDate, officeCheckBy, officeDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveyHeaderEcologicalData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.fieldResponsibility == this.fieldResponsibility &&
          other.fieldCheckBy == this.fieldCheckBy &&
          other.fieldDate == this.fieldDate &&
          other.officeCheckBy == this.officeCheckBy &&
          other.officeDate == this.officeDate);
}

class SurveyHeaderEcologicalCompanion
    extends d.UpdateCompanion<SurveyHeaderEcologicalData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<String?> fieldResponsibility;
  final d.Value<String?> fieldCheckBy;
  final d.Value<DateTime?> fieldDate;
  final d.Value<String?> officeCheckBy;
  final d.Value<DateTime?> officeDate;
  const SurveyHeaderEcologicalCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  });
  SurveyHeaderEcologicalCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  }) : surveyId = d.Value(surveyId);
  static d.Insertable<SurveyHeaderEcologicalData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<String>? fieldResponsibility,
    d.Expression<String>? fieldCheckBy,
    d.Expression<DateTime>? fieldDate,
    d.Expression<String>? officeCheckBy,
    d.Expression<DateTime>? officeDate,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (fieldResponsibility != null)
        'field_responsibility': fieldResponsibility,
      if (fieldCheckBy != null) 'field_check_by': fieldCheckBy,
      if (fieldDate != null) 'field_date': fieldDate,
      if (officeCheckBy != null) 'office_check_by': officeCheckBy,
      if (officeDate != null) 'office_date': officeDate,
    });
  }

  SurveyHeaderEcologicalCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<String?>? fieldResponsibility,
      d.Value<String?>? fieldCheckBy,
      d.Value<DateTime?>? fieldDate,
      d.Value<String?>? officeCheckBy,
      d.Value<DateTime?>? officeDate}) {
    return SurveyHeaderEcologicalCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      fieldResponsibility: fieldResponsibility ?? this.fieldResponsibility,
      fieldCheckBy: fieldCheckBy ?? this.fieldCheckBy,
      fieldDate: fieldDate ?? this.fieldDate,
      officeCheckBy: officeCheckBy ?? this.officeCheckBy,
      officeDate: officeDate ?? this.officeDate,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (fieldResponsibility.present) {
      map['field_responsibility'] =
          d.Variable<String>(fieldResponsibility.value);
    }
    if (fieldCheckBy.present) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy.value);
    }
    if (fieldDate.present) {
      map['field_date'] = d.Variable<DateTime>(fieldDate.value);
    }
    if (officeCheckBy.present) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy.value);
    }
    if (officeDate.present) {
      map['office_date'] = d.Variable<DateTime>(officeDate.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveyHeaderEcologicalCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }
}

class $SurveyHeaderSoilTable extends SurveyHeaderSoil
    with d.TableInfo<$SurveyHeaderSoilTable, SurveyHeaderSoilData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurveyHeaderSoilTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _fieldResponsibilityMeta =
      const d.VerificationMeta('fieldResponsibility');
  @override
  late final d.GeneratedColumn<String> fieldResponsibility =
      d.GeneratedColumn<String>('field_responsibility', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldCheckByMeta =
      const d.VerificationMeta('fieldCheckBy');
  @override
  late final d.GeneratedColumn<String> fieldCheckBy = d.GeneratedColumn<String>(
      'field_check_by', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _fieldDateMeta =
      const d.VerificationMeta('fieldDate');
  @override
  late final d.GeneratedColumn<DateTime> fieldDate =
      d.GeneratedColumn<DateTime>('field_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const d.VerificationMeta _officeCheckByMeta =
      const d.VerificationMeta('officeCheckBy');
  @override
  late final d.GeneratedColumn<String> officeCheckBy =
      d.GeneratedColumn<String>('office_check_by', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _officeDateMeta =
      const d.VerificationMeta('officeDate');
  @override
  late final d.GeneratedColumn<DateTime> officeDate =
      d.GeneratedColumn<DateTime>('office_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        fieldResponsibility,
        fieldCheckBy,
        fieldDate,
        officeCheckBy,
        officeDate
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'survey_header_soil';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurveyHeaderSoilData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('field_responsibility')) {
      context.handle(
          _fieldResponsibilityMeta,
          fieldResponsibility.isAcceptableOrUnknown(
              data['field_responsibility']!, _fieldResponsibilityMeta));
    }
    if (data.containsKey('field_check_by')) {
      context.handle(
          _fieldCheckByMeta,
          fieldCheckBy.isAcceptableOrUnknown(
              data['field_check_by']!, _fieldCheckByMeta));
    }
    if (data.containsKey('field_date')) {
      context.handle(_fieldDateMeta,
          fieldDate.isAcceptableOrUnknown(data['field_date']!, _fieldDateMeta));
    }
    if (data.containsKey('office_check_by')) {
      context.handle(
          _officeCheckByMeta,
          officeCheckBy.isAcceptableOrUnknown(
              data['office_check_by']!, _officeCheckByMeta));
    }
    if (data.containsKey('office_date')) {
      context.handle(
          _officeDateMeta,
          officeDate.isAcceptableOrUnknown(
              data['office_date']!, _officeDateMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurveyHeaderSoilData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurveyHeaderSoilData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      fieldResponsibility: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}field_responsibility']),
      fieldCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}field_check_by']),
      fieldDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}field_date']),
      officeCheckBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}office_check_by']),
      officeDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}office_date']),
    );
  }

  @override
  $SurveyHeaderSoilTable createAlias(String alias) {
    return $SurveyHeaderSoilTable(attachedDatabase, alias);
  }
}

class SurveyHeaderSoilData extends d.DataClass
    implements d.Insertable<SurveyHeaderSoilData> {
  final int id;
  final int surveyId;
  final String? fieldResponsibility;
  final String? fieldCheckBy;
  final DateTime? fieldDate;
  final String? officeCheckBy;
  final DateTime? officeDate;
  const SurveyHeaderSoilData(
      {required this.id,
      required this.surveyId,
      this.fieldResponsibility,
      this.fieldCheckBy,
      this.fieldDate,
      this.officeCheckBy,
      this.officeDate});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    if (!nullToAbsent || fieldResponsibility != null) {
      map['field_responsibility'] = d.Variable<String>(fieldResponsibility);
    }
    if (!nullToAbsent || fieldCheckBy != null) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy);
    }
    if (!nullToAbsent || fieldDate != null) {
      map['field_date'] = d.Variable<DateTime>(fieldDate);
    }
    if (!nullToAbsent || officeCheckBy != null) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy);
    }
    if (!nullToAbsent || officeDate != null) {
      map['office_date'] = d.Variable<DateTime>(officeDate);
    }
    return map;
  }

  SurveyHeaderSoilCompanion toCompanion(bool nullToAbsent) {
    return SurveyHeaderSoilCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      fieldResponsibility: fieldResponsibility == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldResponsibility),
      fieldCheckBy: fieldCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldCheckBy),
      fieldDate: fieldDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(fieldDate),
      officeCheckBy: officeCheckBy == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeCheckBy),
      officeDate: officeDate == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(officeDate),
    );
  }

  factory SurveyHeaderSoilData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurveyHeaderSoilData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      fieldResponsibility:
          serializer.fromJson<String?>(json['fieldResponsibility']),
      fieldCheckBy: serializer.fromJson<String?>(json['fieldCheckBy']),
      fieldDate: serializer.fromJson<DateTime?>(json['fieldDate']),
      officeCheckBy: serializer.fromJson<String?>(json['officeCheckBy']),
      officeDate: serializer.fromJson<DateTime?>(json['officeDate']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'fieldResponsibility': serializer.toJson<String?>(fieldResponsibility),
      'fieldCheckBy': serializer.toJson<String?>(fieldCheckBy),
      'fieldDate': serializer.toJson<DateTime?>(fieldDate),
      'officeCheckBy': serializer.toJson<String?>(officeCheckBy),
      'officeDate': serializer.toJson<DateTime?>(officeDate),
    };
  }

  SurveyHeaderSoilData copyWith(
          {int? id,
          int? surveyId,
          d.Value<String?> fieldResponsibility = const d.Value.absent(),
          d.Value<String?> fieldCheckBy = const d.Value.absent(),
          d.Value<DateTime?> fieldDate = const d.Value.absent(),
          d.Value<String?> officeCheckBy = const d.Value.absent(),
          d.Value<DateTime?> officeDate = const d.Value.absent()}) =>
      SurveyHeaderSoilData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        fieldResponsibility: fieldResponsibility.present
            ? fieldResponsibility.value
            : this.fieldResponsibility,
        fieldCheckBy:
            fieldCheckBy.present ? fieldCheckBy.value : this.fieldCheckBy,
        fieldDate: fieldDate.present ? fieldDate.value : this.fieldDate,
        officeCheckBy:
            officeCheckBy.present ? officeCheckBy.value : this.officeCheckBy,
        officeDate: officeDate.present ? officeDate.value : this.officeDate,
      );
  @override
  String toString() {
    return (StringBuffer('SurveyHeaderSoilData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, fieldResponsibility,
      fieldCheckBy, fieldDate, officeCheckBy, officeDate);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurveyHeaderSoilData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.fieldResponsibility == this.fieldResponsibility &&
          other.fieldCheckBy == this.fieldCheckBy &&
          other.fieldDate == this.fieldDate &&
          other.officeCheckBy == this.officeCheckBy &&
          other.officeDate == this.officeDate);
}

class SurveyHeaderSoilCompanion
    extends d.UpdateCompanion<SurveyHeaderSoilData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<String?> fieldResponsibility;
  final d.Value<String?> fieldCheckBy;
  final d.Value<DateTime?> fieldDate;
  final d.Value<String?> officeCheckBy;
  final d.Value<DateTime?> officeDate;
  const SurveyHeaderSoilCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  });
  SurveyHeaderSoilCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    this.fieldResponsibility = const d.Value.absent(),
    this.fieldCheckBy = const d.Value.absent(),
    this.fieldDate = const d.Value.absent(),
    this.officeCheckBy = const d.Value.absent(),
    this.officeDate = const d.Value.absent(),
  }) : surveyId = d.Value(surveyId);
  static d.Insertable<SurveyHeaderSoilData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<String>? fieldResponsibility,
    d.Expression<String>? fieldCheckBy,
    d.Expression<DateTime>? fieldDate,
    d.Expression<String>? officeCheckBy,
    d.Expression<DateTime>? officeDate,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (fieldResponsibility != null)
        'field_responsibility': fieldResponsibility,
      if (fieldCheckBy != null) 'field_check_by': fieldCheckBy,
      if (fieldDate != null) 'field_date': fieldDate,
      if (officeCheckBy != null) 'office_check_by': officeCheckBy,
      if (officeDate != null) 'office_date': officeDate,
    });
  }

  SurveyHeaderSoilCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<String?>? fieldResponsibility,
      d.Value<String?>? fieldCheckBy,
      d.Value<DateTime?>? fieldDate,
      d.Value<String?>? officeCheckBy,
      d.Value<DateTime?>? officeDate}) {
    return SurveyHeaderSoilCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      fieldResponsibility: fieldResponsibility ?? this.fieldResponsibility,
      fieldCheckBy: fieldCheckBy ?? this.fieldCheckBy,
      fieldDate: fieldDate ?? this.fieldDate,
      officeCheckBy: officeCheckBy ?? this.officeCheckBy,
      officeDate: officeDate ?? this.officeDate,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (fieldResponsibility.present) {
      map['field_responsibility'] =
          d.Variable<String>(fieldResponsibility.value);
    }
    if (fieldCheckBy.present) {
      map['field_check_by'] = d.Variable<String>(fieldCheckBy.value);
    }
    if (fieldDate.present) {
      map['field_date'] = d.Variable<DateTime>(fieldDate.value);
    }
    if (officeCheckBy.present) {
      map['office_check_by'] = d.Variable<String>(officeCheckBy.value);
    }
    if (officeDate.present) {
      map['office_date'] = d.Variable<DateTime>(officeDate.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurveyHeaderSoilCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('fieldResponsibility: $fieldResponsibility, ')
          ..write('fieldCheckBy: $fieldCheckBy, ')
          ..write('fieldDate: $fieldDate, ')
          ..write('officeCheckBy: $officeCheckBy, ')
          ..write('officeDate: $officeDate')
          ..write(')'))
        .toString();
  }
}

class $WoodyDebrisSummaryTable extends WoodyDebrisSummary
    with d.TableInfo<$WoodyDebrisSummaryTable, WoodyDebrisSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WoodyDebrisSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _numTransectsMeta =
      const d.VerificationMeta('numTransects');
  @override
  late final d.GeneratedColumn<int> numTransects = d.GeneratedColumn<int>(
      'num_transects', aliasedName, true,
      check: () => numTransects.isBetweenValues(1, 9),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, measDate, numTransects, notAssessed, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'woody_debris_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<WoodyDebrisSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('num_transects')) {
      context.handle(
          _numTransectsMeta,
          numTransects.isAcceptableOrUnknown(
              data['num_transects']!, _numTransectsMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  WoodyDebrisSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WoodyDebrisSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      numTransects: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num_transects']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $WoodyDebrisSummaryTable createAlias(String alias) {
    return $WoodyDebrisSummaryTable(attachedDatabase, alias);
  }
}

class WoodyDebrisSummaryData extends d.DataClass
    implements d.Insertable<WoodyDebrisSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final int? numTransects;
  final bool notAssessed;
  final bool complete;
  const WoodyDebrisSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      this.numTransects,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    if (!nullToAbsent || numTransects != null) {
      map['num_transects'] = d.Variable<int>(numTransects);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  WoodyDebrisSummaryCompanion toCompanion(bool nullToAbsent) {
    return WoodyDebrisSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      numTransects: numTransects == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(numTransects),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory WoodyDebrisSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return WoodyDebrisSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      numTransects: serializer.fromJson<int?>(json['numTransects']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'numTransects': serializer.toJson<int?>(numTransects),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  WoodyDebrisSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          d.Value<int?> numTransects = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      WoodyDebrisSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        numTransects:
            numTransects.present ? numTransects.value : this.numTransects,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('WoodyDebrisSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numTransects: $numTransects, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, surveyId, measDate, numTransects, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WoodyDebrisSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.numTransects == this.numTransects &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class WoodyDebrisSummaryCompanion
    extends d.UpdateCompanion<WoodyDebrisSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<int?> numTransects;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const WoodyDebrisSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.numTransects = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  WoodyDebrisSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.numTransects = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<WoodyDebrisSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<int>? numTransects,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (numTransects != null) 'num_transects': numTransects,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  WoodyDebrisSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<int?>? numTransects,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return WoodyDebrisSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      numTransects: numTransects ?? this.numTransects,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (numTransects.present) {
      map['num_transects'] = d.Variable<int>(numTransects.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WoodyDebrisSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numTransects: $numTransects, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $WoodyDebrisHeaderTable extends WoodyDebrisHeader
    with d.TableInfo<$WoodyDebrisHeaderTable, WoodyDebrisHeaderData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WoodyDebrisHeaderTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _wdIdMeta = const d.VerificationMeta('wdId');
  @override
  late final d.GeneratedColumn<int> wdId = d.GeneratedColumn<int>(
      'wd_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES woody_debris_summary (id)'));
  static const d.VerificationMeta _transNumMeta =
      const d.VerificationMeta('transNum');
  @override
  late final d.GeneratedColumn<int> transNum = d.GeneratedColumn<int>(
      'trans_num', aliasedName, true,
      check: () => transNum.isBetweenValues(1, 9),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _nomTransLenMeta =
      const d.VerificationMeta('nomTransLen');
  @override
  late final d.GeneratedColumn<double> nomTransLen = d.GeneratedColumn<double>(
      'nom_trans_len', aliasedName, true,
      check: () => nomTransLen.isBetweenValues(10.0, 150.0),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _transAzimuthMeta =
      const d.VerificationMeta('transAzimuth');
  @override
  late final d.GeneratedColumn<int> transAzimuth = d.GeneratedColumn<int>(
      'trans_azimuth', aliasedName, true,
      check: () => transAzimuth.isBetweenValues(0, 360),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _swdMeasLenMeta =
      const d.VerificationMeta('swdMeasLen');
  @override
  late final d.GeneratedColumn<double> swdMeasLen = d.GeneratedColumn<double>(
      'swd_meas_len', aliasedName, true,
      check: () => (swdMeasLen.isBetweenValues(0.0, 150.0) &
          swdMeasLen.isSmallerOrEqual(nomTransLen)),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _mcwdMeasLenMeta =
      const d.VerificationMeta('mcwdMeasLen');
  @override
  late final d.GeneratedColumn<double> mcwdMeasLen = d.GeneratedColumn<double>(
      'mcwd_meas_len', aliasedName, true,
      check: () => (mcwdMeasLen.isBetweenValues(0.0, 150.0) &
          mcwdMeasLen.isSmallerOrEqual(nomTransLen)),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _lcwdMeasLenMeta =
      const d.VerificationMeta('lcwdMeasLen');
  @override
  late final d.GeneratedColumn<double> lcwdMeasLen = d.GeneratedColumn<double>(
      'lcwd_meas_len', aliasedName, true,
      check: () => (lcwdMeasLen.isBetweenValues(0.0, 150.0) &
          lcwdMeasLen.isSmallerOrEqual(nomTransLen)),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _swdDecayClassMeta =
      const d.VerificationMeta('swdDecayClass');
  @override
  late final d.GeneratedColumn<int> swdDecayClass = d.GeneratedColumn<int>(
      'swd_decay_class', aliasedName, true,
      check: () => swdDecayClass.isBetweenValues(-1, 5),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        wdId,
        transNum,
        nomTransLen,
        transAzimuth,
        swdMeasLen,
        mcwdMeasLen,
        lcwdMeasLen,
        swdDecayClass,
        complete
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'woody_debris_header';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<WoodyDebrisHeaderData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('wd_id')) {
      context.handle(
          _wdIdMeta, wdId.isAcceptableOrUnknown(data['wd_id']!, _wdIdMeta));
    } else if (isInserting) {
      context.missing(_wdIdMeta);
    }
    if (data.containsKey('trans_num')) {
      context.handle(_transNumMeta,
          transNum.isAcceptableOrUnknown(data['trans_num']!, _transNumMeta));
    }
    if (data.containsKey('nom_trans_len')) {
      context.handle(
          _nomTransLenMeta,
          nomTransLen.isAcceptableOrUnknown(
              data['nom_trans_len']!, _nomTransLenMeta));
    }
    if (data.containsKey('trans_azimuth')) {
      context.handle(
          _transAzimuthMeta,
          transAzimuth.isAcceptableOrUnknown(
              data['trans_azimuth']!, _transAzimuthMeta));
    }
    if (data.containsKey('swd_meas_len')) {
      context.handle(
          _swdMeasLenMeta,
          swdMeasLen.isAcceptableOrUnknown(
              data['swd_meas_len']!, _swdMeasLenMeta));
    }
    if (data.containsKey('mcwd_meas_len')) {
      context.handle(
          _mcwdMeasLenMeta,
          mcwdMeasLen.isAcceptableOrUnknown(
              data['mcwd_meas_len']!, _mcwdMeasLenMeta));
    }
    if (data.containsKey('lcwd_meas_len')) {
      context.handle(
          _lcwdMeasLenMeta,
          lcwdMeasLen.isAcceptableOrUnknown(
              data['lcwd_meas_len']!, _lcwdMeasLenMeta));
    }
    if (data.containsKey('swd_decay_class')) {
      context.handle(
          _swdDecayClassMeta,
          swdDecayClass.isAcceptableOrUnknown(
              data['swd_decay_class']!, _swdDecayClassMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  WoodyDebrisHeaderData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WoodyDebrisHeaderData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      wdId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}wd_id'])!,
      transNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}trans_num']),
      nomTransLen: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_trans_len']),
      transAzimuth: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}trans_azimuth']),
      swdMeasLen: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}swd_meas_len']),
      mcwdMeasLen: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}mcwd_meas_len']),
      lcwdMeasLen: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}lcwd_meas_len']),
      swdDecayClass: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}swd_decay_class']),
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $WoodyDebrisHeaderTable createAlias(String alias) {
    return $WoodyDebrisHeaderTable(attachedDatabase, alias);
  }
}

class WoodyDebrisHeaderData extends d.DataClass
    implements d.Insertable<WoodyDebrisHeaderData> {
  final int id;
  final int wdId;
  final int? transNum;
  final double? nomTransLen;
  final int? transAzimuth;
  final double? swdMeasLen;
  final double? mcwdMeasLen;
  final double? lcwdMeasLen;
  final int? swdDecayClass;
  final bool complete;
  const WoodyDebrisHeaderData(
      {required this.id,
      required this.wdId,
      this.transNum,
      this.nomTransLen,
      this.transAzimuth,
      this.swdMeasLen,
      this.mcwdMeasLen,
      this.lcwdMeasLen,
      this.swdDecayClass,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['wd_id'] = d.Variable<int>(wdId);
    if (!nullToAbsent || transNum != null) {
      map['trans_num'] = d.Variable<int>(transNum);
    }
    if (!nullToAbsent || nomTransLen != null) {
      map['nom_trans_len'] = d.Variable<double>(nomTransLen);
    }
    if (!nullToAbsent || transAzimuth != null) {
      map['trans_azimuth'] = d.Variable<int>(transAzimuth);
    }
    if (!nullToAbsent || swdMeasLen != null) {
      map['swd_meas_len'] = d.Variable<double>(swdMeasLen);
    }
    if (!nullToAbsent || mcwdMeasLen != null) {
      map['mcwd_meas_len'] = d.Variable<double>(mcwdMeasLen);
    }
    if (!nullToAbsent || lcwdMeasLen != null) {
      map['lcwd_meas_len'] = d.Variable<double>(lcwdMeasLen);
    }
    if (!nullToAbsent || swdDecayClass != null) {
      map['swd_decay_class'] = d.Variable<int>(swdDecayClass);
    }
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  WoodyDebrisHeaderCompanion toCompanion(bool nullToAbsent) {
    return WoodyDebrisHeaderCompanion(
      id: d.Value(id),
      wdId: d.Value(wdId),
      transNum: transNum == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transNum),
      nomTransLen: nomTransLen == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomTransLen),
      transAzimuth: transAzimuth == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transAzimuth),
      swdMeasLen: swdMeasLen == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(swdMeasLen),
      mcwdMeasLen: mcwdMeasLen == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(mcwdMeasLen),
      lcwdMeasLen: lcwdMeasLen == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(lcwdMeasLen),
      swdDecayClass: swdDecayClass == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(swdDecayClass),
      complete: d.Value(complete),
    );
  }

  factory WoodyDebrisHeaderData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return WoodyDebrisHeaderData(
      id: serializer.fromJson<int>(json['id']),
      wdId: serializer.fromJson<int>(json['wdId']),
      transNum: serializer.fromJson<int?>(json['transNum']),
      nomTransLen: serializer.fromJson<double?>(json['nomTransLen']),
      transAzimuth: serializer.fromJson<int?>(json['transAzimuth']),
      swdMeasLen: serializer.fromJson<double?>(json['swdMeasLen']),
      mcwdMeasLen: serializer.fromJson<double?>(json['mcwdMeasLen']),
      lcwdMeasLen: serializer.fromJson<double?>(json['lcwdMeasLen']),
      swdDecayClass: serializer.fromJson<int?>(json['swdDecayClass']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'wdId': serializer.toJson<int>(wdId),
      'transNum': serializer.toJson<int?>(transNum),
      'nomTransLen': serializer.toJson<double?>(nomTransLen),
      'transAzimuth': serializer.toJson<int?>(transAzimuth),
      'swdMeasLen': serializer.toJson<double?>(swdMeasLen),
      'mcwdMeasLen': serializer.toJson<double?>(mcwdMeasLen),
      'lcwdMeasLen': serializer.toJson<double?>(lcwdMeasLen),
      'swdDecayClass': serializer.toJson<int?>(swdDecayClass),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  WoodyDebrisHeaderData copyWith(
          {int? id,
          int? wdId,
          d.Value<int?> transNum = const d.Value.absent(),
          d.Value<double?> nomTransLen = const d.Value.absent(),
          d.Value<int?> transAzimuth = const d.Value.absent(),
          d.Value<double?> swdMeasLen = const d.Value.absent(),
          d.Value<double?> mcwdMeasLen = const d.Value.absent(),
          d.Value<double?> lcwdMeasLen = const d.Value.absent(),
          d.Value<int?> swdDecayClass = const d.Value.absent(),
          bool? complete}) =>
      WoodyDebrisHeaderData(
        id: id ?? this.id,
        wdId: wdId ?? this.wdId,
        transNum: transNum.present ? transNum.value : this.transNum,
        nomTransLen: nomTransLen.present ? nomTransLen.value : this.nomTransLen,
        transAzimuth:
            transAzimuth.present ? transAzimuth.value : this.transAzimuth,
        swdMeasLen: swdMeasLen.present ? swdMeasLen.value : this.swdMeasLen,
        mcwdMeasLen: mcwdMeasLen.present ? mcwdMeasLen.value : this.mcwdMeasLen,
        lcwdMeasLen: lcwdMeasLen.present ? lcwdMeasLen.value : this.lcwdMeasLen,
        swdDecayClass:
            swdDecayClass.present ? swdDecayClass.value : this.swdDecayClass,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('WoodyDebrisHeaderData(')
          ..write('id: $id, ')
          ..write('wdId: $wdId, ')
          ..write('transNum: $transNum, ')
          ..write('nomTransLen: $nomTransLen, ')
          ..write('transAzimuth: $transAzimuth, ')
          ..write('swdMeasLen: $swdMeasLen, ')
          ..write('mcwdMeasLen: $mcwdMeasLen, ')
          ..write('lcwdMeasLen: $lcwdMeasLen, ')
          ..write('swdDecayClass: $swdDecayClass, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, wdId, transNum, nomTransLen, transAzimuth,
      swdMeasLen, mcwdMeasLen, lcwdMeasLen, swdDecayClass, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WoodyDebrisHeaderData &&
          other.id == this.id &&
          other.wdId == this.wdId &&
          other.transNum == this.transNum &&
          other.nomTransLen == this.nomTransLen &&
          other.transAzimuth == this.transAzimuth &&
          other.swdMeasLen == this.swdMeasLen &&
          other.mcwdMeasLen == this.mcwdMeasLen &&
          other.lcwdMeasLen == this.lcwdMeasLen &&
          other.swdDecayClass == this.swdDecayClass &&
          other.complete == this.complete);
}

class WoodyDebrisHeaderCompanion
    extends d.UpdateCompanion<WoodyDebrisHeaderData> {
  final d.Value<int> id;
  final d.Value<int> wdId;
  final d.Value<int?> transNum;
  final d.Value<double?> nomTransLen;
  final d.Value<int?> transAzimuth;
  final d.Value<double?> swdMeasLen;
  final d.Value<double?> mcwdMeasLen;
  final d.Value<double?> lcwdMeasLen;
  final d.Value<int?> swdDecayClass;
  final d.Value<bool> complete;
  const WoodyDebrisHeaderCompanion({
    this.id = const d.Value.absent(),
    this.wdId = const d.Value.absent(),
    this.transNum = const d.Value.absent(),
    this.nomTransLen = const d.Value.absent(),
    this.transAzimuth = const d.Value.absent(),
    this.swdMeasLen = const d.Value.absent(),
    this.mcwdMeasLen = const d.Value.absent(),
    this.lcwdMeasLen = const d.Value.absent(),
    this.swdDecayClass = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  WoodyDebrisHeaderCompanion.insert({
    this.id = const d.Value.absent(),
    required int wdId,
    this.transNum = const d.Value.absent(),
    this.nomTransLen = const d.Value.absent(),
    this.transAzimuth = const d.Value.absent(),
    this.swdMeasLen = const d.Value.absent(),
    this.mcwdMeasLen = const d.Value.absent(),
    this.lcwdMeasLen = const d.Value.absent(),
    this.swdDecayClass = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  }) : wdId = d.Value(wdId);
  static d.Insertable<WoodyDebrisHeaderData> custom({
    d.Expression<int>? id,
    d.Expression<int>? wdId,
    d.Expression<int>? transNum,
    d.Expression<double>? nomTransLen,
    d.Expression<int>? transAzimuth,
    d.Expression<double>? swdMeasLen,
    d.Expression<double>? mcwdMeasLen,
    d.Expression<double>? lcwdMeasLen,
    d.Expression<int>? swdDecayClass,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (wdId != null) 'wd_id': wdId,
      if (transNum != null) 'trans_num': transNum,
      if (nomTransLen != null) 'nom_trans_len': nomTransLen,
      if (transAzimuth != null) 'trans_azimuth': transAzimuth,
      if (swdMeasLen != null) 'swd_meas_len': swdMeasLen,
      if (mcwdMeasLen != null) 'mcwd_meas_len': mcwdMeasLen,
      if (lcwdMeasLen != null) 'lcwd_meas_len': lcwdMeasLen,
      if (swdDecayClass != null) 'swd_decay_class': swdDecayClass,
      if (complete != null) 'complete': complete,
    });
  }

  WoodyDebrisHeaderCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? wdId,
      d.Value<int?>? transNum,
      d.Value<double?>? nomTransLen,
      d.Value<int?>? transAzimuth,
      d.Value<double?>? swdMeasLen,
      d.Value<double?>? mcwdMeasLen,
      d.Value<double?>? lcwdMeasLen,
      d.Value<int?>? swdDecayClass,
      d.Value<bool>? complete}) {
    return WoodyDebrisHeaderCompanion(
      id: id ?? this.id,
      wdId: wdId ?? this.wdId,
      transNum: transNum ?? this.transNum,
      nomTransLen: nomTransLen ?? this.nomTransLen,
      transAzimuth: transAzimuth ?? this.transAzimuth,
      swdMeasLen: swdMeasLen ?? this.swdMeasLen,
      mcwdMeasLen: mcwdMeasLen ?? this.mcwdMeasLen,
      lcwdMeasLen: lcwdMeasLen ?? this.lcwdMeasLen,
      swdDecayClass: swdDecayClass ?? this.swdDecayClass,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (wdId.present) {
      map['wd_id'] = d.Variable<int>(wdId.value);
    }
    if (transNum.present) {
      map['trans_num'] = d.Variable<int>(transNum.value);
    }
    if (nomTransLen.present) {
      map['nom_trans_len'] = d.Variable<double>(nomTransLen.value);
    }
    if (transAzimuth.present) {
      map['trans_azimuth'] = d.Variable<int>(transAzimuth.value);
    }
    if (swdMeasLen.present) {
      map['swd_meas_len'] = d.Variable<double>(swdMeasLen.value);
    }
    if (mcwdMeasLen.present) {
      map['mcwd_meas_len'] = d.Variable<double>(mcwdMeasLen.value);
    }
    if (lcwdMeasLen.present) {
      map['lcwd_meas_len'] = d.Variable<double>(lcwdMeasLen.value);
    }
    if (swdDecayClass.present) {
      map['swd_decay_class'] = d.Variable<int>(swdDecayClass.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WoodyDebrisHeaderCompanion(')
          ..write('id: $id, ')
          ..write('wdId: $wdId, ')
          ..write('transNum: $transNum, ')
          ..write('nomTransLen: $nomTransLen, ')
          ..write('transAzimuth: $transAzimuth, ')
          ..write('swdMeasLen: $swdMeasLen, ')
          ..write('mcwdMeasLen: $mcwdMeasLen, ')
          ..write('lcwdMeasLen: $lcwdMeasLen, ')
          ..write('swdDecayClass: $swdDecayClass, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $WoodyDebrisSmallTable extends WoodyDebrisSmall
    with d.TableInfo<$WoodyDebrisSmallTable, WoodyDebrisSmallData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WoodyDebrisSmallTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _wdHeaderIdMeta =
      const d.VerificationMeta('wdHeaderId');
  @override
  late final d.GeneratedColumn<int> wdHeaderId = d.GeneratedColumn<int>(
      'wd_header_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES woody_debris_header (id)'));
  static const d.VerificationMeta _swdTallySMeta =
      const d.VerificationMeta('swdTallyS');
  @override
  late final d.GeneratedColumn<int> swdTallyS = d.GeneratedColumn<int>(
      'swd_tally_s', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const d.Constant(0));
  static const d.VerificationMeta _swdTallyMMeta =
      const d.VerificationMeta('swdTallyM');
  @override
  late final d.GeneratedColumn<int> swdTallyM = d.GeneratedColumn<int>(
      'swd_tally_m', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const d.Constant(0));
  static const d.VerificationMeta _swdTallyLMeta =
      const d.VerificationMeta('swdTallyL');
  @override
  late final d.GeneratedColumn<int> swdTallyL = d.GeneratedColumn<int>(
      'swd_tally_l', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const d.Constant(0));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, wdHeaderId, swdTallyS, swdTallyM, swdTallyL];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'woody_debris_small';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<WoodyDebrisSmallData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('wd_header_id')) {
      context.handle(
          _wdHeaderIdMeta,
          wdHeaderId.isAcceptableOrUnknown(
              data['wd_header_id']!, _wdHeaderIdMeta));
    } else if (isInserting) {
      context.missing(_wdHeaderIdMeta);
    }
    if (data.containsKey('swd_tally_s')) {
      context.handle(
          _swdTallySMeta,
          swdTallyS.isAcceptableOrUnknown(
              data['swd_tally_s']!, _swdTallySMeta));
    }
    if (data.containsKey('swd_tally_m')) {
      context.handle(
          _swdTallyMMeta,
          swdTallyM.isAcceptableOrUnknown(
              data['swd_tally_m']!, _swdTallyMMeta));
    }
    if (data.containsKey('swd_tally_l')) {
      context.handle(
          _swdTallyLMeta,
          swdTallyL.isAcceptableOrUnknown(
              data['swd_tally_l']!, _swdTallyLMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  WoodyDebrisSmallData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WoodyDebrisSmallData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      wdHeaderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}wd_header_id'])!,
      swdTallyS: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}swd_tally_s'])!,
      swdTallyM: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}swd_tally_m'])!,
      swdTallyL: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}swd_tally_l'])!,
    );
  }

  @override
  $WoodyDebrisSmallTable createAlias(String alias) {
    return $WoodyDebrisSmallTable(attachedDatabase, alias);
  }
}

class WoodyDebrisSmallData extends d.DataClass
    implements d.Insertable<WoodyDebrisSmallData> {
  final int id;
  final int wdHeaderId;
  final int swdTallyS;
  final int swdTallyM;
  final int swdTallyL;
  const WoodyDebrisSmallData(
      {required this.id,
      required this.wdHeaderId,
      required this.swdTallyS,
      required this.swdTallyM,
      required this.swdTallyL});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['wd_header_id'] = d.Variable<int>(wdHeaderId);
    map['swd_tally_s'] = d.Variable<int>(swdTallyS);
    map['swd_tally_m'] = d.Variable<int>(swdTallyM);
    map['swd_tally_l'] = d.Variable<int>(swdTallyL);
    return map;
  }

  WoodyDebrisSmallCompanion toCompanion(bool nullToAbsent) {
    return WoodyDebrisSmallCompanion(
      id: d.Value(id),
      wdHeaderId: d.Value(wdHeaderId),
      swdTallyS: d.Value(swdTallyS),
      swdTallyM: d.Value(swdTallyM),
      swdTallyL: d.Value(swdTallyL),
    );
  }

  factory WoodyDebrisSmallData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return WoodyDebrisSmallData(
      id: serializer.fromJson<int>(json['id']),
      wdHeaderId: serializer.fromJson<int>(json['wdHeaderId']),
      swdTallyS: serializer.fromJson<int>(json['swdTallyS']),
      swdTallyM: serializer.fromJson<int>(json['swdTallyM']),
      swdTallyL: serializer.fromJson<int>(json['swdTallyL']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'wdHeaderId': serializer.toJson<int>(wdHeaderId),
      'swdTallyS': serializer.toJson<int>(swdTallyS),
      'swdTallyM': serializer.toJson<int>(swdTallyM),
      'swdTallyL': serializer.toJson<int>(swdTallyL),
    };
  }

  WoodyDebrisSmallData copyWith(
          {int? id,
          int? wdHeaderId,
          int? swdTallyS,
          int? swdTallyM,
          int? swdTallyL}) =>
      WoodyDebrisSmallData(
        id: id ?? this.id,
        wdHeaderId: wdHeaderId ?? this.wdHeaderId,
        swdTallyS: swdTallyS ?? this.swdTallyS,
        swdTallyM: swdTallyM ?? this.swdTallyM,
        swdTallyL: swdTallyL ?? this.swdTallyL,
      );
  @override
  String toString() {
    return (StringBuffer('WoodyDebrisSmallData(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('swdTallyS: $swdTallyS, ')
          ..write('swdTallyM: $swdTallyM, ')
          ..write('swdTallyL: $swdTallyL')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, wdHeaderId, swdTallyS, swdTallyM, swdTallyL);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WoodyDebrisSmallData &&
          other.id == this.id &&
          other.wdHeaderId == this.wdHeaderId &&
          other.swdTallyS == this.swdTallyS &&
          other.swdTallyM == this.swdTallyM &&
          other.swdTallyL == this.swdTallyL);
}

class WoodyDebrisSmallCompanion
    extends d.UpdateCompanion<WoodyDebrisSmallData> {
  final d.Value<int> id;
  final d.Value<int> wdHeaderId;
  final d.Value<int> swdTallyS;
  final d.Value<int> swdTallyM;
  final d.Value<int> swdTallyL;
  const WoodyDebrisSmallCompanion({
    this.id = const d.Value.absent(),
    this.wdHeaderId = const d.Value.absent(),
    this.swdTallyS = const d.Value.absent(),
    this.swdTallyM = const d.Value.absent(),
    this.swdTallyL = const d.Value.absent(),
  });
  WoodyDebrisSmallCompanion.insert({
    this.id = const d.Value.absent(),
    required int wdHeaderId,
    this.swdTallyS = const d.Value.absent(),
    this.swdTallyM = const d.Value.absent(),
    this.swdTallyL = const d.Value.absent(),
  }) : wdHeaderId = d.Value(wdHeaderId);
  static d.Insertable<WoodyDebrisSmallData> custom({
    d.Expression<int>? id,
    d.Expression<int>? wdHeaderId,
    d.Expression<int>? swdTallyS,
    d.Expression<int>? swdTallyM,
    d.Expression<int>? swdTallyL,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (wdHeaderId != null) 'wd_header_id': wdHeaderId,
      if (swdTallyS != null) 'swd_tally_s': swdTallyS,
      if (swdTallyM != null) 'swd_tally_m': swdTallyM,
      if (swdTallyL != null) 'swd_tally_l': swdTallyL,
    });
  }

  WoodyDebrisSmallCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? wdHeaderId,
      d.Value<int>? swdTallyS,
      d.Value<int>? swdTallyM,
      d.Value<int>? swdTallyL}) {
    return WoodyDebrisSmallCompanion(
      id: id ?? this.id,
      wdHeaderId: wdHeaderId ?? this.wdHeaderId,
      swdTallyS: swdTallyS ?? this.swdTallyS,
      swdTallyM: swdTallyM ?? this.swdTallyM,
      swdTallyL: swdTallyL ?? this.swdTallyL,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (wdHeaderId.present) {
      map['wd_header_id'] = d.Variable<int>(wdHeaderId.value);
    }
    if (swdTallyS.present) {
      map['swd_tally_s'] = d.Variable<int>(swdTallyS.value);
    }
    if (swdTallyM.present) {
      map['swd_tally_m'] = d.Variable<int>(swdTallyM.value);
    }
    if (swdTallyL.present) {
      map['swd_tally_l'] = d.Variable<int>(swdTallyL.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WoodyDebrisSmallCompanion(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('swdTallyS: $swdTallyS, ')
          ..write('swdTallyM: $swdTallyM, ')
          ..write('swdTallyL: $swdTallyL')
          ..write(')'))
        .toString();
  }
}

class $WoodyDebrisOddTable extends WoodyDebrisOdd
    with d.TableInfo<$WoodyDebrisOddTable, WoodyDebrisOddData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WoodyDebrisOddTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _wdHeaderIdMeta =
      const d.VerificationMeta('wdHeaderId');
  @override
  late final d.GeneratedColumn<int> wdHeaderId = d.GeneratedColumn<int>(
      'wd_header_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES woody_debris_header (id)'));
  static const d.VerificationMeta _pieceNumMeta =
      const d.VerificationMeta('pieceNum');
  @override
  late final d.GeneratedColumn<int> pieceNum = d.GeneratedColumn<int>(
      'piece_num', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _accumOddMeta =
      const d.VerificationMeta('accumOdd');
  @override
  late final d.GeneratedColumn<String> accumOdd = d.GeneratedColumn<String>(
      'accum_odd', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _genusMeta =
      const d.VerificationMeta('genus');
  @override
  late final d.GeneratedColumn<String> genus = d.GeneratedColumn<String>(
      'genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 4, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES tree_genus (genus_code)'));
  static const d.VerificationMeta _speciesMeta =
      const d.VerificationMeta('species');
  @override
  late final d.GeneratedColumn<String> species = d.GeneratedColumn<String>(
      'species', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES tree_genus (species_code)'));
  static const d.VerificationMeta _horLengthMeta =
      const d.VerificationMeta('horLength');
  @override
  late final d.GeneratedColumn<double> horLength = d.GeneratedColumn<double>(
      'hor_length', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const d.VerificationMeta _verDepthMeta =
      const d.VerificationMeta('verDepth');
  @override
  late final d.GeneratedColumn<double> verDepth = d.GeneratedColumn<double>(
      'ver_depth', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const d.VerificationMeta _decayClassMeta =
      const d.VerificationMeta('decayClass');
  @override
  late final d.GeneratedColumn<int> decayClass = d.GeneratedColumn<int>(
      'decay_class', aliasedName, true,
      check: () => decayClass.isBetweenValues(-1, 5),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        wdHeaderId,
        pieceNum,
        accumOdd,
        genus,
        species,
        horLength,
        verDepth,
        decayClass
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'woody_debris_odd';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<WoodyDebrisOddData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('wd_header_id')) {
      context.handle(
          _wdHeaderIdMeta,
          wdHeaderId.isAcceptableOrUnknown(
              data['wd_header_id']!, _wdHeaderIdMeta));
    } else if (isInserting) {
      context.missing(_wdHeaderIdMeta);
    }
    if (data.containsKey('piece_num')) {
      context.handle(_pieceNumMeta,
          pieceNum.isAcceptableOrUnknown(data['piece_num']!, _pieceNumMeta));
    } else if (isInserting) {
      context.missing(_pieceNumMeta);
    }
    if (data.containsKey('accum_odd')) {
      context.handle(_accumOddMeta,
          accumOdd.isAcceptableOrUnknown(data['accum_odd']!, _accumOddMeta));
    } else if (isInserting) {
      context.missing(_accumOddMeta);
    }
    if (data.containsKey('genus')) {
      context.handle(
          _genusMeta, genus.isAcceptableOrUnknown(data['genus']!, _genusMeta));
    } else if (isInserting) {
      context.missing(_genusMeta);
    }
    if (data.containsKey('species')) {
      context.handle(_speciesMeta,
          species.isAcceptableOrUnknown(data['species']!, _speciesMeta));
    } else if (isInserting) {
      context.missing(_speciesMeta);
    }
    if (data.containsKey('hor_length')) {
      context.handle(_horLengthMeta,
          horLength.isAcceptableOrUnknown(data['hor_length']!, _horLengthMeta));
    } else if (isInserting) {
      context.missing(_horLengthMeta);
    }
    if (data.containsKey('ver_depth')) {
      context.handle(_verDepthMeta,
          verDepth.isAcceptableOrUnknown(data['ver_depth']!, _verDepthMeta));
    } else if (isInserting) {
      context.missing(_verDepthMeta);
    }
    if (data.containsKey('decay_class')) {
      context.handle(
          _decayClassMeta,
          decayClass.isAcceptableOrUnknown(
              data['decay_class']!, _decayClassMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  WoodyDebrisOddData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WoodyDebrisOddData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      wdHeaderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}wd_header_id'])!,
      pieceNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}piece_num'])!,
      accumOdd: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}accum_odd'])!,
      genus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus'])!,
      species: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species'])!,
      horLength: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}hor_length'])!,
      verDepth: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}ver_depth'])!,
      decayClass: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}decay_class']),
    );
  }

  @override
  $WoodyDebrisOddTable createAlias(String alias) {
    return $WoodyDebrisOddTable(attachedDatabase, alias);
  }
}

class WoodyDebrisOddData extends d.DataClass
    implements d.Insertable<WoodyDebrisOddData> {
  final int id;
  final int wdHeaderId;
  final int pieceNum;
  final String accumOdd;
  final String genus;
  final String species;
  final double horLength;
  final double verDepth;
  final int? decayClass;
  const WoodyDebrisOddData(
      {required this.id,
      required this.wdHeaderId,
      required this.pieceNum,
      required this.accumOdd,
      required this.genus,
      required this.species,
      required this.horLength,
      required this.verDepth,
      this.decayClass});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['wd_header_id'] = d.Variable<int>(wdHeaderId);
    map['piece_num'] = d.Variable<int>(pieceNum);
    map['accum_odd'] = d.Variable<String>(accumOdd);
    map['genus'] = d.Variable<String>(genus);
    map['species'] = d.Variable<String>(species);
    map['hor_length'] = d.Variable<double>(horLength);
    map['ver_depth'] = d.Variable<double>(verDepth);
    if (!nullToAbsent || decayClass != null) {
      map['decay_class'] = d.Variable<int>(decayClass);
    }
    return map;
  }

  WoodyDebrisOddCompanion toCompanion(bool nullToAbsent) {
    return WoodyDebrisOddCompanion(
      id: d.Value(id),
      wdHeaderId: d.Value(wdHeaderId),
      pieceNum: d.Value(pieceNum),
      accumOdd: d.Value(accumOdd),
      genus: d.Value(genus),
      species: d.Value(species),
      horLength: d.Value(horLength),
      verDepth: d.Value(verDepth),
      decayClass: decayClass == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(decayClass),
    );
  }

  factory WoodyDebrisOddData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return WoodyDebrisOddData(
      id: serializer.fromJson<int>(json['id']),
      wdHeaderId: serializer.fromJson<int>(json['wdHeaderId']),
      pieceNum: serializer.fromJson<int>(json['pieceNum']),
      accumOdd: serializer.fromJson<String>(json['accumOdd']),
      genus: serializer.fromJson<String>(json['genus']),
      species: serializer.fromJson<String>(json['species']),
      horLength: serializer.fromJson<double>(json['horLength']),
      verDepth: serializer.fromJson<double>(json['verDepth']),
      decayClass: serializer.fromJson<int?>(json['decayClass']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'wdHeaderId': serializer.toJson<int>(wdHeaderId),
      'pieceNum': serializer.toJson<int>(pieceNum),
      'accumOdd': serializer.toJson<String>(accumOdd),
      'genus': serializer.toJson<String>(genus),
      'species': serializer.toJson<String>(species),
      'horLength': serializer.toJson<double>(horLength),
      'verDepth': serializer.toJson<double>(verDepth),
      'decayClass': serializer.toJson<int?>(decayClass),
    };
  }

  WoodyDebrisOddData copyWith(
          {int? id,
          int? wdHeaderId,
          int? pieceNum,
          String? accumOdd,
          String? genus,
          String? species,
          double? horLength,
          double? verDepth,
          d.Value<int?> decayClass = const d.Value.absent()}) =>
      WoodyDebrisOddData(
        id: id ?? this.id,
        wdHeaderId: wdHeaderId ?? this.wdHeaderId,
        pieceNum: pieceNum ?? this.pieceNum,
        accumOdd: accumOdd ?? this.accumOdd,
        genus: genus ?? this.genus,
        species: species ?? this.species,
        horLength: horLength ?? this.horLength,
        verDepth: verDepth ?? this.verDepth,
        decayClass: decayClass.present ? decayClass.value : this.decayClass,
      );
  @override
  String toString() {
    return (StringBuffer('WoodyDebrisOddData(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('pieceNum: $pieceNum, ')
          ..write('accumOdd: $accumOdd, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('horLength: $horLength, ')
          ..write('verDepth: $verDepth, ')
          ..write('decayClass: $decayClass')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, wdHeaderId, pieceNum, accumOdd, genus,
      species, horLength, verDepth, decayClass);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WoodyDebrisOddData &&
          other.id == this.id &&
          other.wdHeaderId == this.wdHeaderId &&
          other.pieceNum == this.pieceNum &&
          other.accumOdd == this.accumOdd &&
          other.genus == this.genus &&
          other.species == this.species &&
          other.horLength == this.horLength &&
          other.verDepth == this.verDepth &&
          other.decayClass == this.decayClass);
}

class WoodyDebrisOddCompanion extends d.UpdateCompanion<WoodyDebrisOddData> {
  final d.Value<int> id;
  final d.Value<int> wdHeaderId;
  final d.Value<int> pieceNum;
  final d.Value<String> accumOdd;
  final d.Value<String> genus;
  final d.Value<String> species;
  final d.Value<double> horLength;
  final d.Value<double> verDepth;
  final d.Value<int?> decayClass;
  const WoodyDebrisOddCompanion({
    this.id = const d.Value.absent(),
    this.wdHeaderId = const d.Value.absent(),
    this.pieceNum = const d.Value.absent(),
    this.accumOdd = const d.Value.absent(),
    this.genus = const d.Value.absent(),
    this.species = const d.Value.absent(),
    this.horLength = const d.Value.absent(),
    this.verDepth = const d.Value.absent(),
    this.decayClass = const d.Value.absent(),
  });
  WoodyDebrisOddCompanion.insert({
    this.id = const d.Value.absent(),
    required int wdHeaderId,
    required int pieceNum,
    required String accumOdd,
    required String genus,
    required String species,
    required double horLength,
    required double verDepth,
    this.decayClass = const d.Value.absent(),
  })  : wdHeaderId = d.Value(wdHeaderId),
        pieceNum = d.Value(pieceNum),
        accumOdd = d.Value(accumOdd),
        genus = d.Value(genus),
        species = d.Value(species),
        horLength = d.Value(horLength),
        verDepth = d.Value(verDepth);
  static d.Insertable<WoodyDebrisOddData> custom({
    d.Expression<int>? id,
    d.Expression<int>? wdHeaderId,
    d.Expression<int>? pieceNum,
    d.Expression<String>? accumOdd,
    d.Expression<String>? genus,
    d.Expression<String>? species,
    d.Expression<double>? horLength,
    d.Expression<double>? verDepth,
    d.Expression<int>? decayClass,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (wdHeaderId != null) 'wd_header_id': wdHeaderId,
      if (pieceNum != null) 'piece_num': pieceNum,
      if (accumOdd != null) 'accum_odd': accumOdd,
      if (genus != null) 'genus': genus,
      if (species != null) 'species': species,
      if (horLength != null) 'hor_length': horLength,
      if (verDepth != null) 'ver_depth': verDepth,
      if (decayClass != null) 'decay_class': decayClass,
    });
  }

  WoodyDebrisOddCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? wdHeaderId,
      d.Value<int>? pieceNum,
      d.Value<String>? accumOdd,
      d.Value<String>? genus,
      d.Value<String>? species,
      d.Value<double>? horLength,
      d.Value<double>? verDepth,
      d.Value<int?>? decayClass}) {
    return WoodyDebrisOddCompanion(
      id: id ?? this.id,
      wdHeaderId: wdHeaderId ?? this.wdHeaderId,
      pieceNum: pieceNum ?? this.pieceNum,
      accumOdd: accumOdd ?? this.accumOdd,
      genus: genus ?? this.genus,
      species: species ?? this.species,
      horLength: horLength ?? this.horLength,
      verDepth: verDepth ?? this.verDepth,
      decayClass: decayClass ?? this.decayClass,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (wdHeaderId.present) {
      map['wd_header_id'] = d.Variable<int>(wdHeaderId.value);
    }
    if (pieceNum.present) {
      map['piece_num'] = d.Variable<int>(pieceNum.value);
    }
    if (accumOdd.present) {
      map['accum_odd'] = d.Variable<String>(accumOdd.value);
    }
    if (genus.present) {
      map['genus'] = d.Variable<String>(genus.value);
    }
    if (species.present) {
      map['species'] = d.Variable<String>(species.value);
    }
    if (horLength.present) {
      map['hor_length'] = d.Variable<double>(horLength.value);
    }
    if (verDepth.present) {
      map['ver_depth'] = d.Variable<double>(verDepth.value);
    }
    if (decayClass.present) {
      map['decay_class'] = d.Variable<int>(decayClass.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WoodyDebrisOddCompanion(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('pieceNum: $pieceNum, ')
          ..write('accumOdd: $accumOdd, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('horLength: $horLength, ')
          ..write('verDepth: $verDepth, ')
          ..write('decayClass: $decayClass')
          ..write(')'))
        .toString();
  }
}

class $WoodyDebrisRoundTable extends WoodyDebrisRound
    with d.TableInfo<$WoodyDebrisRoundTable, WoodyDebrisRoundData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WoodyDebrisRoundTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _wdHeaderIdMeta =
      const d.VerificationMeta('wdHeaderId');
  @override
  late final d.GeneratedColumn<int> wdHeaderId = d.GeneratedColumn<int>(
      'wd_header_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES woody_debris_header (id)'));
  static const d.VerificationMeta _pieceNumMeta =
      const d.VerificationMeta('pieceNum');
  @override
  late final d.GeneratedColumn<int> pieceNum = d.GeneratedColumn<int>(
      'piece_num', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _genusMeta =
      const d.VerificationMeta('genus');
  @override
  late final d.GeneratedColumn<String> genus = d.GeneratedColumn<String>(
      'genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 4, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES tree_genus (genus_code)'));
  static const d.VerificationMeta _speciesMeta =
      const d.VerificationMeta('species');
  @override
  late final d.GeneratedColumn<String> species = d.GeneratedColumn<String>(
      'species', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES tree_genus (species_code)'));
  static const d.VerificationMeta _diameterMeta =
      const d.VerificationMeta('diameter');
  @override
  late final d.GeneratedColumn<double> diameter = d.GeneratedColumn<double>(
      'diameter', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const d.VerificationMeta _tiltAngleMeta =
      const d.VerificationMeta('tiltAngle');
  @override
  late final d.GeneratedColumn<int> tiltAngle = d.GeneratedColumn<int>(
      'tilt_angle', aliasedName, true,
      check: () => tiltAngle.isBetweenValues(-1, 90),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _decayClassMeta =
      const d.VerificationMeta('decayClass');
  @override
  late final d.GeneratedColumn<int> decayClass = d.GeneratedColumn<int>(
      'decay_class', aliasedName, true,
      check: () => decayClass.isBetweenValues(-1, 5),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        wdHeaderId,
        pieceNum,
        genus,
        species,
        diameter,
        tiltAngle,
        decayClass
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'woody_debris_round';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<WoodyDebrisRoundData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('wd_header_id')) {
      context.handle(
          _wdHeaderIdMeta,
          wdHeaderId.isAcceptableOrUnknown(
              data['wd_header_id']!, _wdHeaderIdMeta));
    } else if (isInserting) {
      context.missing(_wdHeaderIdMeta);
    }
    if (data.containsKey('piece_num')) {
      context.handle(_pieceNumMeta,
          pieceNum.isAcceptableOrUnknown(data['piece_num']!, _pieceNumMeta));
    } else if (isInserting) {
      context.missing(_pieceNumMeta);
    }
    if (data.containsKey('genus')) {
      context.handle(
          _genusMeta, genus.isAcceptableOrUnknown(data['genus']!, _genusMeta));
    } else if (isInserting) {
      context.missing(_genusMeta);
    }
    if (data.containsKey('species')) {
      context.handle(_speciesMeta,
          species.isAcceptableOrUnknown(data['species']!, _speciesMeta));
    } else if (isInserting) {
      context.missing(_speciesMeta);
    }
    if (data.containsKey('diameter')) {
      context.handle(_diameterMeta,
          diameter.isAcceptableOrUnknown(data['diameter']!, _diameterMeta));
    } else if (isInserting) {
      context.missing(_diameterMeta);
    }
    if (data.containsKey('tilt_angle')) {
      context.handle(_tiltAngleMeta,
          tiltAngle.isAcceptableOrUnknown(data['tilt_angle']!, _tiltAngleMeta));
    }
    if (data.containsKey('decay_class')) {
      context.handle(
          _decayClassMeta,
          decayClass.isAcceptableOrUnknown(
              data['decay_class']!, _decayClassMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  WoodyDebrisRoundData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WoodyDebrisRoundData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      wdHeaderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}wd_header_id'])!,
      pieceNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}piece_num'])!,
      genus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus'])!,
      species: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species'])!,
      diameter: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}diameter'])!,
      tiltAngle: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tilt_angle']),
      decayClass: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}decay_class']),
    );
  }

  @override
  $WoodyDebrisRoundTable createAlias(String alias) {
    return $WoodyDebrisRoundTable(attachedDatabase, alias);
  }
}

class WoodyDebrisRoundData extends d.DataClass
    implements d.Insertable<WoodyDebrisRoundData> {
  final int id;
  final int wdHeaderId;
  final int pieceNum;
  final String genus;
  final String species;
  final double diameter;
  final int? tiltAngle;
  final int? decayClass;
  const WoodyDebrisRoundData(
      {required this.id,
      required this.wdHeaderId,
      required this.pieceNum,
      required this.genus,
      required this.species,
      required this.diameter,
      this.tiltAngle,
      this.decayClass});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['wd_header_id'] = d.Variable<int>(wdHeaderId);
    map['piece_num'] = d.Variable<int>(pieceNum);
    map['genus'] = d.Variable<String>(genus);
    map['species'] = d.Variable<String>(species);
    map['diameter'] = d.Variable<double>(diameter);
    if (!nullToAbsent || tiltAngle != null) {
      map['tilt_angle'] = d.Variable<int>(tiltAngle);
    }
    if (!nullToAbsent || decayClass != null) {
      map['decay_class'] = d.Variable<int>(decayClass);
    }
    return map;
  }

  WoodyDebrisRoundCompanion toCompanion(bool nullToAbsent) {
    return WoodyDebrisRoundCompanion(
      id: d.Value(id),
      wdHeaderId: d.Value(wdHeaderId),
      pieceNum: d.Value(pieceNum),
      genus: d.Value(genus),
      species: d.Value(species),
      diameter: d.Value(diameter),
      tiltAngle: tiltAngle == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(tiltAngle),
      decayClass: decayClass == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(decayClass),
    );
  }

  factory WoodyDebrisRoundData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return WoodyDebrisRoundData(
      id: serializer.fromJson<int>(json['id']),
      wdHeaderId: serializer.fromJson<int>(json['wdHeaderId']),
      pieceNum: serializer.fromJson<int>(json['pieceNum']),
      genus: serializer.fromJson<String>(json['genus']),
      species: serializer.fromJson<String>(json['species']),
      diameter: serializer.fromJson<double>(json['diameter']),
      tiltAngle: serializer.fromJson<int?>(json['tiltAngle']),
      decayClass: serializer.fromJson<int?>(json['decayClass']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'wdHeaderId': serializer.toJson<int>(wdHeaderId),
      'pieceNum': serializer.toJson<int>(pieceNum),
      'genus': serializer.toJson<String>(genus),
      'species': serializer.toJson<String>(species),
      'diameter': serializer.toJson<double>(diameter),
      'tiltAngle': serializer.toJson<int?>(tiltAngle),
      'decayClass': serializer.toJson<int?>(decayClass),
    };
  }

  WoodyDebrisRoundData copyWith(
          {int? id,
          int? wdHeaderId,
          int? pieceNum,
          String? genus,
          String? species,
          double? diameter,
          d.Value<int?> tiltAngle = const d.Value.absent(),
          d.Value<int?> decayClass = const d.Value.absent()}) =>
      WoodyDebrisRoundData(
        id: id ?? this.id,
        wdHeaderId: wdHeaderId ?? this.wdHeaderId,
        pieceNum: pieceNum ?? this.pieceNum,
        genus: genus ?? this.genus,
        species: species ?? this.species,
        diameter: diameter ?? this.diameter,
        tiltAngle: tiltAngle.present ? tiltAngle.value : this.tiltAngle,
        decayClass: decayClass.present ? decayClass.value : this.decayClass,
      );
  @override
  String toString() {
    return (StringBuffer('WoodyDebrisRoundData(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('pieceNum: $pieceNum, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('diameter: $diameter, ')
          ..write('tiltAngle: $tiltAngle, ')
          ..write('decayClass: $decayClass')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, wdHeaderId, pieceNum, genus, species,
      diameter, tiltAngle, decayClass);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WoodyDebrisRoundData &&
          other.id == this.id &&
          other.wdHeaderId == this.wdHeaderId &&
          other.pieceNum == this.pieceNum &&
          other.genus == this.genus &&
          other.species == this.species &&
          other.diameter == this.diameter &&
          other.tiltAngle == this.tiltAngle &&
          other.decayClass == this.decayClass);
}

class WoodyDebrisRoundCompanion
    extends d.UpdateCompanion<WoodyDebrisRoundData> {
  final d.Value<int> id;
  final d.Value<int> wdHeaderId;
  final d.Value<int> pieceNum;
  final d.Value<String> genus;
  final d.Value<String> species;
  final d.Value<double> diameter;
  final d.Value<int?> tiltAngle;
  final d.Value<int?> decayClass;
  const WoodyDebrisRoundCompanion({
    this.id = const d.Value.absent(),
    this.wdHeaderId = const d.Value.absent(),
    this.pieceNum = const d.Value.absent(),
    this.genus = const d.Value.absent(),
    this.species = const d.Value.absent(),
    this.diameter = const d.Value.absent(),
    this.tiltAngle = const d.Value.absent(),
    this.decayClass = const d.Value.absent(),
  });
  WoodyDebrisRoundCompanion.insert({
    this.id = const d.Value.absent(),
    required int wdHeaderId,
    required int pieceNum,
    required String genus,
    required String species,
    required double diameter,
    this.tiltAngle = const d.Value.absent(),
    this.decayClass = const d.Value.absent(),
  })  : wdHeaderId = d.Value(wdHeaderId),
        pieceNum = d.Value(pieceNum),
        genus = d.Value(genus),
        species = d.Value(species),
        diameter = d.Value(diameter);
  static d.Insertable<WoodyDebrisRoundData> custom({
    d.Expression<int>? id,
    d.Expression<int>? wdHeaderId,
    d.Expression<int>? pieceNum,
    d.Expression<String>? genus,
    d.Expression<String>? species,
    d.Expression<double>? diameter,
    d.Expression<int>? tiltAngle,
    d.Expression<int>? decayClass,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (wdHeaderId != null) 'wd_header_id': wdHeaderId,
      if (pieceNum != null) 'piece_num': pieceNum,
      if (genus != null) 'genus': genus,
      if (species != null) 'species': species,
      if (diameter != null) 'diameter': diameter,
      if (tiltAngle != null) 'tilt_angle': tiltAngle,
      if (decayClass != null) 'decay_class': decayClass,
    });
  }

  WoodyDebrisRoundCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? wdHeaderId,
      d.Value<int>? pieceNum,
      d.Value<String>? genus,
      d.Value<String>? species,
      d.Value<double>? diameter,
      d.Value<int?>? tiltAngle,
      d.Value<int?>? decayClass}) {
    return WoodyDebrisRoundCompanion(
      id: id ?? this.id,
      wdHeaderId: wdHeaderId ?? this.wdHeaderId,
      pieceNum: pieceNum ?? this.pieceNum,
      genus: genus ?? this.genus,
      species: species ?? this.species,
      diameter: diameter ?? this.diameter,
      tiltAngle: tiltAngle ?? this.tiltAngle,
      decayClass: decayClass ?? this.decayClass,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (wdHeaderId.present) {
      map['wd_header_id'] = d.Variable<int>(wdHeaderId.value);
    }
    if (pieceNum.present) {
      map['piece_num'] = d.Variable<int>(pieceNum.value);
    }
    if (genus.present) {
      map['genus'] = d.Variable<String>(genus.value);
    }
    if (species.present) {
      map['species'] = d.Variable<String>(species.value);
    }
    if (diameter.present) {
      map['diameter'] = d.Variable<double>(diameter.value);
    }
    if (tiltAngle.present) {
      map['tilt_angle'] = d.Variable<int>(tiltAngle.value);
    }
    if (decayClass.present) {
      map['decay_class'] = d.Variable<int>(decayClass.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WoodyDebrisRoundCompanion(')
          ..write('id: $id, ')
          ..write('wdHeaderId: $wdHeaderId, ')
          ..write('pieceNum: $pieceNum, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('diameter: $diameter, ')
          ..write('tiltAngle: $tiltAngle, ')
          ..write('decayClass: $decayClass')
          ..write(')'))
        .toString();
  }
}

class $SurfaceSubstrateSummaryTable extends SurfaceSubstrateSummary
    with
        d
        .TableInfo<$SurfaceSubstrateSummaryTable, SurfaceSubstrateSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurfaceSubstrateSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _numTransectsMeta =
      const d.VerificationMeta('numTransects');
  @override
  late final d.GeneratedColumn<int> numTransects = d.GeneratedColumn<int>(
      'num_transects', aliasedName, true,
      check: () => numTransects.isBetweenValues(1, 9),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, measDate, numTransects, notAssessed, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'surface_substrate_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurfaceSubstrateSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('num_transects')) {
      context.handle(
          _numTransectsMeta,
          numTransects.isAcceptableOrUnknown(
              data['num_transects']!, _numTransectsMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurfaceSubstrateSummaryData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurfaceSubstrateSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      numTransects: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num_transects']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $SurfaceSubstrateSummaryTable createAlias(String alias) {
    return $SurfaceSubstrateSummaryTable(attachedDatabase, alias);
  }
}

class SurfaceSubstrateSummaryData extends d.DataClass
    implements d.Insertable<SurfaceSubstrateSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final int? numTransects;
  final bool notAssessed;
  final bool complete;
  const SurfaceSubstrateSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      this.numTransects,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    if (!nullToAbsent || numTransects != null) {
      map['num_transects'] = d.Variable<int>(numTransects);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  SurfaceSubstrateSummaryCompanion toCompanion(bool nullToAbsent) {
    return SurfaceSubstrateSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      numTransects: numTransects == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(numTransects),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory SurfaceSubstrateSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurfaceSubstrateSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      numTransects: serializer.fromJson<int?>(json['numTransects']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'numTransects': serializer.toJson<int?>(numTransects),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  SurfaceSubstrateSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          d.Value<int?> numTransects = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      SurfaceSubstrateSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        numTransects:
            numTransects.present ? numTransects.value : this.numTransects,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numTransects: $numTransects, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, surveyId, measDate, numTransects, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurfaceSubstrateSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.numTransects == this.numTransects &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class SurfaceSubstrateSummaryCompanion
    extends d.UpdateCompanion<SurfaceSubstrateSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<int?> numTransects;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const SurfaceSubstrateSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.numTransects = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  SurfaceSubstrateSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.numTransects = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<SurfaceSubstrateSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<int>? numTransects,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (numTransects != null) 'num_transects': numTransects,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  SurfaceSubstrateSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<int?>? numTransects,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return SurfaceSubstrateSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      numTransects: numTransects ?? this.numTransects,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (numTransects.present) {
      map['num_transects'] = d.Variable<int>(numTransects.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numTransects: $numTransects, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $SurfaceSubstrateHeaderTable extends SurfaceSubstrateHeader
    with d.TableInfo<$SurfaceSubstrateHeaderTable, SurfaceSubstrateHeaderData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurfaceSubstrateHeaderTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _ssIdMeta = const d.VerificationMeta('ssId');
  @override
  late final d.GeneratedColumn<int> ssId = d.GeneratedColumn<int>(
      'ss_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES surface_substrate_summary (id)'));
  static const d.VerificationMeta _transNumMeta =
      const d.VerificationMeta('transNum');
  @override
  late final d.GeneratedColumn<int> transNum = d.GeneratedColumn<int>(
      'trans_num', aliasedName, false,
      check: () => transNum.isBetweenValues(1, 9),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nomTransLenMeta =
      const d.VerificationMeta('nomTransLen');
  @override
  late final d.GeneratedColumn<double> nomTransLen = d.GeneratedColumn<double>(
      'nom_trans_len', aliasedName, true,
      check: () => nomTransLen.isBetweenValues(10.0, 150.0),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _transAzimuthMeta =
      const d.VerificationMeta('transAzimuth');
  @override
  late final d.GeneratedColumn<int> transAzimuth = d.GeneratedColumn<int>(
      'trans_azimuth', aliasedName, true,
      check: () => transAzimuth.isBetweenValues(0, 360),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, ssId, transNum, nomTransLen, transAzimuth, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'surface_substrate_header';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurfaceSubstrateHeaderData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('ss_id')) {
      context.handle(
          _ssIdMeta, ssId.isAcceptableOrUnknown(data['ss_id']!, _ssIdMeta));
    } else if (isInserting) {
      context.missing(_ssIdMeta);
    }
    if (data.containsKey('trans_num')) {
      context.handle(_transNumMeta,
          transNum.isAcceptableOrUnknown(data['trans_num']!, _transNumMeta));
    } else if (isInserting) {
      context.missing(_transNumMeta);
    }
    if (data.containsKey('nom_trans_len')) {
      context.handle(
          _nomTransLenMeta,
          nomTransLen.isAcceptableOrUnknown(
              data['nom_trans_len']!, _nomTransLenMeta));
    }
    if (data.containsKey('trans_azimuth')) {
      context.handle(
          _transAzimuthMeta,
          transAzimuth.isAcceptableOrUnknown(
              data['trans_azimuth']!, _transAzimuthMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurfaceSubstrateHeaderData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurfaceSubstrateHeaderData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      ssId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ss_id'])!,
      transNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}trans_num'])!,
      nomTransLen: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_trans_len']),
      transAzimuth: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}trans_azimuth']),
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $SurfaceSubstrateHeaderTable createAlias(String alias) {
    return $SurfaceSubstrateHeaderTable(attachedDatabase, alias);
  }
}

class SurfaceSubstrateHeaderData extends d.DataClass
    implements d.Insertable<SurfaceSubstrateHeaderData> {
  final int id;
  final int ssId;
  final int transNum;
  final double? nomTransLen;
  final int? transAzimuth;
  final bool complete;
  const SurfaceSubstrateHeaderData(
      {required this.id,
      required this.ssId,
      required this.transNum,
      this.nomTransLen,
      this.transAzimuth,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['ss_id'] = d.Variable<int>(ssId);
    map['trans_num'] = d.Variable<int>(transNum);
    if (!nullToAbsent || nomTransLen != null) {
      map['nom_trans_len'] = d.Variable<double>(nomTransLen);
    }
    if (!nullToAbsent || transAzimuth != null) {
      map['trans_azimuth'] = d.Variable<int>(transAzimuth);
    }
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  SurfaceSubstrateHeaderCompanion toCompanion(bool nullToAbsent) {
    return SurfaceSubstrateHeaderCompanion(
      id: d.Value(id),
      ssId: d.Value(ssId),
      transNum: d.Value(transNum),
      nomTransLen: nomTransLen == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomTransLen),
      transAzimuth: transAzimuth == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(transAzimuth),
      complete: d.Value(complete),
    );
  }

  factory SurfaceSubstrateHeaderData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurfaceSubstrateHeaderData(
      id: serializer.fromJson<int>(json['id']),
      ssId: serializer.fromJson<int>(json['ssId']),
      transNum: serializer.fromJson<int>(json['transNum']),
      nomTransLen: serializer.fromJson<double?>(json['nomTransLen']),
      transAzimuth: serializer.fromJson<int?>(json['transAzimuth']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ssId': serializer.toJson<int>(ssId),
      'transNum': serializer.toJson<int>(transNum),
      'nomTransLen': serializer.toJson<double?>(nomTransLen),
      'transAzimuth': serializer.toJson<int?>(transAzimuth),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  SurfaceSubstrateHeaderData copyWith(
          {int? id,
          int? ssId,
          int? transNum,
          d.Value<double?> nomTransLen = const d.Value.absent(),
          d.Value<int?> transAzimuth = const d.Value.absent(),
          bool? complete}) =>
      SurfaceSubstrateHeaderData(
        id: id ?? this.id,
        ssId: ssId ?? this.ssId,
        transNum: transNum ?? this.transNum,
        nomTransLen: nomTransLen.present ? nomTransLen.value : this.nomTransLen,
        transAzimuth:
            transAzimuth.present ? transAzimuth.value : this.transAzimuth,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateHeaderData(')
          ..write('id: $id, ')
          ..write('ssId: $ssId, ')
          ..write('transNum: $transNum, ')
          ..write('nomTransLen: $nomTransLen, ')
          ..write('transAzimuth: $transAzimuth, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, ssId, transNum, nomTransLen, transAzimuth, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurfaceSubstrateHeaderData &&
          other.id == this.id &&
          other.ssId == this.ssId &&
          other.transNum == this.transNum &&
          other.nomTransLen == this.nomTransLen &&
          other.transAzimuth == this.transAzimuth &&
          other.complete == this.complete);
}

class SurfaceSubstrateHeaderCompanion
    extends d.UpdateCompanion<SurfaceSubstrateHeaderData> {
  final d.Value<int> id;
  final d.Value<int> ssId;
  final d.Value<int> transNum;
  final d.Value<double?> nomTransLen;
  final d.Value<int?> transAzimuth;
  final d.Value<bool> complete;
  const SurfaceSubstrateHeaderCompanion({
    this.id = const d.Value.absent(),
    this.ssId = const d.Value.absent(),
    this.transNum = const d.Value.absent(),
    this.nomTransLen = const d.Value.absent(),
    this.transAzimuth = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  SurfaceSubstrateHeaderCompanion.insert({
    this.id = const d.Value.absent(),
    required int ssId,
    required int transNum,
    this.nomTransLen = const d.Value.absent(),
    this.transAzimuth = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : ssId = d.Value(ssId),
        transNum = d.Value(transNum);
  static d.Insertable<SurfaceSubstrateHeaderData> custom({
    d.Expression<int>? id,
    d.Expression<int>? ssId,
    d.Expression<int>? transNum,
    d.Expression<double>? nomTransLen,
    d.Expression<int>? transAzimuth,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (ssId != null) 'ss_id': ssId,
      if (transNum != null) 'trans_num': transNum,
      if (nomTransLen != null) 'nom_trans_len': nomTransLen,
      if (transAzimuth != null) 'trans_azimuth': transAzimuth,
      if (complete != null) 'complete': complete,
    });
  }

  SurfaceSubstrateHeaderCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? ssId,
      d.Value<int>? transNum,
      d.Value<double?>? nomTransLen,
      d.Value<int?>? transAzimuth,
      d.Value<bool>? complete}) {
    return SurfaceSubstrateHeaderCompanion(
      id: id ?? this.id,
      ssId: ssId ?? this.ssId,
      transNum: transNum ?? this.transNum,
      nomTransLen: nomTransLen ?? this.nomTransLen,
      transAzimuth: transAzimuth ?? this.transAzimuth,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (ssId.present) {
      map['ss_id'] = d.Variable<int>(ssId.value);
    }
    if (transNum.present) {
      map['trans_num'] = d.Variable<int>(transNum.value);
    }
    if (nomTransLen.present) {
      map['nom_trans_len'] = d.Variable<double>(nomTransLen.value);
    }
    if (transAzimuth.present) {
      map['trans_azimuth'] = d.Variable<int>(transAzimuth.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateHeaderCompanion(')
          ..write('id: $id, ')
          ..write('ssId: $ssId, ')
          ..write('transNum: $transNum, ')
          ..write('nomTransLen: $nomTransLen, ')
          ..write('transAzimuth: $transAzimuth, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $SurfaceSubstrateTallyTable extends SurfaceSubstrateTally
    with d.TableInfo<$SurfaceSubstrateTallyTable, SurfaceSubstrateTallyData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SurfaceSubstrateTallyTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _ssHeaderIdMeta =
      const d.VerificationMeta('ssHeaderId');
  @override
  late final d.GeneratedColumn<int> ssHeaderId = d.GeneratedColumn<int>(
      'ss_header_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES surface_substrate_header (id)'));
  static const d.VerificationMeta _stationNumMeta =
      const d.VerificationMeta('stationNum');
  @override
  late final d.GeneratedColumn<int> stationNum = d.GeneratedColumn<int>(
      'station_num', aliasedName, false,
      check: () => stationNum.isBetweenValues(1, 25),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _substrateTypeMeta =
      const d.VerificationMeta('substrateType');
  @override
  late final d.GeneratedColumn<String> substrateType =
      d.GeneratedColumn<String>('substrate_type', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _depthMeta =
      const d.VerificationMeta('depth');
  @override
  late final d.GeneratedColumn<int> depth = d.GeneratedColumn<int>(
      'depth', aliasedName, false,
      check: () => depth.isBetweenValues(-9, 500),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _depthLimitMeta =
      const d.VerificationMeta('depthLimit');
  @override
  late final d.GeneratedColumn<int> depthLimit = d.GeneratedColumn<int>(
      'depth_limit', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, ssHeaderId, stationNum, substrateType, depth, depthLimit];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'surface_substrate_tally';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SurfaceSubstrateTallyData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('ss_header_id')) {
      context.handle(
          _ssHeaderIdMeta,
          ssHeaderId.isAcceptableOrUnknown(
              data['ss_header_id']!, _ssHeaderIdMeta));
    } else if (isInserting) {
      context.missing(_ssHeaderIdMeta);
    }
    if (data.containsKey('station_num')) {
      context.handle(
          _stationNumMeta,
          stationNum.isAcceptableOrUnknown(
              data['station_num']!, _stationNumMeta));
    } else if (isInserting) {
      context.missing(_stationNumMeta);
    }
    if (data.containsKey('substrate_type')) {
      context.handle(
          _substrateTypeMeta,
          substrateType.isAcceptableOrUnknown(
              data['substrate_type']!, _substrateTypeMeta));
    } else if (isInserting) {
      context.missing(_substrateTypeMeta);
    }
    if (data.containsKey('depth')) {
      context.handle(
          _depthMeta, depth.isAcceptableOrUnknown(data['depth']!, _depthMeta));
    } else if (isInserting) {
      context.missing(_depthMeta);
    }
    if (data.containsKey('depth_limit')) {
      context.handle(
          _depthLimitMeta,
          depthLimit.isAcceptableOrUnknown(
              data['depth_limit']!, _depthLimitMeta));
    } else if (isInserting) {
      context.missing(_depthLimitMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SurfaceSubstrateTallyData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SurfaceSubstrateTallyData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      ssHeaderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ss_header_id'])!,
      stationNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}station_num'])!,
      substrateType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}substrate_type'])!,
      depth: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}depth'])!,
      depthLimit: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}depth_limit'])!,
    );
  }

  @override
  $SurfaceSubstrateTallyTable createAlias(String alias) {
    return $SurfaceSubstrateTallyTable(attachedDatabase, alias);
  }
}

class SurfaceSubstrateTallyData extends d.DataClass
    implements d.Insertable<SurfaceSubstrateTallyData> {
  final int id;
  final int ssHeaderId;
  final int stationNum;
  final String substrateType;
  final int depth;
  final int depthLimit;
  const SurfaceSubstrateTallyData(
      {required this.id,
      required this.ssHeaderId,
      required this.stationNum,
      required this.substrateType,
      required this.depth,
      required this.depthLimit});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['ss_header_id'] = d.Variable<int>(ssHeaderId);
    map['station_num'] = d.Variable<int>(stationNum);
    map['substrate_type'] = d.Variable<String>(substrateType);
    map['depth'] = d.Variable<int>(depth);
    map['depth_limit'] = d.Variable<int>(depthLimit);
    return map;
  }

  SurfaceSubstrateTallyCompanion toCompanion(bool nullToAbsent) {
    return SurfaceSubstrateTallyCompanion(
      id: d.Value(id),
      ssHeaderId: d.Value(ssHeaderId),
      stationNum: d.Value(stationNum),
      substrateType: d.Value(substrateType),
      depth: d.Value(depth),
      depthLimit: d.Value(depthLimit),
    );
  }

  factory SurfaceSubstrateTallyData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SurfaceSubstrateTallyData(
      id: serializer.fromJson<int>(json['id']),
      ssHeaderId: serializer.fromJson<int>(json['ssHeaderId']),
      stationNum: serializer.fromJson<int>(json['stationNum']),
      substrateType: serializer.fromJson<String>(json['substrateType']),
      depth: serializer.fromJson<int>(json['depth']),
      depthLimit: serializer.fromJson<int>(json['depthLimit']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ssHeaderId': serializer.toJson<int>(ssHeaderId),
      'stationNum': serializer.toJson<int>(stationNum),
      'substrateType': serializer.toJson<String>(substrateType),
      'depth': serializer.toJson<int>(depth),
      'depthLimit': serializer.toJson<int>(depthLimit),
    };
  }

  SurfaceSubstrateTallyData copyWith(
          {int? id,
          int? ssHeaderId,
          int? stationNum,
          String? substrateType,
          int? depth,
          int? depthLimit}) =>
      SurfaceSubstrateTallyData(
        id: id ?? this.id,
        ssHeaderId: ssHeaderId ?? this.ssHeaderId,
        stationNum: stationNum ?? this.stationNum,
        substrateType: substrateType ?? this.substrateType,
        depth: depth ?? this.depth,
        depthLimit: depthLimit ?? this.depthLimit,
      );
  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateTallyData(')
          ..write('id: $id, ')
          ..write('ssHeaderId: $ssHeaderId, ')
          ..write('stationNum: $stationNum, ')
          ..write('substrateType: $substrateType, ')
          ..write('depth: $depth, ')
          ..write('depthLimit: $depthLimit')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, ssHeaderId, stationNum, substrateType, depth, depthLimit);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SurfaceSubstrateTallyData &&
          other.id == this.id &&
          other.ssHeaderId == this.ssHeaderId &&
          other.stationNum == this.stationNum &&
          other.substrateType == this.substrateType &&
          other.depth == this.depth &&
          other.depthLimit == this.depthLimit);
}

class SurfaceSubstrateTallyCompanion
    extends d.UpdateCompanion<SurfaceSubstrateTallyData> {
  final d.Value<int> id;
  final d.Value<int> ssHeaderId;
  final d.Value<int> stationNum;
  final d.Value<String> substrateType;
  final d.Value<int> depth;
  final d.Value<int> depthLimit;
  const SurfaceSubstrateTallyCompanion({
    this.id = const d.Value.absent(),
    this.ssHeaderId = const d.Value.absent(),
    this.stationNum = const d.Value.absent(),
    this.substrateType = const d.Value.absent(),
    this.depth = const d.Value.absent(),
    this.depthLimit = const d.Value.absent(),
  });
  SurfaceSubstrateTallyCompanion.insert({
    this.id = const d.Value.absent(),
    required int ssHeaderId,
    required int stationNum,
    required String substrateType,
    required int depth,
    required int depthLimit,
  })  : ssHeaderId = d.Value(ssHeaderId),
        stationNum = d.Value(stationNum),
        substrateType = d.Value(substrateType),
        depth = d.Value(depth),
        depthLimit = d.Value(depthLimit);
  static d.Insertable<SurfaceSubstrateTallyData> custom({
    d.Expression<int>? id,
    d.Expression<int>? ssHeaderId,
    d.Expression<int>? stationNum,
    d.Expression<String>? substrateType,
    d.Expression<int>? depth,
    d.Expression<int>? depthLimit,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (ssHeaderId != null) 'ss_header_id': ssHeaderId,
      if (stationNum != null) 'station_num': stationNum,
      if (substrateType != null) 'substrate_type': substrateType,
      if (depth != null) 'depth': depth,
      if (depthLimit != null) 'depth_limit': depthLimit,
    });
  }

  SurfaceSubstrateTallyCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? ssHeaderId,
      d.Value<int>? stationNum,
      d.Value<String>? substrateType,
      d.Value<int>? depth,
      d.Value<int>? depthLimit}) {
    return SurfaceSubstrateTallyCompanion(
      id: id ?? this.id,
      ssHeaderId: ssHeaderId ?? this.ssHeaderId,
      stationNum: stationNum ?? this.stationNum,
      substrateType: substrateType ?? this.substrateType,
      depth: depth ?? this.depth,
      depthLimit: depthLimit ?? this.depthLimit,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (ssHeaderId.present) {
      map['ss_header_id'] = d.Variable<int>(ssHeaderId.value);
    }
    if (stationNum.present) {
      map['station_num'] = d.Variable<int>(stationNum.value);
    }
    if (substrateType.present) {
      map['substrate_type'] = d.Variable<String>(substrateType.value);
    }
    if (depth.present) {
      map['depth'] = d.Variable<int>(depth.value);
    }
    if (depthLimit.present) {
      map['depth_limit'] = d.Variable<int>(depthLimit.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SurfaceSubstrateTallyCompanion(')
          ..write('id: $id, ')
          ..write('ssHeaderId: $ssHeaderId, ')
          ..write('stationNum: $stationNum, ')
          ..write('substrateType: $substrateType, ')
          ..write('depth: $depth, ')
          ..write('depthLimit: $depthLimit')
          ..write(')'))
        .toString();
  }
}

class $EcpSummaryTable extends EcpSummary
    with d.TableInfo<$EcpSummaryTable, EcpSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _numEcpsMeta =
      const d.VerificationMeta('numEcps');
  @override
  late final d.GeneratedColumn<int> numEcps = d.GeneratedColumn<int>(
      'num_ecps', aliasedName, true,
      check: () => numEcps.isBetweenValues(1, 9),
      type: DriftSqlType.int,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, measDate, numEcps, notAssessed, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_summary';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<EcpSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('num_ecps')) {
      context.handle(_numEcpsMeta,
          numEcps.isAcceptableOrUnknown(data['num_ecps']!, _numEcpsMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  EcpSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      numEcps: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}num_ecps']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $EcpSummaryTable createAlias(String alias) {
    return $EcpSummaryTable(attachedDatabase, alias);
  }
}

class EcpSummaryData extends d.DataClass
    implements d.Insertable<EcpSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final int? numEcps;
  final bool notAssessed;
  final bool complete;
  const EcpSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      this.numEcps,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    if (!nullToAbsent || numEcps != null) {
      map['num_ecps'] = d.Variable<int>(numEcps);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  EcpSummaryCompanion toCompanion(bool nullToAbsent) {
    return EcpSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      numEcps: numEcps == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(numEcps),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory EcpSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      numEcps: serializer.fromJson<int?>(json['numEcps']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'numEcps': serializer.toJson<int?>(numEcps),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  EcpSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          d.Value<int?> numEcps = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      EcpSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        numEcps: numEcps.present ? numEcps.value : this.numEcps,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('EcpSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numEcps: $numEcps, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, surveyId, measDate, numEcps, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.numEcps == this.numEcps &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class EcpSummaryCompanion extends d.UpdateCompanion<EcpSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<int?> numEcps;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const EcpSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.numEcps = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  EcpSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.numEcps = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<EcpSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<int>? numEcps,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (numEcps != null) 'num_ecps': numEcps,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  EcpSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<int?>? numEcps,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return EcpSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      numEcps: numEcps ?? this.numEcps,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (numEcps.present) {
      map['num_ecps'] = d.Variable<int>(numEcps.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('numEcps: $numEcps, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $EcpHeaderTable extends EcpHeader
    with d.TableInfo<$EcpHeaderTable, EcpHeaderData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpHeaderTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _ecpSummaryIdMeta =
      const d.VerificationMeta('ecpSummaryId');
  @override
  late final d.GeneratedColumn<int> ecpSummaryId = d.GeneratedColumn<int>(
      'ecp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ecp_summary (id)'));
  static const d.VerificationMeta _ecpNumMeta =
      const d.VerificationMeta('ecpNum');
  @override
  late final d.GeneratedColumn<int> ecpNum = d.GeneratedColumn<int>(
      'ecp_num', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _plotTypeMeta =
      const d.VerificationMeta('plotType');
  @override
  late final d.GeneratedColumn<String> plotType = d.GeneratedColumn<String>(
      'plot_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _nomPlotSizeMeta =
      const d.VerificationMeta('nomPlotSize');
  @override
  late final d.GeneratedColumn<double> nomPlotSize = d.GeneratedColumn<double>(
      'nom_plot_size', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const d.VerificationMeta _measPlotSizeMeta =
      const d.VerificationMeta('measPlotSize');
  @override
  late final d.GeneratedColumn<double> measPlotSize = d.GeneratedColumn<double>(
      'meas_plot_size', aliasedName, true,
      check: () => measPlotSize.isBetweenValues(0.000025, 1.0),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, ecpSummaryId, ecpNum, complete, plotType, nomPlotSize, measPlotSize];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_header';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<EcpHeaderData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('ecp_summary_id')) {
      context.handle(
          _ecpSummaryIdMeta,
          ecpSummaryId.isAcceptableOrUnknown(
              data['ecp_summary_id']!, _ecpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_ecpSummaryIdMeta);
    }
    if (data.containsKey('ecp_num')) {
      context.handle(_ecpNumMeta,
          ecpNum.isAcceptableOrUnknown(data['ecp_num']!, _ecpNumMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    if (data.containsKey('plot_type')) {
      context.handle(_plotTypeMeta,
          plotType.isAcceptableOrUnknown(data['plot_type']!, _plotTypeMeta));
    }
    if (data.containsKey('nom_plot_size')) {
      context.handle(
          _nomPlotSizeMeta,
          nomPlotSize.isAcceptableOrUnknown(
              data['nom_plot_size']!, _nomPlotSizeMeta));
    }
    if (data.containsKey('meas_plot_size')) {
      context.handle(
          _measPlotSizeMeta,
          measPlotSize.isAcceptableOrUnknown(
              data['meas_plot_size']!, _measPlotSizeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  EcpHeaderData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpHeaderData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      ecpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ecp_summary_id'])!,
      ecpNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ecp_num']),
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
      plotType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}plot_type']),
      nomPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_plot_size']),
      measPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}meas_plot_size']),
    );
  }

  @override
  $EcpHeaderTable createAlias(String alias) {
    return $EcpHeaderTable(attachedDatabase, alias);
  }
}

class EcpHeaderData extends d.DataClass implements d.Insertable<EcpHeaderData> {
  final int id;
  final int ecpSummaryId;
  final int? ecpNum;
  final bool complete;
  final String? plotType;
  final double? nomPlotSize;
  final double? measPlotSize;
  const EcpHeaderData(
      {required this.id,
      required this.ecpSummaryId,
      this.ecpNum,
      required this.complete,
      this.plotType,
      this.nomPlotSize,
      this.measPlotSize});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['ecp_summary_id'] = d.Variable<int>(ecpSummaryId);
    if (!nullToAbsent || ecpNum != null) {
      map['ecp_num'] = d.Variable<int>(ecpNum);
    }
    map['complete'] = d.Variable<bool>(complete);
    if (!nullToAbsent || plotType != null) {
      map['plot_type'] = d.Variable<String>(plotType);
    }
    if (!nullToAbsent || nomPlotSize != null) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize);
    }
    if (!nullToAbsent || measPlotSize != null) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize);
    }
    return map;
  }

  EcpHeaderCompanion toCompanion(bool nullToAbsent) {
    return EcpHeaderCompanion(
      id: d.Value(id),
      ecpSummaryId: d.Value(ecpSummaryId),
      ecpNum: ecpNum == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(ecpNum),
      complete: d.Value(complete),
      plotType: plotType == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(plotType),
      nomPlotSize: nomPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomPlotSize),
      measPlotSize: measPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(measPlotSize),
    );
  }

  factory EcpHeaderData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpHeaderData(
      id: serializer.fromJson<int>(json['id']),
      ecpSummaryId: serializer.fromJson<int>(json['ecpSummaryId']),
      ecpNum: serializer.fromJson<int?>(json['ecpNum']),
      complete: serializer.fromJson<bool>(json['complete']),
      plotType: serializer.fromJson<String?>(json['plotType']),
      nomPlotSize: serializer.fromJson<double?>(json['nomPlotSize']),
      measPlotSize: serializer.fromJson<double?>(json['measPlotSize']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ecpSummaryId': serializer.toJson<int>(ecpSummaryId),
      'ecpNum': serializer.toJson<int?>(ecpNum),
      'complete': serializer.toJson<bool>(complete),
      'plotType': serializer.toJson<String?>(plotType),
      'nomPlotSize': serializer.toJson<double?>(nomPlotSize),
      'measPlotSize': serializer.toJson<double?>(measPlotSize),
    };
  }

  EcpHeaderData copyWith(
          {int? id,
          int? ecpSummaryId,
          d.Value<int?> ecpNum = const d.Value.absent(),
          bool? complete,
          d.Value<String?> plotType = const d.Value.absent(),
          d.Value<double?> nomPlotSize = const d.Value.absent(),
          d.Value<double?> measPlotSize = const d.Value.absent()}) =>
      EcpHeaderData(
        id: id ?? this.id,
        ecpSummaryId: ecpSummaryId ?? this.ecpSummaryId,
        ecpNum: ecpNum.present ? ecpNum.value : this.ecpNum,
        complete: complete ?? this.complete,
        plotType: plotType.present ? plotType.value : this.plotType,
        nomPlotSize: nomPlotSize.present ? nomPlotSize.value : this.nomPlotSize,
        measPlotSize:
            measPlotSize.present ? measPlotSize.value : this.measPlotSize,
      );
  @override
  String toString() {
    return (StringBuffer('EcpHeaderData(')
          ..write('id: $id, ')
          ..write('ecpSummaryId: $ecpSummaryId, ')
          ..write('ecpNum: $ecpNum, ')
          ..write('complete: $complete, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, ecpSummaryId, ecpNum, complete, plotType, nomPlotSize, measPlotSize);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpHeaderData &&
          other.id == this.id &&
          other.ecpSummaryId == this.ecpSummaryId &&
          other.ecpNum == this.ecpNum &&
          other.complete == this.complete &&
          other.plotType == this.plotType &&
          other.nomPlotSize == this.nomPlotSize &&
          other.measPlotSize == this.measPlotSize);
}

class EcpHeaderCompanion extends d.UpdateCompanion<EcpHeaderData> {
  final d.Value<int> id;
  final d.Value<int> ecpSummaryId;
  final d.Value<int?> ecpNum;
  final d.Value<bool> complete;
  final d.Value<String?> plotType;
  final d.Value<double?> nomPlotSize;
  final d.Value<double?> measPlotSize;
  const EcpHeaderCompanion({
    this.id = const d.Value.absent(),
    this.ecpSummaryId = const d.Value.absent(),
    this.ecpNum = const d.Value.absent(),
    this.complete = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
  });
  EcpHeaderCompanion.insert({
    this.id = const d.Value.absent(),
    required int ecpSummaryId,
    this.ecpNum = const d.Value.absent(),
    this.complete = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
  }) : ecpSummaryId = d.Value(ecpSummaryId);
  static d.Insertable<EcpHeaderData> custom({
    d.Expression<int>? id,
    d.Expression<int>? ecpSummaryId,
    d.Expression<int>? ecpNum,
    d.Expression<bool>? complete,
    d.Expression<String>? plotType,
    d.Expression<double>? nomPlotSize,
    d.Expression<double>? measPlotSize,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (ecpSummaryId != null) 'ecp_summary_id': ecpSummaryId,
      if (ecpNum != null) 'ecp_num': ecpNum,
      if (complete != null) 'complete': complete,
      if (plotType != null) 'plot_type': plotType,
      if (nomPlotSize != null) 'nom_plot_size': nomPlotSize,
      if (measPlotSize != null) 'meas_plot_size': measPlotSize,
    });
  }

  EcpHeaderCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? ecpSummaryId,
      d.Value<int?>? ecpNum,
      d.Value<bool>? complete,
      d.Value<String?>? plotType,
      d.Value<double?>? nomPlotSize,
      d.Value<double?>? measPlotSize}) {
    return EcpHeaderCompanion(
      id: id ?? this.id,
      ecpSummaryId: ecpSummaryId ?? this.ecpSummaryId,
      ecpNum: ecpNum ?? this.ecpNum,
      complete: complete ?? this.complete,
      plotType: plotType ?? this.plotType,
      nomPlotSize: nomPlotSize ?? this.nomPlotSize,
      measPlotSize: measPlotSize ?? this.measPlotSize,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (ecpSummaryId.present) {
      map['ecp_summary_id'] = d.Variable<int>(ecpSummaryId.value);
    }
    if (ecpNum.present) {
      map['ecp_num'] = d.Variable<int>(ecpNum.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    if (plotType.present) {
      map['plot_type'] = d.Variable<String>(plotType.value);
    }
    if (nomPlotSize.present) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize.value);
    }
    if (measPlotSize.present) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpHeaderCompanion(')
          ..write('id: $id, ')
          ..write('ecpSummaryId: $ecpSummaryId, ')
          ..write('ecpNum: $ecpNum, ')
          ..write('complete: $complete, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize')
          ..write(')'))
        .toString();
  }
}

class $EcpSpeciesTable extends EcpSpecies
    with d.TableInfo<$EcpSpeciesTable, EcpSpeciesData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EcpSpeciesTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _ecpHeaderIdMeta =
      const d.VerificationMeta('ecpHeaderId');
  @override
  late final d.GeneratedColumn<int> ecpHeaderId = d.GeneratedColumn<int>(
      'ecp_header_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ecp_header (id)'));
  static const d.VerificationMeta _speciesNumMeta =
      const d.VerificationMeta('speciesNum');
  @override
  late final d.GeneratedColumn<int> speciesNum = d.GeneratedColumn<int>(
      'species_num', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const d.VerificationMeta _layerIdMeta =
      const d.VerificationMeta('layerId');
  @override
  late final d.GeneratedColumn<String> layerId = d.GeneratedColumn<String>(
      'layer_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _genusMeta =
      const d.VerificationMeta('genus');
  @override
  late final d.GeneratedColumn<String> genus = d.GeneratedColumn<String>(
      'genus', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _speciesMeta =
      const d.VerificationMeta('species');
  @override
  late final d.GeneratedColumn<String> species = d.GeneratedColumn<String>(
      'species', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _varietyMeta =
      const d.VerificationMeta('variety');
  @override
  late final d.GeneratedColumn<String> variety = d.GeneratedColumn<String>(
      'variety', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _speciesPctMeta =
      const d.VerificationMeta('speciesPct');
  @override
  late final d.GeneratedColumn<double> speciesPct = d.GeneratedColumn<double>(
      'species_pct', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const d.VerificationMeta _commentIdMeta =
      const d.VerificationMeta('commentId');
  @override
  late final d.GeneratedColumn<int> commentId = d.GeneratedColumn<int>(
      'comment_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES meta_comment (id)'));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        ecpHeaderId,
        speciesNum,
        layerId,
        genus,
        species,
        variety,
        speciesPct,
        commentId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ecp_species';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<EcpSpeciesData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('ecp_header_id')) {
      context.handle(
          _ecpHeaderIdMeta,
          ecpHeaderId.isAcceptableOrUnknown(
              data['ecp_header_id']!, _ecpHeaderIdMeta));
    } else if (isInserting) {
      context.missing(_ecpHeaderIdMeta);
    }
    if (data.containsKey('species_num')) {
      context.handle(
          _speciesNumMeta,
          speciesNum.isAcceptableOrUnknown(
              data['species_num']!, _speciesNumMeta));
    } else if (isInserting) {
      context.missing(_speciesNumMeta);
    }
    if (data.containsKey('layer_id')) {
      context.handle(_layerIdMeta,
          layerId.isAcceptableOrUnknown(data['layer_id']!, _layerIdMeta));
    } else if (isInserting) {
      context.missing(_layerIdMeta);
    }
    if (data.containsKey('genus')) {
      context.handle(
          _genusMeta, genus.isAcceptableOrUnknown(data['genus']!, _genusMeta));
    } else if (isInserting) {
      context.missing(_genusMeta);
    }
    if (data.containsKey('species')) {
      context.handle(_speciesMeta,
          species.isAcceptableOrUnknown(data['species']!, _speciesMeta));
    } else if (isInserting) {
      context.missing(_speciesMeta);
    }
    if (data.containsKey('variety')) {
      context.handle(_varietyMeta,
          variety.isAcceptableOrUnknown(data['variety']!, _varietyMeta));
    }
    if (data.containsKey('species_pct')) {
      context.handle(
          _speciesPctMeta,
          speciesPct.isAcceptableOrUnknown(
              data['species_pct']!, _speciesPctMeta));
    } else if (isInserting) {
      context.missing(_speciesPctMeta);
    }
    if (data.containsKey('comment_id')) {
      context.handle(_commentIdMeta,
          commentId.isAcceptableOrUnknown(data['comment_id']!, _commentIdMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  EcpSpeciesData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EcpSpeciesData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      ecpHeaderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ecp_header_id'])!,
      speciesNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}species_num'])!,
      layerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}layer_id'])!,
      genus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus'])!,
      species: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species'])!,
      variety: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variety']),
      speciesPct: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}species_pct'])!,
      commentId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}comment_id']),
    );
  }

  @override
  $EcpSpeciesTable createAlias(String alias) {
    return $EcpSpeciesTable(attachedDatabase, alias);
  }
}

class EcpSpeciesData extends d.DataClass
    implements d.Insertable<EcpSpeciesData> {
  final int id;
  final int ecpHeaderId;
  final int speciesNum;
  final String layerId;
  final String genus;
  final String species;
  final String? variety;
  final double speciesPct;
  final int? commentId;
  const EcpSpeciesData(
      {required this.id,
      required this.ecpHeaderId,
      required this.speciesNum,
      required this.layerId,
      required this.genus,
      required this.species,
      this.variety,
      required this.speciesPct,
      this.commentId});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['ecp_header_id'] = d.Variable<int>(ecpHeaderId);
    map['species_num'] = d.Variable<int>(speciesNum);
    map['layer_id'] = d.Variable<String>(layerId);
    map['genus'] = d.Variable<String>(genus);
    map['species'] = d.Variable<String>(species);
    if (!nullToAbsent || variety != null) {
      map['variety'] = d.Variable<String>(variety);
    }
    map['species_pct'] = d.Variable<double>(speciesPct);
    if (!nullToAbsent || commentId != null) {
      map['comment_id'] = d.Variable<int>(commentId);
    }
    return map;
  }

  EcpSpeciesCompanion toCompanion(bool nullToAbsent) {
    return EcpSpeciesCompanion(
      id: d.Value(id),
      ecpHeaderId: d.Value(ecpHeaderId),
      speciesNum: d.Value(speciesNum),
      layerId: d.Value(layerId),
      genus: d.Value(genus),
      species: d.Value(species),
      variety: variety == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(variety),
      speciesPct: d.Value(speciesPct),
      commentId: commentId == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(commentId),
    );
  }

  factory EcpSpeciesData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return EcpSpeciesData(
      id: serializer.fromJson<int>(json['id']),
      ecpHeaderId: serializer.fromJson<int>(json['ecpHeaderId']),
      speciesNum: serializer.fromJson<int>(json['speciesNum']),
      layerId: serializer.fromJson<String>(json['layerId']),
      genus: serializer.fromJson<String>(json['genus']),
      species: serializer.fromJson<String>(json['species']),
      variety: serializer.fromJson<String?>(json['variety']),
      speciesPct: serializer.fromJson<double>(json['speciesPct']),
      commentId: serializer.fromJson<int?>(json['commentId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'ecpHeaderId': serializer.toJson<int>(ecpHeaderId),
      'speciesNum': serializer.toJson<int>(speciesNum),
      'layerId': serializer.toJson<String>(layerId),
      'genus': serializer.toJson<String>(genus),
      'species': serializer.toJson<String>(species),
      'variety': serializer.toJson<String?>(variety),
      'speciesPct': serializer.toJson<double>(speciesPct),
      'commentId': serializer.toJson<int?>(commentId),
    };
  }

  EcpSpeciesData copyWith(
          {int? id,
          int? ecpHeaderId,
          int? speciesNum,
          String? layerId,
          String? genus,
          String? species,
          d.Value<String?> variety = const d.Value.absent(),
          double? speciesPct,
          d.Value<int?> commentId = const d.Value.absent()}) =>
      EcpSpeciesData(
        id: id ?? this.id,
        ecpHeaderId: ecpHeaderId ?? this.ecpHeaderId,
        speciesNum: speciesNum ?? this.speciesNum,
        layerId: layerId ?? this.layerId,
        genus: genus ?? this.genus,
        species: species ?? this.species,
        variety: variety.present ? variety.value : this.variety,
        speciesPct: speciesPct ?? this.speciesPct,
        commentId: commentId.present ? commentId.value : this.commentId,
      );
  @override
  String toString() {
    return (StringBuffer('EcpSpeciesData(')
          ..write('id: $id, ')
          ..write('ecpHeaderId: $ecpHeaderId, ')
          ..write('speciesNum: $speciesNum, ')
          ..write('layerId: $layerId, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety, ')
          ..write('speciesPct: $speciesPct, ')
          ..write('commentId: $commentId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, ecpHeaderId, speciesNum, layerId, genus,
      species, variety, speciesPct, commentId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EcpSpeciesData &&
          other.id == this.id &&
          other.ecpHeaderId == this.ecpHeaderId &&
          other.speciesNum == this.speciesNum &&
          other.layerId == this.layerId &&
          other.genus == this.genus &&
          other.species == this.species &&
          other.variety == this.variety &&
          other.speciesPct == this.speciesPct &&
          other.commentId == this.commentId);
}

class EcpSpeciesCompanion extends d.UpdateCompanion<EcpSpeciesData> {
  final d.Value<int> id;
  final d.Value<int> ecpHeaderId;
  final d.Value<int> speciesNum;
  final d.Value<String> layerId;
  final d.Value<String> genus;
  final d.Value<String> species;
  final d.Value<String?> variety;
  final d.Value<double> speciesPct;
  final d.Value<int?> commentId;
  const EcpSpeciesCompanion({
    this.id = const d.Value.absent(),
    this.ecpHeaderId = const d.Value.absent(),
    this.speciesNum = const d.Value.absent(),
    this.layerId = const d.Value.absent(),
    this.genus = const d.Value.absent(),
    this.species = const d.Value.absent(),
    this.variety = const d.Value.absent(),
    this.speciesPct = const d.Value.absent(),
    this.commentId = const d.Value.absent(),
  });
  EcpSpeciesCompanion.insert({
    this.id = const d.Value.absent(),
    required int ecpHeaderId,
    required int speciesNum,
    required String layerId,
    required String genus,
    required String species,
    this.variety = const d.Value.absent(),
    required double speciesPct,
    this.commentId = const d.Value.absent(),
  })  : ecpHeaderId = d.Value(ecpHeaderId),
        speciesNum = d.Value(speciesNum),
        layerId = d.Value(layerId),
        genus = d.Value(genus),
        species = d.Value(species),
        speciesPct = d.Value(speciesPct);
  static d.Insertable<EcpSpeciesData> custom({
    d.Expression<int>? id,
    d.Expression<int>? ecpHeaderId,
    d.Expression<int>? speciesNum,
    d.Expression<String>? layerId,
    d.Expression<String>? genus,
    d.Expression<String>? species,
    d.Expression<String>? variety,
    d.Expression<double>? speciesPct,
    d.Expression<int>? commentId,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (ecpHeaderId != null) 'ecp_header_id': ecpHeaderId,
      if (speciesNum != null) 'species_num': speciesNum,
      if (layerId != null) 'layer_id': layerId,
      if (genus != null) 'genus': genus,
      if (species != null) 'species': species,
      if (variety != null) 'variety': variety,
      if (speciesPct != null) 'species_pct': speciesPct,
      if (commentId != null) 'comment_id': commentId,
    });
  }

  EcpSpeciesCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? ecpHeaderId,
      d.Value<int>? speciesNum,
      d.Value<String>? layerId,
      d.Value<String>? genus,
      d.Value<String>? species,
      d.Value<String?>? variety,
      d.Value<double>? speciesPct,
      d.Value<int?>? commentId}) {
    return EcpSpeciesCompanion(
      id: id ?? this.id,
      ecpHeaderId: ecpHeaderId ?? this.ecpHeaderId,
      speciesNum: speciesNum ?? this.speciesNum,
      layerId: layerId ?? this.layerId,
      genus: genus ?? this.genus,
      species: species ?? this.species,
      variety: variety ?? this.variety,
      speciesPct: speciesPct ?? this.speciesPct,
      commentId: commentId ?? this.commentId,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (ecpHeaderId.present) {
      map['ecp_header_id'] = d.Variable<int>(ecpHeaderId.value);
    }
    if (speciesNum.present) {
      map['species_num'] = d.Variable<int>(speciesNum.value);
    }
    if (layerId.present) {
      map['layer_id'] = d.Variable<String>(layerId.value);
    }
    if (genus.present) {
      map['genus'] = d.Variable<String>(genus.value);
    }
    if (species.present) {
      map['species'] = d.Variable<String>(species.value);
    }
    if (variety.present) {
      map['variety'] = d.Variable<String>(variety.value);
    }
    if (speciesPct.present) {
      map['species_pct'] = d.Variable<double>(speciesPct.value);
    }
    if (commentId.present) {
      map['comment_id'] = d.Variable<int>(commentId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EcpSpeciesCompanion(')
          ..write('id: $id, ')
          ..write('ecpHeaderId: $ecpHeaderId, ')
          ..write('speciesNum: $speciesNum, ')
          ..write('layerId: $layerId, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety, ')
          ..write('speciesPct: $speciesPct, ')
          ..write('commentId: $commentId')
          ..write(')'))
        .toString();
  }
}

class $SoilPitSummaryTable extends SoilPitSummary
    with d.TableInfo<$SoilPitSummaryTable, SoilPitSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, measDate, notAssessed, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilPitSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SoilPitSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilPitSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $SoilPitSummaryTable createAlias(String alias) {
    return $SoilPitSummaryTable(attachedDatabase, alias);
  }
}

class SoilPitSummaryData extends d.DataClass
    implements d.Insertable<SoilPitSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final bool notAssessed;
  final bool complete;
  const SoilPitSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  SoilPitSummaryCompanion toCompanion(bool nullToAbsent) {
    return SoilPitSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory SoilPitSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilPitSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  SoilPitSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          bool? notAssessed,
          bool? complete}) =>
      SoilPitSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('SoilPitSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, surveyId, measDate, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilPitSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class SoilPitSummaryCompanion extends d.UpdateCompanion<SoilPitSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const SoilPitSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  SoilPitSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<SoilPitSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  SoilPitSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return SoilPitSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $SoilSiteInfoTable extends SoilSiteInfo
    with d.TableInfo<$SoilSiteInfoTable, SoilSiteInfoData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilSiteInfoTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _soilPitSummaryIdMeta =
      const d.VerificationMeta('soilPitSummaryId');
  @override
  late final d.GeneratedColumn<int> soilPitSummaryId = d.GeneratedColumn<int>(
      'soil_pit_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES soil_pit_summary (id)'));
  static const d.VerificationMeta _soilClassOrderMeta =
      const d.VerificationMeta('soilClassOrder');
  @override
  late final d.GeneratedColumn<String> soilClassOrder =
      d.GeneratedColumn<String>('soil_class_order', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _soilClassGreatGroupMeta =
      const d.VerificationMeta('soilClassGreatGroup');
  @override
  late final d.GeneratedColumn<String> soilClassGreatGroup =
      d.GeneratedColumn<String>('soil_class_great_group', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _soilClassSubGroupMeta =
      const d.VerificationMeta('soilClassSubGroup');
  @override
  late final d.GeneratedColumn<String> soilClassSubGroup =
      d.GeneratedColumn<String>('soil_class_sub_group', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _soilClassMeta =
      const d.VerificationMeta('soilClass');
  @override
  late final d.GeneratedColumn<String> soilClass = d.GeneratedColumn<String>(
      'soil_class', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 9),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _profileDepthMeta =
      const d.VerificationMeta('profileDepth');
  @override
  late final d.GeneratedColumn<double> profileDepth = d.GeneratedColumn<double>(
      'profile_depth', aliasedName, false,
      check: () => profileDepth.isBetweenValues(-1, 250),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _drainageMeta =
      const d.VerificationMeta('drainage');
  @override
  late final d.GeneratedColumn<int> drainage = d.GeneratedColumn<int>(
      'drainage', aliasedName, false,
      check: () => drainage.isBetweenValues(-9, 7),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _moistureMeta =
      const d.VerificationMeta('moisture');
  @override
  late final d.GeneratedColumn<int> moisture = d.GeneratedColumn<int>(
      'moisture', aliasedName, false,
      check: () => moisture.isBetweenValues(-9, 3),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _depositionMeta =
      const d.VerificationMeta('deposition');
  @override
  late final d.GeneratedColumn<String> deposition = d.GeneratedColumn<String>(
      'deposition', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _humusFormMeta =
      const d.VerificationMeta('humusForm');
  @override
  late final d.GeneratedColumn<String> humusForm = d.GeneratedColumn<String>(
      'humus_form', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        soilPitSummaryId,
        soilClassOrder,
        soilClassGreatGroup,
        soilClassSubGroup,
        soilClass,
        profileDepth,
        drainage,
        moisture,
        deposition,
        humusForm
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_site_info';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilSiteInfoData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('soil_pit_summary_id')) {
      context.handle(
          _soilPitSummaryIdMeta,
          soilPitSummaryId.isAcceptableOrUnknown(
              data['soil_pit_summary_id']!, _soilPitSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_soilPitSummaryIdMeta);
    }
    if (data.containsKey('soil_class_order')) {
      context.handle(
          _soilClassOrderMeta,
          soilClassOrder.isAcceptableOrUnknown(
              data['soil_class_order']!, _soilClassOrderMeta));
    } else if (isInserting) {
      context.missing(_soilClassOrderMeta);
    }
    if (data.containsKey('soil_class_great_group')) {
      context.handle(
          _soilClassGreatGroupMeta,
          soilClassGreatGroup.isAcceptableOrUnknown(
              data['soil_class_great_group']!, _soilClassGreatGroupMeta));
    } else if (isInserting) {
      context.missing(_soilClassGreatGroupMeta);
    }
    if (data.containsKey('soil_class_sub_group')) {
      context.handle(
          _soilClassSubGroupMeta,
          soilClassSubGroup.isAcceptableOrUnknown(
              data['soil_class_sub_group']!, _soilClassSubGroupMeta));
    } else if (isInserting) {
      context.missing(_soilClassSubGroupMeta);
    }
    if (data.containsKey('soil_class')) {
      context.handle(_soilClassMeta,
          soilClass.isAcceptableOrUnknown(data['soil_class']!, _soilClassMeta));
    } else if (isInserting) {
      context.missing(_soilClassMeta);
    }
    if (data.containsKey('profile_depth')) {
      context.handle(
          _profileDepthMeta,
          profileDepth.isAcceptableOrUnknown(
              data['profile_depth']!, _profileDepthMeta));
    } else if (isInserting) {
      context.missing(_profileDepthMeta);
    }
    if (data.containsKey('drainage')) {
      context.handle(_drainageMeta,
          drainage.isAcceptableOrUnknown(data['drainage']!, _drainageMeta));
    } else if (isInserting) {
      context.missing(_drainageMeta);
    }
    if (data.containsKey('moisture')) {
      context.handle(_moistureMeta,
          moisture.isAcceptableOrUnknown(data['moisture']!, _moistureMeta));
    } else if (isInserting) {
      context.missing(_moistureMeta);
    }
    if (data.containsKey('deposition')) {
      context.handle(
          _depositionMeta,
          deposition.isAcceptableOrUnknown(
              data['deposition']!, _depositionMeta));
    } else if (isInserting) {
      context.missing(_depositionMeta);
    }
    if (data.containsKey('humus_form')) {
      context.handle(_humusFormMeta,
          humusForm.isAcceptableOrUnknown(data['humus_form']!, _humusFormMeta));
    } else if (isInserting) {
      context.missing(_humusFormMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SoilSiteInfoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilSiteInfoData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      soilPitSummaryId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}soil_pit_summary_id'])!,
      soilClassOrder: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}soil_class_order'])!,
      soilClassGreatGroup: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}soil_class_great_group'])!,
      soilClassSubGroup: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}soil_class_sub_group'])!,
      soilClass: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}soil_class'])!,
      profileDepth: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}profile_depth'])!,
      drainage: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}drainage'])!,
      moisture: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}moisture'])!,
      deposition: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deposition'])!,
      humusForm: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}humus_form'])!,
    );
  }

  @override
  $SoilSiteInfoTable createAlias(String alias) {
    return $SoilSiteInfoTable(attachedDatabase, alias);
  }
}

class SoilSiteInfoData extends d.DataClass
    implements d.Insertable<SoilSiteInfoData> {
  final int id;
  final int soilPitSummaryId;
  final String soilClassOrder;
  final String soilClassGreatGroup;
  final String soilClassSubGroup;
  final String soilClass;
  final double profileDepth;
  final int drainage;
  final int moisture;
  final String deposition;
  final String humusForm;
  const SoilSiteInfoData(
      {required this.id,
      required this.soilPitSummaryId,
      required this.soilClassOrder,
      required this.soilClassGreatGroup,
      required this.soilClassSubGroup,
      required this.soilClass,
      required this.profileDepth,
      required this.drainage,
      required this.moisture,
      required this.deposition,
      required this.humusForm});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId);
    map['soil_class_order'] = d.Variable<String>(soilClassOrder);
    map['soil_class_great_group'] = d.Variable<String>(soilClassGreatGroup);
    map['soil_class_sub_group'] = d.Variable<String>(soilClassSubGroup);
    map['soil_class'] = d.Variable<String>(soilClass);
    map['profile_depth'] = d.Variable<double>(profileDepth);
    map['drainage'] = d.Variable<int>(drainage);
    map['moisture'] = d.Variable<int>(moisture);
    map['deposition'] = d.Variable<String>(deposition);
    map['humus_form'] = d.Variable<String>(humusForm);
    return map;
  }

  SoilSiteInfoCompanion toCompanion(bool nullToAbsent) {
    return SoilSiteInfoCompanion(
      id: d.Value(id),
      soilPitSummaryId: d.Value(soilPitSummaryId),
      soilClassOrder: d.Value(soilClassOrder),
      soilClassGreatGroup: d.Value(soilClassGreatGroup),
      soilClassSubGroup: d.Value(soilClassSubGroup),
      soilClass: d.Value(soilClass),
      profileDepth: d.Value(profileDepth),
      drainage: d.Value(drainage),
      moisture: d.Value(moisture),
      deposition: d.Value(deposition),
      humusForm: d.Value(humusForm),
    );
  }

  factory SoilSiteInfoData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilSiteInfoData(
      id: serializer.fromJson<int>(json['id']),
      soilPitSummaryId: serializer.fromJson<int>(json['soilPitSummaryId']),
      soilClassOrder: serializer.fromJson<String>(json['soilClassOrder']),
      soilClassGreatGroup:
          serializer.fromJson<String>(json['soilClassGreatGroup']),
      soilClassSubGroup: serializer.fromJson<String>(json['soilClassSubGroup']),
      soilClass: serializer.fromJson<String>(json['soilClass']),
      profileDepth: serializer.fromJson<double>(json['profileDepth']),
      drainage: serializer.fromJson<int>(json['drainage']),
      moisture: serializer.fromJson<int>(json['moisture']),
      deposition: serializer.fromJson<String>(json['deposition']),
      humusForm: serializer.fromJson<String>(json['humusForm']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'soilPitSummaryId': serializer.toJson<int>(soilPitSummaryId),
      'soilClassOrder': serializer.toJson<String>(soilClassOrder),
      'soilClassGreatGroup': serializer.toJson<String>(soilClassGreatGroup),
      'soilClassSubGroup': serializer.toJson<String>(soilClassSubGroup),
      'soilClass': serializer.toJson<String>(soilClass),
      'profileDepth': serializer.toJson<double>(profileDepth),
      'drainage': serializer.toJson<int>(drainage),
      'moisture': serializer.toJson<int>(moisture),
      'deposition': serializer.toJson<String>(deposition),
      'humusForm': serializer.toJson<String>(humusForm),
    };
  }

  SoilSiteInfoData copyWith(
          {int? id,
          int? soilPitSummaryId,
          String? soilClassOrder,
          String? soilClassGreatGroup,
          String? soilClassSubGroup,
          String? soilClass,
          double? profileDepth,
          int? drainage,
          int? moisture,
          String? deposition,
          String? humusForm}) =>
      SoilSiteInfoData(
        id: id ?? this.id,
        soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
        soilClassOrder: soilClassOrder ?? this.soilClassOrder,
        soilClassGreatGroup: soilClassGreatGroup ?? this.soilClassGreatGroup,
        soilClassSubGroup: soilClassSubGroup ?? this.soilClassSubGroup,
        soilClass: soilClass ?? this.soilClass,
        profileDepth: profileDepth ?? this.profileDepth,
        drainage: drainage ?? this.drainage,
        moisture: moisture ?? this.moisture,
        deposition: deposition ?? this.deposition,
        humusForm: humusForm ?? this.humusForm,
      );
  @override
  String toString() {
    return (StringBuffer('SoilSiteInfoData(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilClassOrder: $soilClassOrder, ')
          ..write('soilClassGreatGroup: $soilClassGreatGroup, ')
          ..write('soilClassSubGroup: $soilClassSubGroup, ')
          ..write('soilClass: $soilClass, ')
          ..write('profileDepth: $profileDepth, ')
          ..write('drainage: $drainage, ')
          ..write('moisture: $moisture, ')
          ..write('deposition: $deposition, ')
          ..write('humusForm: $humusForm')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      soilPitSummaryId,
      soilClassOrder,
      soilClassGreatGroup,
      soilClassSubGroup,
      soilClass,
      profileDepth,
      drainage,
      moisture,
      deposition,
      humusForm);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilSiteInfoData &&
          other.id == this.id &&
          other.soilPitSummaryId == this.soilPitSummaryId &&
          other.soilClassOrder == this.soilClassOrder &&
          other.soilClassGreatGroup == this.soilClassGreatGroup &&
          other.soilClassSubGroup == this.soilClassSubGroup &&
          other.soilClass == this.soilClass &&
          other.profileDepth == this.profileDepth &&
          other.drainage == this.drainage &&
          other.moisture == this.moisture &&
          other.deposition == this.deposition &&
          other.humusForm == this.humusForm);
}

class SoilSiteInfoCompanion extends d.UpdateCompanion<SoilSiteInfoData> {
  final d.Value<int> id;
  final d.Value<int> soilPitSummaryId;
  final d.Value<String> soilClassOrder;
  final d.Value<String> soilClassGreatGroup;
  final d.Value<String> soilClassSubGroup;
  final d.Value<String> soilClass;
  final d.Value<double> profileDepth;
  final d.Value<int> drainage;
  final d.Value<int> moisture;
  final d.Value<String> deposition;
  final d.Value<String> humusForm;
  const SoilSiteInfoCompanion({
    this.id = const d.Value.absent(),
    this.soilPitSummaryId = const d.Value.absent(),
    this.soilClassOrder = const d.Value.absent(),
    this.soilClassGreatGroup = const d.Value.absent(),
    this.soilClassSubGroup = const d.Value.absent(),
    this.soilClass = const d.Value.absent(),
    this.profileDepth = const d.Value.absent(),
    this.drainage = const d.Value.absent(),
    this.moisture = const d.Value.absent(),
    this.deposition = const d.Value.absent(),
    this.humusForm = const d.Value.absent(),
  });
  SoilSiteInfoCompanion.insert({
    this.id = const d.Value.absent(),
    required int soilPitSummaryId,
    required String soilClassOrder,
    required String soilClassGreatGroup,
    required String soilClassSubGroup,
    required String soilClass,
    required double profileDepth,
    required int drainage,
    required int moisture,
    required String deposition,
    required String humusForm,
  })  : soilPitSummaryId = d.Value(soilPitSummaryId),
        soilClassOrder = d.Value(soilClassOrder),
        soilClassGreatGroup = d.Value(soilClassGreatGroup),
        soilClassSubGroup = d.Value(soilClassSubGroup),
        soilClass = d.Value(soilClass),
        profileDepth = d.Value(profileDepth),
        drainage = d.Value(drainage),
        moisture = d.Value(moisture),
        deposition = d.Value(deposition),
        humusForm = d.Value(humusForm);
  static d.Insertable<SoilSiteInfoData> custom({
    d.Expression<int>? id,
    d.Expression<int>? soilPitSummaryId,
    d.Expression<String>? soilClassOrder,
    d.Expression<String>? soilClassGreatGroup,
    d.Expression<String>? soilClassSubGroup,
    d.Expression<String>? soilClass,
    d.Expression<double>? profileDepth,
    d.Expression<int>? drainage,
    d.Expression<int>? moisture,
    d.Expression<String>? deposition,
    d.Expression<String>? humusForm,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (soilPitSummaryId != null) 'soil_pit_summary_id': soilPitSummaryId,
      if (soilClassOrder != null) 'soil_class_order': soilClassOrder,
      if (soilClassGreatGroup != null)
        'soil_class_great_group': soilClassGreatGroup,
      if (soilClassSubGroup != null) 'soil_class_sub_group': soilClassSubGroup,
      if (soilClass != null) 'soil_class': soilClass,
      if (profileDepth != null) 'profile_depth': profileDepth,
      if (drainage != null) 'drainage': drainage,
      if (moisture != null) 'moisture': moisture,
      if (deposition != null) 'deposition': deposition,
      if (humusForm != null) 'humus_form': humusForm,
    });
  }

  SoilSiteInfoCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? soilPitSummaryId,
      d.Value<String>? soilClassOrder,
      d.Value<String>? soilClassGreatGroup,
      d.Value<String>? soilClassSubGroup,
      d.Value<String>? soilClass,
      d.Value<double>? profileDepth,
      d.Value<int>? drainage,
      d.Value<int>? moisture,
      d.Value<String>? deposition,
      d.Value<String>? humusForm}) {
    return SoilSiteInfoCompanion(
      id: id ?? this.id,
      soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
      soilClassOrder: soilClassOrder ?? this.soilClassOrder,
      soilClassGreatGroup: soilClassGreatGroup ?? this.soilClassGreatGroup,
      soilClassSubGroup: soilClassSubGroup ?? this.soilClassSubGroup,
      soilClass: soilClass ?? this.soilClass,
      profileDepth: profileDepth ?? this.profileDepth,
      drainage: drainage ?? this.drainage,
      moisture: moisture ?? this.moisture,
      deposition: deposition ?? this.deposition,
      humusForm: humusForm ?? this.humusForm,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (soilPitSummaryId.present) {
      map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId.value);
    }
    if (soilClassOrder.present) {
      map['soil_class_order'] = d.Variable<String>(soilClassOrder.value);
    }
    if (soilClassGreatGroup.present) {
      map['soil_class_great_group'] =
          d.Variable<String>(soilClassGreatGroup.value);
    }
    if (soilClassSubGroup.present) {
      map['soil_class_sub_group'] = d.Variable<String>(soilClassSubGroup.value);
    }
    if (soilClass.present) {
      map['soil_class'] = d.Variable<String>(soilClass.value);
    }
    if (profileDepth.present) {
      map['profile_depth'] = d.Variable<double>(profileDepth.value);
    }
    if (drainage.present) {
      map['drainage'] = d.Variable<int>(drainage.value);
    }
    if (moisture.present) {
      map['moisture'] = d.Variable<int>(moisture.value);
    }
    if (deposition.present) {
      map['deposition'] = d.Variable<String>(deposition.value);
    }
    if (humusForm.present) {
      map['humus_form'] = d.Variable<String>(humusForm.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilSiteInfoCompanion(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilClassOrder: $soilClassOrder, ')
          ..write('soilClassGreatGroup: $soilClassGreatGroup, ')
          ..write('soilClassSubGroup: $soilClassSubGroup, ')
          ..write('soilClass: $soilClass, ')
          ..write('profileDepth: $profileDepth, ')
          ..write('drainage: $drainage, ')
          ..write('moisture: $moisture, ')
          ..write('deposition: $deposition, ')
          ..write('humusForm: $humusForm')
          ..write(')'))
        .toString();
  }
}

class $SoilPitFeatureTable extends SoilPitFeature
    with d.TableInfo<$SoilPitFeatureTable, SoilPitFeatureData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitFeatureTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _soilPitSummaryIdMeta =
      const d.VerificationMeta('soilPitSummaryId');
  @override
  late final d.GeneratedColumn<int> soilPitSummaryId = d.GeneratedColumn<int>(
      'soil_pit_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES soil_pit_summary (id)'));
  static const d.VerificationMeta _soilPitCodeMeta =
      const d.VerificationMeta('soilPitCode');
  @override
  late final d.GeneratedColumn<String> soilPitCode = d.GeneratedColumn<String>(
      'soil_pit_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _soilFeatureMeta =
      const d.VerificationMeta('soilFeature');
  @override
  late final d.GeneratedColumn<String> soilFeature = d.GeneratedColumn<String>(
      'soil_feature', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _depthFeatureMeta =
      const d.VerificationMeta('depthFeature');
  @override
  late final d.GeneratedColumn<int> depthFeature = d.GeneratedColumn<int>(
      'depth_feature', aliasedName, false,
      check: () => depthFeature.isBetweenValues(-9, 200),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, soilPitSummaryId, soilPitCode, soilFeature, depthFeature];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_feature';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilPitFeatureData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('soil_pit_summary_id')) {
      context.handle(
          _soilPitSummaryIdMeta,
          soilPitSummaryId.isAcceptableOrUnknown(
              data['soil_pit_summary_id']!, _soilPitSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_soilPitSummaryIdMeta);
    }
    if (data.containsKey('soil_pit_code')) {
      context.handle(
          _soilPitCodeMeta,
          soilPitCode.isAcceptableOrUnknown(
              data['soil_pit_code']!, _soilPitCodeMeta));
    } else if (isInserting) {
      context.missing(_soilPitCodeMeta);
    }
    if (data.containsKey('soil_feature')) {
      context.handle(
          _soilFeatureMeta,
          soilFeature.isAcceptableOrUnknown(
              data['soil_feature']!, _soilFeatureMeta));
    } else if (isInserting) {
      context.missing(_soilFeatureMeta);
    }
    if (data.containsKey('depth_feature')) {
      context.handle(
          _depthFeatureMeta,
          depthFeature.isAcceptableOrUnknown(
              data['depth_feature']!, _depthFeatureMeta));
    } else if (isInserting) {
      context.missing(_depthFeatureMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SoilPitFeatureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilPitFeatureData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      soilPitSummaryId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}soil_pit_summary_id'])!,
      soilPitCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}soil_pit_code'])!,
      soilFeature: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}soil_feature'])!,
      depthFeature: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}depth_feature'])!,
    );
  }

  @override
  $SoilPitFeatureTable createAlias(String alias) {
    return $SoilPitFeatureTable(attachedDatabase, alias);
  }
}

class SoilPitFeatureData extends d.DataClass
    implements d.Insertable<SoilPitFeatureData> {
  final int id;
  final int soilPitSummaryId;
  final String soilPitCode;
  final String soilFeature;
  final int depthFeature;
  const SoilPitFeatureData(
      {required this.id,
      required this.soilPitSummaryId,
      required this.soilPitCode,
      required this.soilFeature,
      required this.depthFeature});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId);
    map['soil_pit_code'] = d.Variable<String>(soilPitCode);
    map['soil_feature'] = d.Variable<String>(soilFeature);
    map['depth_feature'] = d.Variable<int>(depthFeature);
    return map;
  }

  SoilPitFeatureCompanion toCompanion(bool nullToAbsent) {
    return SoilPitFeatureCompanion(
      id: d.Value(id),
      soilPitSummaryId: d.Value(soilPitSummaryId),
      soilPitCode: d.Value(soilPitCode),
      soilFeature: d.Value(soilFeature),
      depthFeature: d.Value(depthFeature),
    );
  }

  factory SoilPitFeatureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilPitFeatureData(
      id: serializer.fromJson<int>(json['id']),
      soilPitSummaryId: serializer.fromJson<int>(json['soilPitSummaryId']),
      soilPitCode: serializer.fromJson<String>(json['soilPitCode']),
      soilFeature: serializer.fromJson<String>(json['soilFeature']),
      depthFeature: serializer.fromJson<int>(json['depthFeature']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'soilPitSummaryId': serializer.toJson<int>(soilPitSummaryId),
      'soilPitCode': serializer.toJson<String>(soilPitCode),
      'soilFeature': serializer.toJson<String>(soilFeature),
      'depthFeature': serializer.toJson<int>(depthFeature),
    };
  }

  SoilPitFeatureData copyWith(
          {int? id,
          int? soilPitSummaryId,
          String? soilPitCode,
          String? soilFeature,
          int? depthFeature}) =>
      SoilPitFeatureData(
        id: id ?? this.id,
        soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
        soilPitCode: soilPitCode ?? this.soilPitCode,
        soilFeature: soilFeature ?? this.soilFeature,
        depthFeature: depthFeature ?? this.depthFeature,
      );
  @override
  String toString() {
    return (StringBuffer('SoilPitFeatureData(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilPitCode: $soilPitCode, ')
          ..write('soilFeature: $soilFeature, ')
          ..write('depthFeature: $depthFeature')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, soilPitSummaryId, soilPitCode, soilFeature, depthFeature);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilPitFeatureData &&
          other.id == this.id &&
          other.soilPitSummaryId == this.soilPitSummaryId &&
          other.soilPitCode == this.soilPitCode &&
          other.soilFeature == this.soilFeature &&
          other.depthFeature == this.depthFeature);
}

class SoilPitFeatureCompanion extends d.UpdateCompanion<SoilPitFeatureData> {
  final d.Value<int> id;
  final d.Value<int> soilPitSummaryId;
  final d.Value<String> soilPitCode;
  final d.Value<String> soilFeature;
  final d.Value<int> depthFeature;
  const SoilPitFeatureCompanion({
    this.id = const d.Value.absent(),
    this.soilPitSummaryId = const d.Value.absent(),
    this.soilPitCode = const d.Value.absent(),
    this.soilFeature = const d.Value.absent(),
    this.depthFeature = const d.Value.absent(),
  });
  SoilPitFeatureCompanion.insert({
    this.id = const d.Value.absent(),
    required int soilPitSummaryId,
    required String soilPitCode,
    required String soilFeature,
    required int depthFeature,
  })  : soilPitSummaryId = d.Value(soilPitSummaryId),
        soilPitCode = d.Value(soilPitCode),
        soilFeature = d.Value(soilFeature),
        depthFeature = d.Value(depthFeature);
  static d.Insertable<SoilPitFeatureData> custom({
    d.Expression<int>? id,
    d.Expression<int>? soilPitSummaryId,
    d.Expression<String>? soilPitCode,
    d.Expression<String>? soilFeature,
    d.Expression<int>? depthFeature,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (soilPitSummaryId != null) 'soil_pit_summary_id': soilPitSummaryId,
      if (soilPitCode != null) 'soil_pit_code': soilPitCode,
      if (soilFeature != null) 'soil_feature': soilFeature,
      if (depthFeature != null) 'depth_feature': depthFeature,
    });
  }

  SoilPitFeatureCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? soilPitSummaryId,
      d.Value<String>? soilPitCode,
      d.Value<String>? soilFeature,
      d.Value<int>? depthFeature}) {
    return SoilPitFeatureCompanion(
      id: id ?? this.id,
      soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
      soilPitCode: soilPitCode ?? this.soilPitCode,
      soilFeature: soilFeature ?? this.soilFeature,
      depthFeature: depthFeature ?? this.depthFeature,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (soilPitSummaryId.present) {
      map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId.value);
    }
    if (soilPitCode.present) {
      map['soil_pit_code'] = d.Variable<String>(soilPitCode.value);
    }
    if (soilFeature.present) {
      map['soil_feature'] = d.Variable<String>(soilFeature.value);
    }
    if (depthFeature.present) {
      map['depth_feature'] = d.Variable<int>(depthFeature.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitFeatureCompanion(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilPitCode: $soilPitCode, ')
          ..write('soilFeature: $soilFeature, ')
          ..write('depthFeature: $depthFeature')
          ..write(')'))
        .toString();
  }
}

class $SoilPitHorizonDescriptionTable extends SoilPitHorizonDescription
    with
        d.TableInfo<$SoilPitHorizonDescriptionTable,
            SoilPitHorizonDescriptionData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SoilPitHorizonDescriptionTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _soilPitSummaryIdMeta =
      const d.VerificationMeta('soilPitSummaryId');
  @override
  late final d.GeneratedColumn<int> soilPitSummaryId = d.GeneratedColumn<int>(
      'soil_pit_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES soil_pit_summary (id)'));
  static const d.VerificationMeta _soilPitCodeFieldMeta =
      const d.VerificationMeta('soilPitCodeField');
  @override
  late final d.GeneratedColumn<String> soilPitCodeField =
      d.GeneratedColumn<String>('soil_pit_code_field', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _horizonNumMeta =
      const d.VerificationMeta('horizonNum');
  @override
  late final d.GeneratedColumn<int> horizonNum = d.GeneratedColumn<int>(
      'horizon_num', aliasedName, false,
      check: () => horizonNum.isBetweenValues(1, 99),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _horizonMeta =
      const d.VerificationMeta('horizon');
  @override
  late final d.GeneratedColumn<String> horizon = d.GeneratedColumn<String>(
      'horizon', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 6),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _horizonUpperMeta =
      const d.VerificationMeta('horizonUpper');
  @override
  late final d.GeneratedColumn<double> horizonUpper = d.GeneratedColumn<double>(
      'horizon_upper', aliasedName, false,
      check: () => horizonUpper.isBetweenValues(-1, 200.0),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _thicknessMeta =
      const d.VerificationMeta('thickness');
  @override
  late final d.GeneratedColumn<double> thickness = d.GeneratedColumn<double>(
      'thickness', aliasedName, false,
      check: () => thickness.isBetweenValues(-1, 300.0),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _colorMeta =
      const d.VerificationMeta('color');
  @override
  late final d.GeneratedColumn<String> color = d.GeneratedColumn<String>(
      'color', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _mineralTypeMeta =
      const d.VerificationMeta('mineralType');
  @override
  late final d.GeneratedColumn<String> mineralType = d.GeneratedColumn<String>(
      'mineral_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _textureMeta =
      const d.VerificationMeta('texture');
  @override
  late final d.GeneratedColumn<String> texture = d.GeneratedColumn<String>(
      'texture', aliasedName, false,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 5),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _cfGravMeta =
      const d.VerificationMeta('cfGrav');
  @override
  late final d.GeneratedColumn<int> cfGrav = d.GeneratedColumn<int>(
      'cf_grav', aliasedName, false,
      check: () => cfGrav.isBetweenValues(-9, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _cfCobbMeta =
      const d.VerificationMeta('cfCobb');
  @override
  late final d.GeneratedColumn<int> cfCobb = d.GeneratedColumn<int>(
      'cf_cobb', aliasedName, false,
      check: () => cfCobb.isBetweenValues(-9, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _cfStoneMeta =
      const d.VerificationMeta('cfStone');
  @override
  late final d.GeneratedColumn<int> cfStone = d.GeneratedColumn<int>(
      'cf_stone', aliasedName, false,
      check: () => cfStone.isBetweenValues(-9, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        soilPitSummaryId,
        soilPitCodeField,
        horizonNum,
        horizon,
        horizonUpper,
        thickness,
        color,
        mineralType,
        texture,
        cfGrav,
        cfCobb,
        cfStone
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'soil_pit_horizon_description';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<SoilPitHorizonDescriptionData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('soil_pit_summary_id')) {
      context.handle(
          _soilPitSummaryIdMeta,
          soilPitSummaryId.isAcceptableOrUnknown(
              data['soil_pit_summary_id']!, _soilPitSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_soilPitSummaryIdMeta);
    }
    if (data.containsKey('soil_pit_code_field')) {
      context.handle(
          _soilPitCodeFieldMeta,
          soilPitCodeField.isAcceptableOrUnknown(
              data['soil_pit_code_field']!, _soilPitCodeFieldMeta));
    } else if (isInserting) {
      context.missing(_soilPitCodeFieldMeta);
    }
    if (data.containsKey('horizon_num')) {
      context.handle(
          _horizonNumMeta,
          horizonNum.isAcceptableOrUnknown(
              data['horizon_num']!, _horizonNumMeta));
    } else if (isInserting) {
      context.missing(_horizonNumMeta);
    }
    if (data.containsKey('horizon')) {
      context.handle(_horizonMeta,
          horizon.isAcceptableOrUnknown(data['horizon']!, _horizonMeta));
    } else if (isInserting) {
      context.missing(_horizonMeta);
    }
    if (data.containsKey('horizon_upper')) {
      context.handle(
          _horizonUpperMeta,
          horizonUpper.isAcceptableOrUnknown(
              data['horizon_upper']!, _horizonUpperMeta));
    } else if (isInserting) {
      context.missing(_horizonUpperMeta);
    }
    if (data.containsKey('thickness')) {
      context.handle(_thicknessMeta,
          thickness.isAcceptableOrUnknown(data['thickness']!, _thicknessMeta));
    } else if (isInserting) {
      context.missing(_thicknessMeta);
    }
    if (data.containsKey('color')) {
      context.handle(
          _colorMeta, color.isAcceptableOrUnknown(data['color']!, _colorMeta));
    } else if (isInserting) {
      context.missing(_colorMeta);
    }
    if (data.containsKey('mineral_type')) {
      context.handle(
          _mineralTypeMeta,
          mineralType.isAcceptableOrUnknown(
              data['mineral_type']!, _mineralTypeMeta));
    } else if (isInserting) {
      context.missing(_mineralTypeMeta);
    }
    if (data.containsKey('texture')) {
      context.handle(_textureMeta,
          texture.isAcceptableOrUnknown(data['texture']!, _textureMeta));
    } else if (isInserting) {
      context.missing(_textureMeta);
    }
    if (data.containsKey('cf_grav')) {
      context.handle(_cfGravMeta,
          cfGrav.isAcceptableOrUnknown(data['cf_grav']!, _cfGravMeta));
    } else if (isInserting) {
      context.missing(_cfGravMeta);
    }
    if (data.containsKey('cf_cobb')) {
      context.handle(_cfCobbMeta,
          cfCobb.isAcceptableOrUnknown(data['cf_cobb']!, _cfCobbMeta));
    } else if (isInserting) {
      context.missing(_cfCobbMeta);
    }
    if (data.containsKey('cf_stone')) {
      context.handle(_cfStoneMeta,
          cfStone.isAcceptableOrUnknown(data['cf_stone']!, _cfStoneMeta));
    } else if (isInserting) {
      context.missing(_cfStoneMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  SoilPitHorizonDescriptionData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SoilPitHorizonDescriptionData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      soilPitSummaryId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}soil_pit_summary_id'])!,
      soilPitCodeField: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}soil_pit_code_field'])!,
      horizonNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}horizon_num'])!,
      horizon: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}horizon'])!,
      horizonUpper: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}horizon_upper'])!,
      thickness: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}thickness'])!,
      color: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}color'])!,
      mineralType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mineral_type'])!,
      texture: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}texture'])!,
      cfGrav: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}cf_grav'])!,
      cfCobb: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}cf_cobb'])!,
      cfStone: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}cf_stone'])!,
    );
  }

  @override
  $SoilPitHorizonDescriptionTable createAlias(String alias) {
    return $SoilPitHorizonDescriptionTable(attachedDatabase, alias);
  }
}

class SoilPitHorizonDescriptionData extends d.DataClass
    implements d.Insertable<SoilPitHorizonDescriptionData> {
  final int id;
  final int soilPitSummaryId;
  final String soilPitCodeField;
  final int horizonNum;
  final String horizon;
  final double horizonUpper;
  final double thickness;
  final String color;
  final String mineralType;
  final String texture;
  final int cfGrav;
  final int cfCobb;
  final int cfStone;
  const SoilPitHorizonDescriptionData(
      {required this.id,
      required this.soilPitSummaryId,
      required this.soilPitCodeField,
      required this.horizonNum,
      required this.horizon,
      required this.horizonUpper,
      required this.thickness,
      required this.color,
      required this.mineralType,
      required this.texture,
      required this.cfGrav,
      required this.cfCobb,
      required this.cfStone});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId);
    map['soil_pit_code_field'] = d.Variable<String>(soilPitCodeField);
    map['horizon_num'] = d.Variable<int>(horizonNum);
    map['horizon'] = d.Variable<String>(horizon);
    map['horizon_upper'] = d.Variable<double>(horizonUpper);
    map['thickness'] = d.Variable<double>(thickness);
    map['color'] = d.Variable<String>(color);
    map['mineral_type'] = d.Variable<String>(mineralType);
    map['texture'] = d.Variable<String>(texture);
    map['cf_grav'] = d.Variable<int>(cfGrav);
    map['cf_cobb'] = d.Variable<int>(cfCobb);
    map['cf_stone'] = d.Variable<int>(cfStone);
    return map;
  }

  SoilPitHorizonDescriptionCompanion toCompanion(bool nullToAbsent) {
    return SoilPitHorizonDescriptionCompanion(
      id: d.Value(id),
      soilPitSummaryId: d.Value(soilPitSummaryId),
      soilPitCodeField: d.Value(soilPitCodeField),
      horizonNum: d.Value(horizonNum),
      horizon: d.Value(horizon),
      horizonUpper: d.Value(horizonUpper),
      thickness: d.Value(thickness),
      color: d.Value(color),
      mineralType: d.Value(mineralType),
      texture: d.Value(texture),
      cfGrav: d.Value(cfGrav),
      cfCobb: d.Value(cfCobb),
      cfStone: d.Value(cfStone),
    );
  }

  factory SoilPitHorizonDescriptionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return SoilPitHorizonDescriptionData(
      id: serializer.fromJson<int>(json['id']),
      soilPitSummaryId: serializer.fromJson<int>(json['soilPitSummaryId']),
      soilPitCodeField: serializer.fromJson<String>(json['soilPitCodeField']),
      horizonNum: serializer.fromJson<int>(json['horizonNum']),
      horizon: serializer.fromJson<String>(json['horizon']),
      horizonUpper: serializer.fromJson<double>(json['horizonUpper']),
      thickness: serializer.fromJson<double>(json['thickness']),
      color: serializer.fromJson<String>(json['color']),
      mineralType: serializer.fromJson<String>(json['mineralType']),
      texture: serializer.fromJson<String>(json['texture']),
      cfGrav: serializer.fromJson<int>(json['cfGrav']),
      cfCobb: serializer.fromJson<int>(json['cfCobb']),
      cfStone: serializer.fromJson<int>(json['cfStone']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'soilPitSummaryId': serializer.toJson<int>(soilPitSummaryId),
      'soilPitCodeField': serializer.toJson<String>(soilPitCodeField),
      'horizonNum': serializer.toJson<int>(horizonNum),
      'horizon': serializer.toJson<String>(horizon),
      'horizonUpper': serializer.toJson<double>(horizonUpper),
      'thickness': serializer.toJson<double>(thickness),
      'color': serializer.toJson<String>(color),
      'mineralType': serializer.toJson<String>(mineralType),
      'texture': serializer.toJson<String>(texture),
      'cfGrav': serializer.toJson<int>(cfGrav),
      'cfCobb': serializer.toJson<int>(cfCobb),
      'cfStone': serializer.toJson<int>(cfStone),
    };
  }

  SoilPitHorizonDescriptionData copyWith(
          {int? id,
          int? soilPitSummaryId,
          String? soilPitCodeField,
          int? horizonNum,
          String? horizon,
          double? horizonUpper,
          double? thickness,
          String? color,
          String? mineralType,
          String? texture,
          int? cfGrav,
          int? cfCobb,
          int? cfStone}) =>
      SoilPitHorizonDescriptionData(
        id: id ?? this.id,
        soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
        soilPitCodeField: soilPitCodeField ?? this.soilPitCodeField,
        horizonNum: horizonNum ?? this.horizonNum,
        horizon: horizon ?? this.horizon,
        horizonUpper: horizonUpper ?? this.horizonUpper,
        thickness: thickness ?? this.thickness,
        color: color ?? this.color,
        mineralType: mineralType ?? this.mineralType,
        texture: texture ?? this.texture,
        cfGrav: cfGrav ?? this.cfGrav,
        cfCobb: cfCobb ?? this.cfCobb,
        cfStone: cfStone ?? this.cfStone,
      );
  @override
  String toString() {
    return (StringBuffer('SoilPitHorizonDescriptionData(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilPitCodeField: $soilPitCodeField, ')
          ..write('horizonNum: $horizonNum, ')
          ..write('horizon: $horizon, ')
          ..write('horizonUpper: $horizonUpper, ')
          ..write('thickness: $thickness, ')
          ..write('color: $color, ')
          ..write('mineralType: $mineralType, ')
          ..write('texture: $texture, ')
          ..write('cfGrav: $cfGrav, ')
          ..write('cfCobb: $cfCobb, ')
          ..write('cfStone: $cfStone')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      soilPitSummaryId,
      soilPitCodeField,
      horizonNum,
      horizon,
      horizonUpper,
      thickness,
      color,
      mineralType,
      texture,
      cfGrav,
      cfCobb,
      cfStone);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SoilPitHorizonDescriptionData &&
          other.id == this.id &&
          other.soilPitSummaryId == this.soilPitSummaryId &&
          other.soilPitCodeField == this.soilPitCodeField &&
          other.horizonNum == this.horizonNum &&
          other.horizon == this.horizon &&
          other.horizonUpper == this.horizonUpper &&
          other.thickness == this.thickness &&
          other.color == this.color &&
          other.mineralType == this.mineralType &&
          other.texture == this.texture &&
          other.cfGrav == this.cfGrav &&
          other.cfCobb == this.cfCobb &&
          other.cfStone == this.cfStone);
}

class SoilPitHorizonDescriptionCompanion
    extends d.UpdateCompanion<SoilPitHorizonDescriptionData> {
  final d.Value<int> id;
  final d.Value<int> soilPitSummaryId;
  final d.Value<String> soilPitCodeField;
  final d.Value<int> horizonNum;
  final d.Value<String> horizon;
  final d.Value<double> horizonUpper;
  final d.Value<double> thickness;
  final d.Value<String> color;
  final d.Value<String> mineralType;
  final d.Value<String> texture;
  final d.Value<int> cfGrav;
  final d.Value<int> cfCobb;
  final d.Value<int> cfStone;
  const SoilPitHorizonDescriptionCompanion({
    this.id = const d.Value.absent(),
    this.soilPitSummaryId = const d.Value.absent(),
    this.soilPitCodeField = const d.Value.absent(),
    this.horizonNum = const d.Value.absent(),
    this.horizon = const d.Value.absent(),
    this.horizonUpper = const d.Value.absent(),
    this.thickness = const d.Value.absent(),
    this.color = const d.Value.absent(),
    this.mineralType = const d.Value.absent(),
    this.texture = const d.Value.absent(),
    this.cfGrav = const d.Value.absent(),
    this.cfCobb = const d.Value.absent(),
    this.cfStone = const d.Value.absent(),
  });
  SoilPitHorizonDescriptionCompanion.insert({
    this.id = const d.Value.absent(),
    required int soilPitSummaryId,
    required String soilPitCodeField,
    required int horizonNum,
    required String horizon,
    required double horizonUpper,
    required double thickness,
    required String color,
    required String mineralType,
    required String texture,
    required int cfGrav,
    required int cfCobb,
    required int cfStone,
  })  : soilPitSummaryId = d.Value(soilPitSummaryId),
        soilPitCodeField = d.Value(soilPitCodeField),
        horizonNum = d.Value(horizonNum),
        horizon = d.Value(horizon),
        horizonUpper = d.Value(horizonUpper),
        thickness = d.Value(thickness),
        color = d.Value(color),
        mineralType = d.Value(mineralType),
        texture = d.Value(texture),
        cfGrav = d.Value(cfGrav),
        cfCobb = d.Value(cfCobb),
        cfStone = d.Value(cfStone);
  static d.Insertable<SoilPitHorizonDescriptionData> custom({
    d.Expression<int>? id,
    d.Expression<int>? soilPitSummaryId,
    d.Expression<String>? soilPitCodeField,
    d.Expression<int>? horizonNum,
    d.Expression<String>? horizon,
    d.Expression<double>? horizonUpper,
    d.Expression<double>? thickness,
    d.Expression<String>? color,
    d.Expression<String>? mineralType,
    d.Expression<String>? texture,
    d.Expression<int>? cfGrav,
    d.Expression<int>? cfCobb,
    d.Expression<int>? cfStone,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (soilPitSummaryId != null) 'soil_pit_summary_id': soilPitSummaryId,
      if (soilPitCodeField != null) 'soil_pit_code_field': soilPitCodeField,
      if (horizonNum != null) 'horizon_num': horizonNum,
      if (horizon != null) 'horizon': horizon,
      if (horizonUpper != null) 'horizon_upper': horizonUpper,
      if (thickness != null) 'thickness': thickness,
      if (color != null) 'color': color,
      if (mineralType != null) 'mineral_type': mineralType,
      if (texture != null) 'texture': texture,
      if (cfGrav != null) 'cf_grav': cfGrav,
      if (cfCobb != null) 'cf_cobb': cfCobb,
      if (cfStone != null) 'cf_stone': cfStone,
    });
  }

  SoilPitHorizonDescriptionCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? soilPitSummaryId,
      d.Value<String>? soilPitCodeField,
      d.Value<int>? horizonNum,
      d.Value<String>? horizon,
      d.Value<double>? horizonUpper,
      d.Value<double>? thickness,
      d.Value<String>? color,
      d.Value<String>? mineralType,
      d.Value<String>? texture,
      d.Value<int>? cfGrav,
      d.Value<int>? cfCobb,
      d.Value<int>? cfStone}) {
    return SoilPitHorizonDescriptionCompanion(
      id: id ?? this.id,
      soilPitSummaryId: soilPitSummaryId ?? this.soilPitSummaryId,
      soilPitCodeField: soilPitCodeField ?? this.soilPitCodeField,
      horizonNum: horizonNum ?? this.horizonNum,
      horizon: horizon ?? this.horizon,
      horizonUpper: horizonUpper ?? this.horizonUpper,
      thickness: thickness ?? this.thickness,
      color: color ?? this.color,
      mineralType: mineralType ?? this.mineralType,
      texture: texture ?? this.texture,
      cfGrav: cfGrav ?? this.cfGrav,
      cfCobb: cfCobb ?? this.cfCobb,
      cfStone: cfStone ?? this.cfStone,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (soilPitSummaryId.present) {
      map['soil_pit_summary_id'] = d.Variable<int>(soilPitSummaryId.value);
    }
    if (soilPitCodeField.present) {
      map['soil_pit_code_field'] = d.Variable<String>(soilPitCodeField.value);
    }
    if (horizonNum.present) {
      map['horizon_num'] = d.Variable<int>(horizonNum.value);
    }
    if (horizon.present) {
      map['horizon'] = d.Variable<String>(horizon.value);
    }
    if (horizonUpper.present) {
      map['horizon_upper'] = d.Variable<double>(horizonUpper.value);
    }
    if (thickness.present) {
      map['thickness'] = d.Variable<double>(thickness.value);
    }
    if (color.present) {
      map['color'] = d.Variable<String>(color.value);
    }
    if (mineralType.present) {
      map['mineral_type'] = d.Variable<String>(mineralType.value);
    }
    if (texture.present) {
      map['texture'] = d.Variable<String>(texture.value);
    }
    if (cfGrav.present) {
      map['cf_grav'] = d.Variable<int>(cfGrav.value);
    }
    if (cfCobb.present) {
      map['cf_cobb'] = d.Variable<int>(cfCobb.value);
    }
    if (cfStone.present) {
      map['cf_stone'] = d.Variable<int>(cfStone.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SoilPitHorizonDescriptionCompanion(')
          ..write('id: $id, ')
          ..write('soilPitSummaryId: $soilPitSummaryId, ')
          ..write('soilPitCodeField: $soilPitCodeField, ')
          ..write('horizonNum: $horizonNum, ')
          ..write('horizon: $horizon, ')
          ..write('horizonUpper: $horizonUpper, ')
          ..write('thickness: $thickness, ')
          ..write('color: $color, ')
          ..write('mineralType: $mineralType, ')
          ..write('texture: $texture, ')
          ..write('cfGrav: $cfGrav, ')
          ..write('cfCobb: $cfCobb, ')
          ..write('cfStone: $cfStone')
          ..write(')'))
        .toString();
  }
}

class $LtpSummaryTable extends LtpSummary
    with d.TableInfo<$LtpSummaryTable, LtpSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _plotTypeMeta =
      const d.VerificationMeta('plotType');
  @override
  late final d.GeneratedColumn<String> plotType = d.GeneratedColumn<String>(
      'plot_type', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const d.VerificationMeta _nomPlotSizeMeta =
      const d.VerificationMeta('nomPlotSize');
  @override
  late final d.GeneratedColumn<double> nomPlotSize = d.GeneratedColumn<double>(
      'nom_plot_size', aliasedName, true,
      check: () => nomPlotSize.isBetweenValues(-1, 0.1),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _measPlotSizeMeta =
      const d.VerificationMeta('measPlotSize');
  @override
  late final d.GeneratedColumn<double> measPlotSize = d.GeneratedColumn<double>(
      'meas_plot_size', aliasedName, true,
      check: () => measPlotSize.isBetweenValues(0.0075, 0.1),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        measDate,
        plotType,
        nomPlotSize,
        measPlotSize,
        notAssessed,
        complete
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_summary';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<LtpSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('plot_type')) {
      context.handle(_plotTypeMeta,
          plotType.isAcceptableOrUnknown(data['plot_type']!, _plotTypeMeta));
    }
    if (data.containsKey('nom_plot_size')) {
      context.handle(
          _nomPlotSizeMeta,
          nomPlotSize.isAcceptableOrUnknown(
              data['nom_plot_size']!, _nomPlotSizeMeta));
    }
    if (data.containsKey('meas_plot_size')) {
      context.handle(
          _measPlotSizeMeta,
          measPlotSize.isAcceptableOrUnknown(
              data['meas_plot_size']!, _measPlotSizeMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      plotType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}plot_type']),
      nomPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_plot_size']),
      measPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}meas_plot_size']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $LtpSummaryTable createAlias(String alias) {
    return $LtpSummaryTable(attachedDatabase, alias);
  }
}

class LtpSummaryData extends d.DataClass
    implements d.Insertable<LtpSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final String? plotType;
  final double? nomPlotSize;
  final double? measPlotSize;
  final bool notAssessed;
  final bool complete;
  const LtpSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      this.plotType,
      this.nomPlotSize,
      this.measPlotSize,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    if (!nullToAbsent || plotType != null) {
      map['plot_type'] = d.Variable<String>(plotType);
    }
    if (!nullToAbsent || nomPlotSize != null) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize);
    }
    if (!nullToAbsent || measPlotSize != null) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  LtpSummaryCompanion toCompanion(bool nullToAbsent) {
    return LtpSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      plotType: plotType == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(plotType),
      nomPlotSize: nomPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomPlotSize),
      measPlotSize: measPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(measPlotSize),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory LtpSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      plotType: serializer.fromJson<String?>(json['plotType']),
      nomPlotSize: serializer.fromJson<double?>(json['nomPlotSize']),
      measPlotSize: serializer.fromJson<double?>(json['measPlotSize']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'plotType': serializer.toJson<String?>(plotType),
      'nomPlotSize': serializer.toJson<double?>(nomPlotSize),
      'measPlotSize': serializer.toJson<double?>(measPlotSize),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  LtpSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          d.Value<String?> plotType = const d.Value.absent(),
          d.Value<double?> nomPlotSize = const d.Value.absent(),
          d.Value<double?> measPlotSize = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      LtpSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        plotType: plotType.present ? plotType.value : this.plotType,
        nomPlotSize: nomPlotSize.present ? nomPlotSize.value : this.nomPlotSize,
        measPlotSize:
            measPlotSize.present ? measPlotSize.value : this.measPlotSize,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('LtpSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, measDate, plotType, nomPlotSize,
      measPlotSize, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.plotType == this.plotType &&
          other.nomPlotSize == this.nomPlotSize &&
          other.measPlotSize == this.measPlotSize &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class LtpSummaryCompanion extends d.UpdateCompanion<LtpSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<String?> plotType;
  final d.Value<double?> nomPlotSize;
  final d.Value<double?> measPlotSize;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const LtpSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  LtpSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<LtpSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<String>? plotType,
    d.Expression<double>? nomPlotSize,
    d.Expression<double>? measPlotSize,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (plotType != null) 'plot_type': plotType,
      if (nomPlotSize != null) 'nom_plot_size': nomPlotSize,
      if (measPlotSize != null) 'meas_plot_size': measPlotSize,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  LtpSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<String?>? plotType,
      d.Value<double?>? nomPlotSize,
      d.Value<double?>? measPlotSize,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return LtpSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      plotType: plotType ?? this.plotType,
      nomPlotSize: nomPlotSize ?? this.nomPlotSize,
      measPlotSize: measPlotSize ?? this.measPlotSize,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (plotType.present) {
      map['plot_type'] = d.Variable<String>(plotType.value);
    }
    if (nomPlotSize.present) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize.value);
    }
    if (measPlotSize.present) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeTable extends LtpTree
    with d.TableInfo<$LtpTreeTable, LtpTreeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _lptSummaryIdMeta =
      const d.VerificationMeta('lptSummaryId');
  @override
  late final d.GeneratedColumn<int> lptSummaryId = d.GeneratedColumn<int>(
      'lpt_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ltp_summary (id)'));
  static const d.VerificationMeta _sectorMeta =
      const d.VerificationMeta('sector');
  @override
  late final d.GeneratedColumn<int> sector = d.GeneratedColumn<int>(
      'sector', aliasedName, false,
      check: () => sector.isBetweenValues(-1, 8),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _origPlotAreaMeta =
      const d.VerificationMeta('origPlotArea');
  @override
  late final d.GeneratedColumn<String> origPlotArea = d.GeneratedColumn<String>(
      'orig_plot_area', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _lgTreeGenusMeta =
      const d.VerificationMeta('lgTreeGenus');
  @override
  late final d.GeneratedColumn<String> lgTreeGenus = d.GeneratedColumn<String>(
      'lg_tree_genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _lgTreeSpeciesMeta =
      const d.VerificationMeta('lgTreeSpecies');
  @override
  late final d.GeneratedColumn<String> lgTreeSpecies =
      d.GeneratedColumn<String>('lg_tree_species', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 0, maxTextLength: 3),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _lgTreeVarietyMeta =
      const d.VerificationMeta('lgTreeVariety');
  @override
  late final d.GeneratedColumn<String> lgTreeVariety =
      d.GeneratedColumn<String>('lg_tree_variety', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 0, maxTextLength: 3),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _lgTreeStatusMeta =
      const d.VerificationMeta('lgTreeStatus');
  @override
  late final d.GeneratedColumn<String> lgTreeStatus = d.GeneratedColumn<String>(
      'lg_tree_status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _dbhMeta = const d.VerificationMeta('dbh');
  @override
  late final d.GeneratedColumn<double> dbh = d.GeneratedColumn<double>(
      'dbh', aliasedName, false,
      check: () => dbh.isBetweenValues(-1, 999.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _measEstDbhMeta =
      const d.VerificationMeta('measEstDbh');
  @override
  late final d.GeneratedColumn<String> measEstDbh = d.GeneratedColumn<String>(
      'meas_est_dbh', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _heightMeta =
      const d.VerificationMeta('height');
  @override
  late final d.GeneratedColumn<double> height = d.GeneratedColumn<double>(
      'height', aliasedName, false,
      check: () => height.isBetweenValues(-1, 99.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _measEstHeightMeta =
      const d.VerificationMeta('measEstHeight');
  @override
  late final d.GeneratedColumn<String> measEstHeight =
      d.GeneratedColumn<String>('meas_est_height', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 0, maxTextLength: 1),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _crownClassMeta =
      const d.VerificationMeta('crownClass');
  @override
  late final d.GeneratedColumn<String> crownClass = d.GeneratedColumn<String>(
      'crown_class', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _crownBaseMeta =
      const d.VerificationMeta('crownBase');
  @override
  late final d.GeneratedColumn<double> crownBase = d.GeneratedColumn<double>(
      'crown_base', aliasedName, false,
      check: () => crownBase.isBetweenValues(-9, 99.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _crownTopMeta =
      const d.VerificationMeta('crownTop');
  @override
  late final d.GeneratedColumn<double> crownTop = d.GeneratedColumn<double>(
      'crown_top', aliasedName, false,
      check: () => crownTop.isBetweenValues(-9, 99.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stemCondMeta =
      const d.VerificationMeta('stemCond');
  @override
  late final d.GeneratedColumn<String> stemCond = d.GeneratedColumn<String>(
      'stem_cond', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _crownCondMeta =
      const d.VerificationMeta('crownCond');
  @override
  late final d.GeneratedColumn<int> crownCond = d.GeneratedColumn<int>(
      'crown_cond', aliasedName, false,
      check: () => crownCond.isBetweenValues(-1, 6),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _barkRetMeta =
      const d.VerificationMeta('barkRet');
  @override
  late final d.GeneratedColumn<int> barkRet = d.GeneratedColumn<int>(
      'bark_ret', aliasedName, false,
      check: () => barkRet.isBetweenValues(-1, 7),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _woodCondMeta =
      const d.VerificationMeta('woodCond');
  @override
  late final d.GeneratedColumn<int> woodCond = d.GeneratedColumn<int>(
      'wood_cond', aliasedName, false,
      check: () => woodCond.isBetweenValues(-1, 8),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _azimuthMeta =
      const d.VerificationMeta('azimuth');
  @override
  late final d.GeneratedColumn<int> azimuth = d.GeneratedColumn<int>(
      'azimuth', aliasedName, false,
      check: () => azimuth.isBetweenValues(-1, 360),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _distanceMeta =
      const d.VerificationMeta('distance');
  @override
  late final d.GeneratedColumn<double> distance = d.GeneratedColumn<double>(
      'distance', aliasedName, false,
      check: () => distance.isBetweenValues(-1, 99.99),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _renumberedMeta =
      const d.VerificationMeta('renumbered');
  @override
  late final d.GeneratedColumn<int> renumbered = d.GeneratedColumn<int>(
      'renumbered', aliasedName, false,
      check: () => renumbered.isBetweenValues(-1, 360),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        lptSummaryId,
        sector,
        treeNum,
        origPlotArea,
        lgTreeGenus,
        lgTreeSpecies,
        lgTreeVariety,
        lgTreeStatus,
        dbh,
        measEstDbh,
        height,
        measEstHeight,
        crownClass,
        crownBase,
        crownTop,
        stemCond,
        crownCond,
        barkRet,
        woodCond,
        azimuth,
        distance,
        renumbered
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<LtpTreeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('lpt_summary_id')) {
      context.handle(
          _lptSummaryIdMeta,
          lptSummaryId.isAcceptableOrUnknown(
              data['lpt_summary_id']!, _lptSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_lptSummaryIdMeta);
    }
    if (data.containsKey('sector')) {
      context.handle(_sectorMeta,
          sector.isAcceptableOrUnknown(data['sector']!, _sectorMeta));
    } else if (isInserting) {
      context.missing(_sectorMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('orig_plot_area')) {
      context.handle(
          _origPlotAreaMeta,
          origPlotArea.isAcceptableOrUnknown(
              data['orig_plot_area']!, _origPlotAreaMeta));
    } else if (isInserting) {
      context.missing(_origPlotAreaMeta);
    }
    if (data.containsKey('lg_tree_genus')) {
      context.handle(
          _lgTreeGenusMeta,
          lgTreeGenus.isAcceptableOrUnknown(
              data['lg_tree_genus']!, _lgTreeGenusMeta));
    } else if (isInserting) {
      context.missing(_lgTreeGenusMeta);
    }
    if (data.containsKey('lg_tree_species')) {
      context.handle(
          _lgTreeSpeciesMeta,
          lgTreeSpecies.isAcceptableOrUnknown(
              data['lg_tree_species']!, _lgTreeSpeciesMeta));
    } else if (isInserting) {
      context.missing(_lgTreeSpeciesMeta);
    }
    if (data.containsKey('lg_tree_variety')) {
      context.handle(
          _lgTreeVarietyMeta,
          lgTreeVariety.isAcceptableOrUnknown(
              data['lg_tree_variety']!, _lgTreeVarietyMeta));
    } else if (isInserting) {
      context.missing(_lgTreeVarietyMeta);
    }
    if (data.containsKey('lg_tree_status')) {
      context.handle(
          _lgTreeStatusMeta,
          lgTreeStatus.isAcceptableOrUnknown(
              data['lg_tree_status']!, _lgTreeStatusMeta));
    } else if (isInserting) {
      context.missing(_lgTreeStatusMeta);
    }
    if (data.containsKey('dbh')) {
      context.handle(
          _dbhMeta, dbh.isAcceptableOrUnknown(data['dbh']!, _dbhMeta));
    } else if (isInserting) {
      context.missing(_dbhMeta);
    }
    if (data.containsKey('meas_est_dbh')) {
      context.handle(
          _measEstDbhMeta,
          measEstDbh.isAcceptableOrUnknown(
              data['meas_est_dbh']!, _measEstDbhMeta));
    } else if (isInserting) {
      context.missing(_measEstDbhMeta);
    }
    if (data.containsKey('height')) {
      context.handle(_heightMeta,
          height.isAcceptableOrUnknown(data['height']!, _heightMeta));
    } else if (isInserting) {
      context.missing(_heightMeta);
    }
    if (data.containsKey('meas_est_height')) {
      context.handle(
          _measEstHeightMeta,
          measEstHeight.isAcceptableOrUnknown(
              data['meas_est_height']!, _measEstHeightMeta));
    } else if (isInserting) {
      context.missing(_measEstHeightMeta);
    }
    if (data.containsKey('crown_class')) {
      context.handle(
          _crownClassMeta,
          crownClass.isAcceptableOrUnknown(
              data['crown_class']!, _crownClassMeta));
    } else if (isInserting) {
      context.missing(_crownClassMeta);
    }
    if (data.containsKey('crown_base')) {
      context.handle(_crownBaseMeta,
          crownBase.isAcceptableOrUnknown(data['crown_base']!, _crownBaseMeta));
    } else if (isInserting) {
      context.missing(_crownBaseMeta);
    }
    if (data.containsKey('crown_top')) {
      context.handle(_crownTopMeta,
          crownTop.isAcceptableOrUnknown(data['crown_top']!, _crownTopMeta));
    } else if (isInserting) {
      context.missing(_crownTopMeta);
    }
    if (data.containsKey('stem_cond')) {
      context.handle(_stemCondMeta,
          stemCond.isAcceptableOrUnknown(data['stem_cond']!, _stemCondMeta));
    } else if (isInserting) {
      context.missing(_stemCondMeta);
    }
    if (data.containsKey('crown_cond')) {
      context.handle(_crownCondMeta,
          crownCond.isAcceptableOrUnknown(data['crown_cond']!, _crownCondMeta));
    } else if (isInserting) {
      context.missing(_crownCondMeta);
    }
    if (data.containsKey('bark_ret')) {
      context.handle(_barkRetMeta,
          barkRet.isAcceptableOrUnknown(data['bark_ret']!, _barkRetMeta));
    } else if (isInserting) {
      context.missing(_barkRetMeta);
    }
    if (data.containsKey('wood_cond')) {
      context.handle(_woodCondMeta,
          woodCond.isAcceptableOrUnknown(data['wood_cond']!, _woodCondMeta));
    } else if (isInserting) {
      context.missing(_woodCondMeta);
    }
    if (data.containsKey('azimuth')) {
      context.handle(_azimuthMeta,
          azimuth.isAcceptableOrUnknown(data['azimuth']!, _azimuthMeta));
    } else if (isInserting) {
      context.missing(_azimuthMeta);
    }
    if (data.containsKey('distance')) {
      context.handle(_distanceMeta,
          distance.isAcceptableOrUnknown(data['distance']!, _distanceMeta));
    } else if (isInserting) {
      context.missing(_distanceMeta);
    }
    if (data.containsKey('renumbered')) {
      context.handle(
          _renumberedMeta,
          renumbered.isAcceptableOrUnknown(
              data['renumbered']!, _renumberedMeta));
    } else if (isInserting) {
      context.missing(_renumberedMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpTreeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      lptSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lpt_summary_id'])!,
      sector: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}sector'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      origPlotArea: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}orig_plot_area'])!,
      lgTreeGenus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lg_tree_genus'])!,
      lgTreeSpecies: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}lg_tree_species'])!,
      lgTreeVariety: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}lg_tree_variety'])!,
      lgTreeStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}lg_tree_status'])!,
      dbh: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}dbh'])!,
      measEstDbh: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}meas_est_dbh'])!,
      height: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}height'])!,
      measEstHeight: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}meas_est_height'])!,
      crownClass: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}crown_class'])!,
      crownBase: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}crown_base'])!,
      crownTop: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}crown_top'])!,
      stemCond: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stem_cond'])!,
      crownCond: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}crown_cond'])!,
      barkRet: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}bark_ret'])!,
      woodCond: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}wood_cond'])!,
      azimuth: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}azimuth'])!,
      distance: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}distance'])!,
      renumbered: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}renumbered'])!,
    );
  }

  @override
  $LtpTreeTable createAlias(String alias) {
    return $LtpTreeTable(attachedDatabase, alias);
  }
}

class LtpTreeData extends d.DataClass implements d.Insertable<LtpTreeData> {
  final int id;
  final int lptSummaryId;
  final int sector;
  final int treeNum;
  final String origPlotArea;
  final String lgTreeGenus;
  final String lgTreeSpecies;
  final String lgTreeVariety;
  final String lgTreeStatus;
  final double dbh;
  final String measEstDbh;
  final double height;
  final String measEstHeight;
  final String crownClass;
  final double crownBase;
  final double crownTop;
  final String stemCond;
  final int crownCond;
  final int barkRet;
  final int woodCond;
  final int azimuth;
  final double distance;
  final int renumbered;
  const LtpTreeData(
      {required this.id,
      required this.lptSummaryId,
      required this.sector,
      required this.treeNum,
      required this.origPlotArea,
      required this.lgTreeGenus,
      required this.lgTreeSpecies,
      required this.lgTreeVariety,
      required this.lgTreeStatus,
      required this.dbh,
      required this.measEstDbh,
      required this.height,
      required this.measEstHeight,
      required this.crownClass,
      required this.crownBase,
      required this.crownTop,
      required this.stemCond,
      required this.crownCond,
      required this.barkRet,
      required this.woodCond,
      required this.azimuth,
      required this.distance,
      required this.renumbered});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['lpt_summary_id'] = d.Variable<int>(lptSummaryId);
    map['sector'] = d.Variable<int>(sector);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['orig_plot_area'] = d.Variable<String>(origPlotArea);
    map['lg_tree_genus'] = d.Variable<String>(lgTreeGenus);
    map['lg_tree_species'] = d.Variable<String>(lgTreeSpecies);
    map['lg_tree_variety'] = d.Variable<String>(lgTreeVariety);
    map['lg_tree_status'] = d.Variable<String>(lgTreeStatus);
    map['dbh'] = d.Variable<double>(dbh);
    map['meas_est_dbh'] = d.Variable<String>(measEstDbh);
    map['height'] = d.Variable<double>(height);
    map['meas_est_height'] = d.Variable<String>(measEstHeight);
    map['crown_class'] = d.Variable<String>(crownClass);
    map['crown_base'] = d.Variable<double>(crownBase);
    map['crown_top'] = d.Variable<double>(crownTop);
    map['stem_cond'] = d.Variable<String>(stemCond);
    map['crown_cond'] = d.Variable<int>(crownCond);
    map['bark_ret'] = d.Variable<int>(barkRet);
    map['wood_cond'] = d.Variable<int>(woodCond);
    map['azimuth'] = d.Variable<int>(azimuth);
    map['distance'] = d.Variable<double>(distance);
    map['renumbered'] = d.Variable<int>(renumbered);
    return map;
  }

  LtpTreeCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeCompanion(
      id: d.Value(id),
      lptSummaryId: d.Value(lptSummaryId),
      sector: d.Value(sector),
      treeNum: d.Value(treeNum),
      origPlotArea: d.Value(origPlotArea),
      lgTreeGenus: d.Value(lgTreeGenus),
      lgTreeSpecies: d.Value(lgTreeSpecies),
      lgTreeVariety: d.Value(lgTreeVariety),
      lgTreeStatus: d.Value(lgTreeStatus),
      dbh: d.Value(dbh),
      measEstDbh: d.Value(measEstDbh),
      height: d.Value(height),
      measEstHeight: d.Value(measEstHeight),
      crownClass: d.Value(crownClass),
      crownBase: d.Value(crownBase),
      crownTop: d.Value(crownTop),
      stemCond: d.Value(stemCond),
      crownCond: d.Value(crownCond),
      barkRet: d.Value(barkRet),
      woodCond: d.Value(woodCond),
      azimuth: d.Value(azimuth),
      distance: d.Value(distance),
      renumbered: d.Value(renumbered),
    );
  }

  factory LtpTreeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeData(
      id: serializer.fromJson<int>(json['id']),
      lptSummaryId: serializer.fromJson<int>(json['lptSummaryId']),
      sector: serializer.fromJson<int>(json['sector']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      origPlotArea: serializer.fromJson<String>(json['origPlotArea']),
      lgTreeGenus: serializer.fromJson<String>(json['lgTreeGenus']),
      lgTreeSpecies: serializer.fromJson<String>(json['lgTreeSpecies']),
      lgTreeVariety: serializer.fromJson<String>(json['lgTreeVariety']),
      lgTreeStatus: serializer.fromJson<String>(json['lgTreeStatus']),
      dbh: serializer.fromJson<double>(json['dbh']),
      measEstDbh: serializer.fromJson<String>(json['measEstDbh']),
      height: serializer.fromJson<double>(json['height']),
      measEstHeight: serializer.fromJson<String>(json['measEstHeight']),
      crownClass: serializer.fromJson<String>(json['crownClass']),
      crownBase: serializer.fromJson<double>(json['crownBase']),
      crownTop: serializer.fromJson<double>(json['crownTop']),
      stemCond: serializer.fromJson<String>(json['stemCond']),
      crownCond: serializer.fromJson<int>(json['crownCond']),
      barkRet: serializer.fromJson<int>(json['barkRet']),
      woodCond: serializer.fromJson<int>(json['woodCond']),
      azimuth: serializer.fromJson<int>(json['azimuth']),
      distance: serializer.fromJson<double>(json['distance']),
      renumbered: serializer.fromJson<int>(json['renumbered']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'lptSummaryId': serializer.toJson<int>(lptSummaryId),
      'sector': serializer.toJson<int>(sector),
      'treeNum': serializer.toJson<int>(treeNum),
      'origPlotArea': serializer.toJson<String>(origPlotArea),
      'lgTreeGenus': serializer.toJson<String>(lgTreeGenus),
      'lgTreeSpecies': serializer.toJson<String>(lgTreeSpecies),
      'lgTreeVariety': serializer.toJson<String>(lgTreeVariety),
      'lgTreeStatus': serializer.toJson<String>(lgTreeStatus),
      'dbh': serializer.toJson<double>(dbh),
      'measEstDbh': serializer.toJson<String>(measEstDbh),
      'height': serializer.toJson<double>(height),
      'measEstHeight': serializer.toJson<String>(measEstHeight),
      'crownClass': serializer.toJson<String>(crownClass),
      'crownBase': serializer.toJson<double>(crownBase),
      'crownTop': serializer.toJson<double>(crownTop),
      'stemCond': serializer.toJson<String>(stemCond),
      'crownCond': serializer.toJson<int>(crownCond),
      'barkRet': serializer.toJson<int>(barkRet),
      'woodCond': serializer.toJson<int>(woodCond),
      'azimuth': serializer.toJson<int>(azimuth),
      'distance': serializer.toJson<double>(distance),
      'renumbered': serializer.toJson<int>(renumbered),
    };
  }

  LtpTreeData copyWith(
          {int? id,
          int? lptSummaryId,
          int? sector,
          int? treeNum,
          String? origPlotArea,
          String? lgTreeGenus,
          String? lgTreeSpecies,
          String? lgTreeVariety,
          String? lgTreeStatus,
          double? dbh,
          String? measEstDbh,
          double? height,
          String? measEstHeight,
          String? crownClass,
          double? crownBase,
          double? crownTop,
          String? stemCond,
          int? crownCond,
          int? barkRet,
          int? woodCond,
          int? azimuth,
          double? distance,
          int? renumbered}) =>
      LtpTreeData(
        id: id ?? this.id,
        lptSummaryId: lptSummaryId ?? this.lptSummaryId,
        sector: sector ?? this.sector,
        treeNum: treeNum ?? this.treeNum,
        origPlotArea: origPlotArea ?? this.origPlotArea,
        lgTreeGenus: lgTreeGenus ?? this.lgTreeGenus,
        lgTreeSpecies: lgTreeSpecies ?? this.lgTreeSpecies,
        lgTreeVariety: lgTreeVariety ?? this.lgTreeVariety,
        lgTreeStatus: lgTreeStatus ?? this.lgTreeStatus,
        dbh: dbh ?? this.dbh,
        measEstDbh: measEstDbh ?? this.measEstDbh,
        height: height ?? this.height,
        measEstHeight: measEstHeight ?? this.measEstHeight,
        crownClass: crownClass ?? this.crownClass,
        crownBase: crownBase ?? this.crownBase,
        crownTop: crownTop ?? this.crownTop,
        stemCond: stemCond ?? this.stemCond,
        crownCond: crownCond ?? this.crownCond,
        barkRet: barkRet ?? this.barkRet,
        woodCond: woodCond ?? this.woodCond,
        azimuth: azimuth ?? this.azimuth,
        distance: distance ?? this.distance,
        renumbered: renumbered ?? this.renumbered,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeData(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('sector: $sector, ')
          ..write('treeNum: $treeNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('lgTreeGenus: $lgTreeGenus, ')
          ..write('lgTreeSpecies: $lgTreeSpecies, ')
          ..write('lgTreeVariety: $lgTreeVariety, ')
          ..write('lgTreeStatus: $lgTreeStatus, ')
          ..write('dbh: $dbh, ')
          ..write('measEstDbh: $measEstDbh, ')
          ..write('height: $height, ')
          ..write('measEstHeight: $measEstHeight, ')
          ..write('crownClass: $crownClass, ')
          ..write('crownBase: $crownBase, ')
          ..write('crownTop: $crownTop, ')
          ..write('stemCond: $stemCond, ')
          ..write('crownCond: $crownCond, ')
          ..write('barkRet: $barkRet, ')
          ..write('woodCond: $woodCond, ')
          ..write('azimuth: $azimuth, ')
          ..write('distance: $distance, ')
          ..write('renumbered: $renumbered')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        lptSummaryId,
        sector,
        treeNum,
        origPlotArea,
        lgTreeGenus,
        lgTreeSpecies,
        lgTreeVariety,
        lgTreeStatus,
        dbh,
        measEstDbh,
        height,
        measEstHeight,
        crownClass,
        crownBase,
        crownTop,
        stemCond,
        crownCond,
        barkRet,
        woodCond,
        azimuth,
        distance,
        renumbered
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeData &&
          other.id == this.id &&
          other.lptSummaryId == this.lptSummaryId &&
          other.sector == this.sector &&
          other.treeNum == this.treeNum &&
          other.origPlotArea == this.origPlotArea &&
          other.lgTreeGenus == this.lgTreeGenus &&
          other.lgTreeSpecies == this.lgTreeSpecies &&
          other.lgTreeVariety == this.lgTreeVariety &&
          other.lgTreeStatus == this.lgTreeStatus &&
          other.dbh == this.dbh &&
          other.measEstDbh == this.measEstDbh &&
          other.height == this.height &&
          other.measEstHeight == this.measEstHeight &&
          other.crownClass == this.crownClass &&
          other.crownBase == this.crownBase &&
          other.crownTop == this.crownTop &&
          other.stemCond == this.stemCond &&
          other.crownCond == this.crownCond &&
          other.barkRet == this.barkRet &&
          other.woodCond == this.woodCond &&
          other.azimuth == this.azimuth &&
          other.distance == this.distance &&
          other.renumbered == this.renumbered);
}

class LtpTreeCompanion extends d.UpdateCompanion<LtpTreeData> {
  final d.Value<int> id;
  final d.Value<int> lptSummaryId;
  final d.Value<int> sector;
  final d.Value<int> treeNum;
  final d.Value<String> origPlotArea;
  final d.Value<String> lgTreeGenus;
  final d.Value<String> lgTreeSpecies;
  final d.Value<String> lgTreeVariety;
  final d.Value<String> lgTreeStatus;
  final d.Value<double> dbh;
  final d.Value<String> measEstDbh;
  final d.Value<double> height;
  final d.Value<String> measEstHeight;
  final d.Value<String> crownClass;
  final d.Value<double> crownBase;
  final d.Value<double> crownTop;
  final d.Value<String> stemCond;
  final d.Value<int> crownCond;
  final d.Value<int> barkRet;
  final d.Value<int> woodCond;
  final d.Value<int> azimuth;
  final d.Value<double> distance;
  final d.Value<int> renumbered;
  const LtpTreeCompanion({
    this.id = const d.Value.absent(),
    this.lptSummaryId = const d.Value.absent(),
    this.sector = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.origPlotArea = const d.Value.absent(),
    this.lgTreeGenus = const d.Value.absent(),
    this.lgTreeSpecies = const d.Value.absent(),
    this.lgTreeVariety = const d.Value.absent(),
    this.lgTreeStatus = const d.Value.absent(),
    this.dbh = const d.Value.absent(),
    this.measEstDbh = const d.Value.absent(),
    this.height = const d.Value.absent(),
    this.measEstHeight = const d.Value.absent(),
    this.crownClass = const d.Value.absent(),
    this.crownBase = const d.Value.absent(),
    this.crownTop = const d.Value.absent(),
    this.stemCond = const d.Value.absent(),
    this.crownCond = const d.Value.absent(),
    this.barkRet = const d.Value.absent(),
    this.woodCond = const d.Value.absent(),
    this.azimuth = const d.Value.absent(),
    this.distance = const d.Value.absent(),
    this.renumbered = const d.Value.absent(),
  });
  LtpTreeCompanion.insert({
    this.id = const d.Value.absent(),
    required int lptSummaryId,
    required int sector,
    required int treeNum,
    required String origPlotArea,
    required String lgTreeGenus,
    required String lgTreeSpecies,
    required String lgTreeVariety,
    required String lgTreeStatus,
    required double dbh,
    required String measEstDbh,
    required double height,
    required String measEstHeight,
    required String crownClass,
    required double crownBase,
    required double crownTop,
    required String stemCond,
    required int crownCond,
    required int barkRet,
    required int woodCond,
    required int azimuth,
    required double distance,
    required int renumbered,
  })  : lptSummaryId = d.Value(lptSummaryId),
        sector = d.Value(sector),
        treeNum = d.Value(treeNum),
        origPlotArea = d.Value(origPlotArea),
        lgTreeGenus = d.Value(lgTreeGenus),
        lgTreeSpecies = d.Value(lgTreeSpecies),
        lgTreeVariety = d.Value(lgTreeVariety),
        lgTreeStatus = d.Value(lgTreeStatus),
        dbh = d.Value(dbh),
        measEstDbh = d.Value(measEstDbh),
        height = d.Value(height),
        measEstHeight = d.Value(measEstHeight),
        crownClass = d.Value(crownClass),
        crownBase = d.Value(crownBase),
        crownTop = d.Value(crownTop),
        stemCond = d.Value(stemCond),
        crownCond = d.Value(crownCond),
        barkRet = d.Value(barkRet),
        woodCond = d.Value(woodCond),
        azimuth = d.Value(azimuth),
        distance = d.Value(distance),
        renumbered = d.Value(renumbered);
  static d.Insertable<LtpTreeData> custom({
    d.Expression<int>? id,
    d.Expression<int>? lptSummaryId,
    d.Expression<int>? sector,
    d.Expression<int>? treeNum,
    d.Expression<String>? origPlotArea,
    d.Expression<String>? lgTreeGenus,
    d.Expression<String>? lgTreeSpecies,
    d.Expression<String>? lgTreeVariety,
    d.Expression<String>? lgTreeStatus,
    d.Expression<double>? dbh,
    d.Expression<String>? measEstDbh,
    d.Expression<double>? height,
    d.Expression<String>? measEstHeight,
    d.Expression<String>? crownClass,
    d.Expression<double>? crownBase,
    d.Expression<double>? crownTop,
    d.Expression<String>? stemCond,
    d.Expression<int>? crownCond,
    d.Expression<int>? barkRet,
    d.Expression<int>? woodCond,
    d.Expression<int>? azimuth,
    d.Expression<double>? distance,
    d.Expression<int>? renumbered,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (lptSummaryId != null) 'lpt_summary_id': lptSummaryId,
      if (sector != null) 'sector': sector,
      if (treeNum != null) 'tree_num': treeNum,
      if (origPlotArea != null) 'orig_plot_area': origPlotArea,
      if (lgTreeGenus != null) 'lg_tree_genus': lgTreeGenus,
      if (lgTreeSpecies != null) 'lg_tree_species': lgTreeSpecies,
      if (lgTreeVariety != null) 'lg_tree_variety': lgTreeVariety,
      if (lgTreeStatus != null) 'lg_tree_status': lgTreeStatus,
      if (dbh != null) 'dbh': dbh,
      if (measEstDbh != null) 'meas_est_dbh': measEstDbh,
      if (height != null) 'height': height,
      if (measEstHeight != null) 'meas_est_height': measEstHeight,
      if (crownClass != null) 'crown_class': crownClass,
      if (crownBase != null) 'crown_base': crownBase,
      if (crownTop != null) 'crown_top': crownTop,
      if (stemCond != null) 'stem_cond': stemCond,
      if (crownCond != null) 'crown_cond': crownCond,
      if (barkRet != null) 'bark_ret': barkRet,
      if (woodCond != null) 'wood_cond': woodCond,
      if (azimuth != null) 'azimuth': azimuth,
      if (distance != null) 'distance': distance,
      if (renumbered != null) 'renumbered': renumbered,
    });
  }

  LtpTreeCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? lptSummaryId,
      d.Value<int>? sector,
      d.Value<int>? treeNum,
      d.Value<String>? origPlotArea,
      d.Value<String>? lgTreeGenus,
      d.Value<String>? lgTreeSpecies,
      d.Value<String>? lgTreeVariety,
      d.Value<String>? lgTreeStatus,
      d.Value<double>? dbh,
      d.Value<String>? measEstDbh,
      d.Value<double>? height,
      d.Value<String>? measEstHeight,
      d.Value<String>? crownClass,
      d.Value<double>? crownBase,
      d.Value<double>? crownTop,
      d.Value<String>? stemCond,
      d.Value<int>? crownCond,
      d.Value<int>? barkRet,
      d.Value<int>? woodCond,
      d.Value<int>? azimuth,
      d.Value<double>? distance,
      d.Value<int>? renumbered}) {
    return LtpTreeCompanion(
      id: id ?? this.id,
      lptSummaryId: lptSummaryId ?? this.lptSummaryId,
      sector: sector ?? this.sector,
      treeNum: treeNum ?? this.treeNum,
      origPlotArea: origPlotArea ?? this.origPlotArea,
      lgTreeGenus: lgTreeGenus ?? this.lgTreeGenus,
      lgTreeSpecies: lgTreeSpecies ?? this.lgTreeSpecies,
      lgTreeVariety: lgTreeVariety ?? this.lgTreeVariety,
      lgTreeStatus: lgTreeStatus ?? this.lgTreeStatus,
      dbh: dbh ?? this.dbh,
      measEstDbh: measEstDbh ?? this.measEstDbh,
      height: height ?? this.height,
      measEstHeight: measEstHeight ?? this.measEstHeight,
      crownClass: crownClass ?? this.crownClass,
      crownBase: crownBase ?? this.crownBase,
      crownTop: crownTop ?? this.crownTop,
      stemCond: stemCond ?? this.stemCond,
      crownCond: crownCond ?? this.crownCond,
      barkRet: barkRet ?? this.barkRet,
      woodCond: woodCond ?? this.woodCond,
      azimuth: azimuth ?? this.azimuth,
      distance: distance ?? this.distance,
      renumbered: renumbered ?? this.renumbered,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (lptSummaryId.present) {
      map['lpt_summary_id'] = d.Variable<int>(lptSummaryId.value);
    }
    if (sector.present) {
      map['sector'] = d.Variable<int>(sector.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (origPlotArea.present) {
      map['orig_plot_area'] = d.Variable<String>(origPlotArea.value);
    }
    if (lgTreeGenus.present) {
      map['lg_tree_genus'] = d.Variable<String>(lgTreeGenus.value);
    }
    if (lgTreeSpecies.present) {
      map['lg_tree_species'] = d.Variable<String>(lgTreeSpecies.value);
    }
    if (lgTreeVariety.present) {
      map['lg_tree_variety'] = d.Variable<String>(lgTreeVariety.value);
    }
    if (lgTreeStatus.present) {
      map['lg_tree_status'] = d.Variable<String>(lgTreeStatus.value);
    }
    if (dbh.present) {
      map['dbh'] = d.Variable<double>(dbh.value);
    }
    if (measEstDbh.present) {
      map['meas_est_dbh'] = d.Variable<String>(measEstDbh.value);
    }
    if (height.present) {
      map['height'] = d.Variable<double>(height.value);
    }
    if (measEstHeight.present) {
      map['meas_est_height'] = d.Variable<String>(measEstHeight.value);
    }
    if (crownClass.present) {
      map['crown_class'] = d.Variable<String>(crownClass.value);
    }
    if (crownBase.present) {
      map['crown_base'] = d.Variable<double>(crownBase.value);
    }
    if (crownTop.present) {
      map['crown_top'] = d.Variable<double>(crownTop.value);
    }
    if (stemCond.present) {
      map['stem_cond'] = d.Variable<String>(stemCond.value);
    }
    if (crownCond.present) {
      map['crown_cond'] = d.Variable<int>(crownCond.value);
    }
    if (barkRet.present) {
      map['bark_ret'] = d.Variable<int>(barkRet.value);
    }
    if (woodCond.present) {
      map['wood_cond'] = d.Variable<int>(woodCond.value);
    }
    if (azimuth.present) {
      map['azimuth'] = d.Variable<int>(azimuth.value);
    }
    if (distance.present) {
      map['distance'] = d.Variable<double>(distance.value);
    }
    if (renumbered.present) {
      map['renumbered'] = d.Variable<int>(renumbered.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeCompanion(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('sector: $sector, ')
          ..write('treeNum: $treeNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('lgTreeGenus: $lgTreeGenus, ')
          ..write('lgTreeSpecies: $lgTreeSpecies, ')
          ..write('lgTreeVariety: $lgTreeVariety, ')
          ..write('lgTreeStatus: $lgTreeStatus, ')
          ..write('dbh: $dbh, ')
          ..write('measEstDbh: $measEstDbh, ')
          ..write('height: $height, ')
          ..write('measEstHeight: $measEstHeight, ')
          ..write('crownClass: $crownClass, ')
          ..write('crownBase: $crownBase, ')
          ..write('crownTop: $crownTop, ')
          ..write('stemCond: $stemCond, ')
          ..write('crownCond: $crownCond, ')
          ..write('barkRet: $barkRet, ')
          ..write('woodCond: $woodCond, ')
          ..write('azimuth: $azimuth, ')
          ..write('distance: $distance, ')
          ..write('renumbered: $renumbered')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeDamageTable extends LtpTreeDamage
    with d.TableInfo<$LtpTreeDamageTable, LtpTreeDamageData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeDamageTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _lptSummaryIdMeta =
      const d.VerificationMeta('lptSummaryId');
  @override
  late final d.GeneratedColumn<int> lptSummaryId = d.GeneratedColumn<int>(
      'lpt_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ltp_summary (id)'));
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _damageAgentMeta =
      const d.VerificationMeta('damageAgent');
  @override
  late final d.GeneratedColumn<String> damageAgent = d.GeneratedColumn<String>(
      'damage_agent', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _damageLocationMeta =
      const d.VerificationMeta('damageLocation');
  @override
  late final d.GeneratedColumn<String> damageLocation =
      d.GeneratedColumn<String>('damage_location', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 2, maxTextLength: 2),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _severityPctMeta =
      const d.VerificationMeta('severityPct');
  @override
  late final d.GeneratedColumn<int> severityPct = d.GeneratedColumn<int>(
      'severity_pct', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const d.Constant(-7));
  static const d.VerificationMeta _severityMeta =
      const d.VerificationMeta('severity');
  @override
  late final d.GeneratedColumn<String> severity = d.GeneratedColumn<String>(
      'severity', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        lptSummaryId,
        treeNum,
        damageAgent,
        damageLocation,
        severityPct,
        severity
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree_damage';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpTreeDamageData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('lpt_summary_id')) {
      context.handle(
          _lptSummaryIdMeta,
          lptSummaryId.isAcceptableOrUnknown(
              data['lpt_summary_id']!, _lptSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_lptSummaryIdMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('damage_agent')) {
      context.handle(
          _damageAgentMeta,
          damageAgent.isAcceptableOrUnknown(
              data['damage_agent']!, _damageAgentMeta));
    } else if (isInserting) {
      context.missing(_damageAgentMeta);
    }
    if (data.containsKey('damage_location')) {
      context.handle(
          _damageLocationMeta,
          damageLocation.isAcceptableOrUnknown(
              data['damage_location']!, _damageLocationMeta));
    } else if (isInserting) {
      context.missing(_damageLocationMeta);
    }
    if (data.containsKey('severity_pct')) {
      context.handle(
          _severityPctMeta,
          severityPct.isAcceptableOrUnknown(
              data['severity_pct']!, _severityPctMeta));
    }
    if (data.containsKey('severity')) {
      context.handle(_severityMeta,
          severity.isAcceptableOrUnknown(data['severity']!, _severityMeta));
    } else if (isInserting) {
      context.missing(_severityMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpTreeDamageData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeDamageData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      lptSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lpt_summary_id'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      damageAgent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}damage_agent'])!,
      damageLocation: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}damage_location'])!,
      severityPct: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}severity_pct'])!,
      severity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}severity'])!,
    );
  }

  @override
  $LtpTreeDamageTable createAlias(String alias) {
    return $LtpTreeDamageTable(attachedDatabase, alias);
  }
}

class LtpTreeDamageData extends d.DataClass
    implements d.Insertable<LtpTreeDamageData> {
  final int id;
  final int lptSummaryId;
  final int treeNum;
  final String damageAgent;
  final String damageLocation;
  final int severityPct;
  final String severity;
  const LtpTreeDamageData(
      {required this.id,
      required this.lptSummaryId,
      required this.treeNum,
      required this.damageAgent,
      required this.damageLocation,
      required this.severityPct,
      required this.severity});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['lpt_summary_id'] = d.Variable<int>(lptSummaryId);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['damage_agent'] = d.Variable<String>(damageAgent);
    map['damage_location'] = d.Variable<String>(damageLocation);
    map['severity_pct'] = d.Variable<int>(severityPct);
    map['severity'] = d.Variable<String>(severity);
    return map;
  }

  LtpTreeDamageCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeDamageCompanion(
      id: d.Value(id),
      lptSummaryId: d.Value(lptSummaryId),
      treeNum: d.Value(treeNum),
      damageAgent: d.Value(damageAgent),
      damageLocation: d.Value(damageLocation),
      severityPct: d.Value(severityPct),
      severity: d.Value(severity),
    );
  }

  factory LtpTreeDamageData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeDamageData(
      id: serializer.fromJson<int>(json['id']),
      lptSummaryId: serializer.fromJson<int>(json['lptSummaryId']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      damageAgent: serializer.fromJson<String>(json['damageAgent']),
      damageLocation: serializer.fromJson<String>(json['damageLocation']),
      severityPct: serializer.fromJson<int>(json['severityPct']),
      severity: serializer.fromJson<String>(json['severity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'lptSummaryId': serializer.toJson<int>(lptSummaryId),
      'treeNum': serializer.toJson<int>(treeNum),
      'damageAgent': serializer.toJson<String>(damageAgent),
      'damageLocation': serializer.toJson<String>(damageLocation),
      'severityPct': serializer.toJson<int>(severityPct),
      'severity': serializer.toJson<String>(severity),
    };
  }

  LtpTreeDamageData copyWith(
          {int? id,
          int? lptSummaryId,
          int? treeNum,
          String? damageAgent,
          String? damageLocation,
          int? severityPct,
          String? severity}) =>
      LtpTreeDamageData(
        id: id ?? this.id,
        lptSummaryId: lptSummaryId ?? this.lptSummaryId,
        treeNum: treeNum ?? this.treeNum,
        damageAgent: damageAgent ?? this.damageAgent,
        damageLocation: damageLocation ?? this.damageLocation,
        severityPct: severityPct ?? this.severityPct,
        severity: severity ?? this.severity,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeDamageData(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('damageAgent: $damageAgent, ')
          ..write('damageLocation: $damageLocation, ')
          ..write('severityPct: $severityPct, ')
          ..write('severity: $severity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lptSummaryId, treeNum, damageAgent,
      damageLocation, severityPct, severity);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeDamageData &&
          other.id == this.id &&
          other.lptSummaryId == this.lptSummaryId &&
          other.treeNum == this.treeNum &&
          other.damageAgent == this.damageAgent &&
          other.damageLocation == this.damageLocation &&
          other.severityPct == this.severityPct &&
          other.severity == this.severity);
}

class LtpTreeDamageCompanion extends d.UpdateCompanion<LtpTreeDamageData> {
  final d.Value<int> id;
  final d.Value<int> lptSummaryId;
  final d.Value<int> treeNum;
  final d.Value<String> damageAgent;
  final d.Value<String> damageLocation;
  final d.Value<int> severityPct;
  final d.Value<String> severity;
  const LtpTreeDamageCompanion({
    this.id = const d.Value.absent(),
    this.lptSummaryId = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.damageAgent = const d.Value.absent(),
    this.damageLocation = const d.Value.absent(),
    this.severityPct = const d.Value.absent(),
    this.severity = const d.Value.absent(),
  });
  LtpTreeDamageCompanion.insert({
    this.id = const d.Value.absent(),
    required int lptSummaryId,
    required int treeNum,
    required String damageAgent,
    required String damageLocation,
    this.severityPct = const d.Value.absent(),
    required String severity,
  })  : lptSummaryId = d.Value(lptSummaryId),
        treeNum = d.Value(treeNum),
        damageAgent = d.Value(damageAgent),
        damageLocation = d.Value(damageLocation),
        severity = d.Value(severity);
  static d.Insertable<LtpTreeDamageData> custom({
    d.Expression<int>? id,
    d.Expression<int>? lptSummaryId,
    d.Expression<int>? treeNum,
    d.Expression<String>? damageAgent,
    d.Expression<String>? damageLocation,
    d.Expression<int>? severityPct,
    d.Expression<String>? severity,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (lptSummaryId != null) 'lpt_summary_id': lptSummaryId,
      if (treeNum != null) 'tree_num': treeNum,
      if (damageAgent != null) 'damage_agent': damageAgent,
      if (damageLocation != null) 'damage_location': damageLocation,
      if (severityPct != null) 'severity_pct': severityPct,
      if (severity != null) 'severity': severity,
    });
  }

  LtpTreeDamageCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? lptSummaryId,
      d.Value<int>? treeNum,
      d.Value<String>? damageAgent,
      d.Value<String>? damageLocation,
      d.Value<int>? severityPct,
      d.Value<String>? severity}) {
    return LtpTreeDamageCompanion(
      id: id ?? this.id,
      lptSummaryId: lptSummaryId ?? this.lptSummaryId,
      treeNum: treeNum ?? this.treeNum,
      damageAgent: damageAgent ?? this.damageAgent,
      damageLocation: damageLocation ?? this.damageLocation,
      severityPct: severityPct ?? this.severityPct,
      severity: severity ?? this.severity,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (lptSummaryId.present) {
      map['lpt_summary_id'] = d.Variable<int>(lptSummaryId.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (damageAgent.present) {
      map['damage_agent'] = d.Variable<String>(damageAgent.value);
    }
    if (damageLocation.present) {
      map['damage_location'] = d.Variable<String>(damageLocation.value);
    }
    if (severityPct.present) {
      map['severity_pct'] = d.Variable<int>(severityPct.value);
    }
    if (severity.present) {
      map['severity'] = d.Variable<String>(severity.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeDamageCompanion(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('damageAgent: $damageAgent, ')
          ..write('damageLocation: $damageLocation, ')
          ..write('severityPct: $severityPct, ')
          ..write('severity: $severity')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeRemovedTable extends LtpTreeRemoved
    with d.TableInfo<$LtpTreeRemovedTable, LtpTreeRemovedData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeRemovedTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _lptSummaryIdMeta =
      const d.VerificationMeta('lptSummaryId');
  @override
  late final d.GeneratedColumn<int> lptSummaryId = d.GeneratedColumn<int>(
      'lpt_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ltp_summary (id)'));
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _reasonMeta =
      const d.VerificationMeta('reason');
  @override
  late final d.GeneratedColumn<String> reason = d.GeneratedColumn<String>(
      'reason', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [id, lptSummaryId, treeNum, reason];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree_removed';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpTreeRemovedData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('lpt_summary_id')) {
      context.handle(
          _lptSummaryIdMeta,
          lptSummaryId.isAcceptableOrUnknown(
              data['lpt_summary_id']!, _lptSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_lptSummaryIdMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpTreeRemovedData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeRemovedData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      lptSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lpt_summary_id'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason'])!,
    );
  }

  @override
  $LtpTreeRemovedTable createAlias(String alias) {
    return $LtpTreeRemovedTable(attachedDatabase, alias);
  }
}

class LtpTreeRemovedData extends d.DataClass
    implements d.Insertable<LtpTreeRemovedData> {
  final int id;
  final int lptSummaryId;
  final int treeNum;
  final String reason;
  const LtpTreeRemovedData(
      {required this.id,
      required this.lptSummaryId,
      required this.treeNum,
      required this.reason});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['lpt_summary_id'] = d.Variable<int>(lptSummaryId);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['reason'] = d.Variable<String>(reason);
    return map;
  }

  LtpTreeRemovedCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeRemovedCompanion(
      id: d.Value(id),
      lptSummaryId: d.Value(lptSummaryId),
      treeNum: d.Value(treeNum),
      reason: d.Value(reason),
    );
  }

  factory LtpTreeRemovedData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeRemovedData(
      id: serializer.fromJson<int>(json['id']),
      lptSummaryId: serializer.fromJson<int>(json['lptSummaryId']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      reason: serializer.fromJson<String>(json['reason']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'lptSummaryId': serializer.toJson<int>(lptSummaryId),
      'treeNum': serializer.toJson<int>(treeNum),
      'reason': serializer.toJson<String>(reason),
    };
  }

  LtpTreeRemovedData copyWith(
          {int? id, int? lptSummaryId, int? treeNum, String? reason}) =>
      LtpTreeRemovedData(
        id: id ?? this.id,
        lptSummaryId: lptSummaryId ?? this.lptSummaryId,
        treeNum: treeNum ?? this.treeNum,
        reason: reason ?? this.reason,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeRemovedData(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('reason: $reason')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lptSummaryId, treeNum, reason);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeRemovedData &&
          other.id == this.id &&
          other.lptSummaryId == this.lptSummaryId &&
          other.treeNum == this.treeNum &&
          other.reason == this.reason);
}

class LtpTreeRemovedCompanion extends d.UpdateCompanion<LtpTreeRemovedData> {
  final d.Value<int> id;
  final d.Value<int> lptSummaryId;
  final d.Value<int> treeNum;
  final d.Value<String> reason;
  const LtpTreeRemovedCompanion({
    this.id = const d.Value.absent(),
    this.lptSummaryId = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.reason = const d.Value.absent(),
  });
  LtpTreeRemovedCompanion.insert({
    this.id = const d.Value.absent(),
    required int lptSummaryId,
    required int treeNum,
    required String reason,
  })  : lptSummaryId = d.Value(lptSummaryId),
        treeNum = d.Value(treeNum),
        reason = d.Value(reason);
  static d.Insertable<LtpTreeRemovedData> custom({
    d.Expression<int>? id,
    d.Expression<int>? lptSummaryId,
    d.Expression<int>? treeNum,
    d.Expression<String>? reason,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (lptSummaryId != null) 'lpt_summary_id': lptSummaryId,
      if (treeNum != null) 'tree_num': treeNum,
      if (reason != null) 'reason': reason,
    });
  }

  LtpTreeRemovedCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? lptSummaryId,
      d.Value<int>? treeNum,
      d.Value<String>? reason}) {
    return LtpTreeRemovedCompanion(
      id: id ?? this.id,
      lptSummaryId: lptSummaryId ?? this.lptSummaryId,
      treeNum: treeNum ?? this.treeNum,
      reason: reason ?? this.reason,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (lptSummaryId.present) {
      map['lpt_summary_id'] = d.Variable<int>(lptSummaryId.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (reason.present) {
      map['reason'] = d.Variable<String>(reason.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeRemovedCompanion(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('reason: $reason')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeAgeTable extends LtpTreeAge
    with d.TableInfo<$LtpTreeAgeTable, LtpTreeAgeData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeAgeTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _lptSummaryIdMeta =
      const d.VerificationMeta('lptSummaryId');
  @override
  late final d.GeneratedColumn<int> lptSummaryId = d.GeneratedColumn<int>(
      'lpt_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ltp_summary (id)'));
  static const d.VerificationMeta _quadrantMeta =
      const d.VerificationMeta('quadrant');
  @override
  late final d.GeneratedColumn<String> quadrant = d.GeneratedColumn<String>(
      'quadrant', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _siteTypeMeta =
      const d.VerificationMeta('siteType');
  @override
  late final d.GeneratedColumn<String> siteType = d.GeneratedColumn<String>(
      'site_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 2, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _boreDOBMeta =
      const d.VerificationMeta('boreDOB');
  @override
  late final d.GeneratedColumn<double> boreDOB = d.GeneratedColumn<double>(
      'bore_d_o_b', aliasedName, false,
      check: () => boreDOB.isBetweenValues(-1, 999.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _boreHtMeta =
      const d.VerificationMeta('boreHt');
  @override
  late final d.GeneratedColumn<double> boreHt = d.GeneratedColumn<double>(
      'bore_ht', aliasedName, false,
      check: () => boreHt.isBetweenValues(-1, 9.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _suitHtMeta =
      const d.VerificationMeta('suitHt');
  @override
  late final d.GeneratedColumn<String> suitHt = d.GeneratedColumn<String>(
      'suit_ht', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _suitAgeMeta =
      const d.VerificationMeta('suitAge');
  @override
  late final d.GeneratedColumn<String> suitAge = d.GeneratedColumn<String>(
      'suit_age', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _fieldAgeMeta =
      const d.VerificationMeta('fieldAge');
  @override
  late final d.GeneratedColumn<int> fieldAge = d.GeneratedColumn<int>(
      'field_age', aliasedName, false,
      check: () => fieldAge.isBetweenValues(-8, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _proCodeMeta =
      const d.VerificationMeta('proCode');
  @override
  late final d.GeneratedColumn<String> proCode = d.GeneratedColumn<String>(
      'pro_code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        lptSummaryId,
        quadrant,
        treeNum,
        siteType,
        boreDOB,
        boreHt,
        suitHt,
        suitAge,
        fieldAge,
        proCode
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree_age';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<LtpTreeAgeData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('lpt_summary_id')) {
      context.handle(
          _lptSummaryIdMeta,
          lptSummaryId.isAcceptableOrUnknown(
              data['lpt_summary_id']!, _lptSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_lptSummaryIdMeta);
    }
    if (data.containsKey('quadrant')) {
      context.handle(_quadrantMeta,
          quadrant.isAcceptableOrUnknown(data['quadrant']!, _quadrantMeta));
    } else if (isInserting) {
      context.missing(_quadrantMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('site_type')) {
      context.handle(_siteTypeMeta,
          siteType.isAcceptableOrUnknown(data['site_type']!, _siteTypeMeta));
    } else if (isInserting) {
      context.missing(_siteTypeMeta);
    }
    if (data.containsKey('bore_d_o_b')) {
      context.handle(_boreDOBMeta,
          boreDOB.isAcceptableOrUnknown(data['bore_d_o_b']!, _boreDOBMeta));
    } else if (isInserting) {
      context.missing(_boreDOBMeta);
    }
    if (data.containsKey('bore_ht')) {
      context.handle(_boreHtMeta,
          boreHt.isAcceptableOrUnknown(data['bore_ht']!, _boreHtMeta));
    } else if (isInserting) {
      context.missing(_boreHtMeta);
    }
    if (data.containsKey('suit_ht')) {
      context.handle(_suitHtMeta,
          suitHt.isAcceptableOrUnknown(data['suit_ht']!, _suitHtMeta));
    } else if (isInserting) {
      context.missing(_suitHtMeta);
    }
    if (data.containsKey('suit_age')) {
      context.handle(_suitAgeMeta,
          suitAge.isAcceptableOrUnknown(data['suit_age']!, _suitAgeMeta));
    } else if (isInserting) {
      context.missing(_suitAgeMeta);
    }
    if (data.containsKey('field_age')) {
      context.handle(_fieldAgeMeta,
          fieldAge.isAcceptableOrUnknown(data['field_age']!, _fieldAgeMeta));
    } else if (isInserting) {
      context.missing(_fieldAgeMeta);
    }
    if (data.containsKey('pro_code')) {
      context.handle(_proCodeMeta,
          proCode.isAcceptableOrUnknown(data['pro_code']!, _proCodeMeta));
    } else if (isInserting) {
      context.missing(_proCodeMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpTreeAgeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeAgeData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      lptSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lpt_summary_id'])!,
      quadrant: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}quadrant'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      siteType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}site_type'])!,
      boreDOB: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}bore_d_o_b'])!,
      boreHt: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}bore_ht'])!,
      suitHt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}suit_ht'])!,
      suitAge: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}suit_age'])!,
      fieldAge: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}field_age'])!,
      proCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pro_code'])!,
    );
  }

  @override
  $LtpTreeAgeTable createAlias(String alias) {
    return $LtpTreeAgeTable(attachedDatabase, alias);
  }
}

class LtpTreeAgeData extends d.DataClass
    implements d.Insertable<LtpTreeAgeData> {
  final int id;
  final int lptSummaryId;
  final String quadrant;
  final int treeNum;
  final String siteType;
  final double boreDOB;
  final double boreHt;
  final String suitHt;
  final String suitAge;
  final int fieldAge;
  final String proCode;
  const LtpTreeAgeData(
      {required this.id,
      required this.lptSummaryId,
      required this.quadrant,
      required this.treeNum,
      required this.siteType,
      required this.boreDOB,
      required this.boreHt,
      required this.suitHt,
      required this.suitAge,
      required this.fieldAge,
      required this.proCode});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['lpt_summary_id'] = d.Variable<int>(lptSummaryId);
    map['quadrant'] = d.Variable<String>(quadrant);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['site_type'] = d.Variable<String>(siteType);
    map['bore_d_o_b'] = d.Variable<double>(boreDOB);
    map['bore_ht'] = d.Variable<double>(boreHt);
    map['suit_ht'] = d.Variable<String>(suitHt);
    map['suit_age'] = d.Variable<String>(suitAge);
    map['field_age'] = d.Variable<int>(fieldAge);
    map['pro_code'] = d.Variable<String>(proCode);
    return map;
  }

  LtpTreeAgeCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeAgeCompanion(
      id: d.Value(id),
      lptSummaryId: d.Value(lptSummaryId),
      quadrant: d.Value(quadrant),
      treeNum: d.Value(treeNum),
      siteType: d.Value(siteType),
      boreDOB: d.Value(boreDOB),
      boreHt: d.Value(boreHt),
      suitHt: d.Value(suitHt),
      suitAge: d.Value(suitAge),
      fieldAge: d.Value(fieldAge),
      proCode: d.Value(proCode),
    );
  }

  factory LtpTreeAgeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeAgeData(
      id: serializer.fromJson<int>(json['id']),
      lptSummaryId: serializer.fromJson<int>(json['lptSummaryId']),
      quadrant: serializer.fromJson<String>(json['quadrant']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      siteType: serializer.fromJson<String>(json['siteType']),
      boreDOB: serializer.fromJson<double>(json['boreDOB']),
      boreHt: serializer.fromJson<double>(json['boreHt']),
      suitHt: serializer.fromJson<String>(json['suitHt']),
      suitAge: serializer.fromJson<String>(json['suitAge']),
      fieldAge: serializer.fromJson<int>(json['fieldAge']),
      proCode: serializer.fromJson<String>(json['proCode']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'lptSummaryId': serializer.toJson<int>(lptSummaryId),
      'quadrant': serializer.toJson<String>(quadrant),
      'treeNum': serializer.toJson<int>(treeNum),
      'siteType': serializer.toJson<String>(siteType),
      'boreDOB': serializer.toJson<double>(boreDOB),
      'boreHt': serializer.toJson<double>(boreHt),
      'suitHt': serializer.toJson<String>(suitHt),
      'suitAge': serializer.toJson<String>(suitAge),
      'fieldAge': serializer.toJson<int>(fieldAge),
      'proCode': serializer.toJson<String>(proCode),
    };
  }

  LtpTreeAgeData copyWith(
          {int? id,
          int? lptSummaryId,
          String? quadrant,
          int? treeNum,
          String? siteType,
          double? boreDOB,
          double? boreHt,
          String? suitHt,
          String? suitAge,
          int? fieldAge,
          String? proCode}) =>
      LtpTreeAgeData(
        id: id ?? this.id,
        lptSummaryId: lptSummaryId ?? this.lptSummaryId,
        quadrant: quadrant ?? this.quadrant,
        treeNum: treeNum ?? this.treeNum,
        siteType: siteType ?? this.siteType,
        boreDOB: boreDOB ?? this.boreDOB,
        boreHt: boreHt ?? this.boreHt,
        suitHt: suitHt ?? this.suitHt,
        suitAge: suitAge ?? this.suitAge,
        fieldAge: fieldAge ?? this.fieldAge,
        proCode: proCode ?? this.proCode,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeAgeData(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('quadrant: $quadrant, ')
          ..write('treeNum: $treeNum, ')
          ..write('siteType: $siteType, ')
          ..write('boreDOB: $boreDOB, ')
          ..write('boreHt: $boreHt, ')
          ..write('suitHt: $suitHt, ')
          ..write('suitAge: $suitAge, ')
          ..write('fieldAge: $fieldAge, ')
          ..write('proCode: $proCode')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lptSummaryId, quadrant, treeNum, siteType,
      boreDOB, boreHt, suitHt, suitAge, fieldAge, proCode);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeAgeData &&
          other.id == this.id &&
          other.lptSummaryId == this.lptSummaryId &&
          other.quadrant == this.quadrant &&
          other.treeNum == this.treeNum &&
          other.siteType == this.siteType &&
          other.boreDOB == this.boreDOB &&
          other.boreHt == this.boreHt &&
          other.suitHt == this.suitHt &&
          other.suitAge == this.suitAge &&
          other.fieldAge == this.fieldAge &&
          other.proCode == this.proCode);
}

class LtpTreeAgeCompanion extends d.UpdateCompanion<LtpTreeAgeData> {
  final d.Value<int> id;
  final d.Value<int> lptSummaryId;
  final d.Value<String> quadrant;
  final d.Value<int> treeNum;
  final d.Value<String> siteType;
  final d.Value<double> boreDOB;
  final d.Value<double> boreHt;
  final d.Value<String> suitHt;
  final d.Value<String> suitAge;
  final d.Value<int> fieldAge;
  final d.Value<String> proCode;
  const LtpTreeAgeCompanion({
    this.id = const d.Value.absent(),
    this.lptSummaryId = const d.Value.absent(),
    this.quadrant = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.siteType = const d.Value.absent(),
    this.boreDOB = const d.Value.absent(),
    this.boreHt = const d.Value.absent(),
    this.suitHt = const d.Value.absent(),
    this.suitAge = const d.Value.absent(),
    this.fieldAge = const d.Value.absent(),
    this.proCode = const d.Value.absent(),
  });
  LtpTreeAgeCompanion.insert({
    this.id = const d.Value.absent(),
    required int lptSummaryId,
    required String quadrant,
    required int treeNum,
    required String siteType,
    required double boreDOB,
    required double boreHt,
    required String suitHt,
    required String suitAge,
    required int fieldAge,
    required String proCode,
  })  : lptSummaryId = d.Value(lptSummaryId),
        quadrant = d.Value(quadrant),
        treeNum = d.Value(treeNum),
        siteType = d.Value(siteType),
        boreDOB = d.Value(boreDOB),
        boreHt = d.Value(boreHt),
        suitHt = d.Value(suitHt),
        suitAge = d.Value(suitAge),
        fieldAge = d.Value(fieldAge),
        proCode = d.Value(proCode);
  static d.Insertable<LtpTreeAgeData> custom({
    d.Expression<int>? id,
    d.Expression<int>? lptSummaryId,
    d.Expression<String>? quadrant,
    d.Expression<int>? treeNum,
    d.Expression<String>? siteType,
    d.Expression<double>? boreDOB,
    d.Expression<double>? boreHt,
    d.Expression<String>? suitHt,
    d.Expression<String>? suitAge,
    d.Expression<int>? fieldAge,
    d.Expression<String>? proCode,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (lptSummaryId != null) 'lpt_summary_id': lptSummaryId,
      if (quadrant != null) 'quadrant': quadrant,
      if (treeNum != null) 'tree_num': treeNum,
      if (siteType != null) 'site_type': siteType,
      if (boreDOB != null) 'bore_d_o_b': boreDOB,
      if (boreHt != null) 'bore_ht': boreHt,
      if (suitHt != null) 'suit_ht': suitHt,
      if (suitAge != null) 'suit_age': suitAge,
      if (fieldAge != null) 'field_age': fieldAge,
      if (proCode != null) 'pro_code': proCode,
    });
  }

  LtpTreeAgeCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? lptSummaryId,
      d.Value<String>? quadrant,
      d.Value<int>? treeNum,
      d.Value<String>? siteType,
      d.Value<double>? boreDOB,
      d.Value<double>? boreHt,
      d.Value<String>? suitHt,
      d.Value<String>? suitAge,
      d.Value<int>? fieldAge,
      d.Value<String>? proCode}) {
    return LtpTreeAgeCompanion(
      id: id ?? this.id,
      lptSummaryId: lptSummaryId ?? this.lptSummaryId,
      quadrant: quadrant ?? this.quadrant,
      treeNum: treeNum ?? this.treeNum,
      siteType: siteType ?? this.siteType,
      boreDOB: boreDOB ?? this.boreDOB,
      boreHt: boreHt ?? this.boreHt,
      suitHt: suitHt ?? this.suitHt,
      suitAge: suitAge ?? this.suitAge,
      fieldAge: fieldAge ?? this.fieldAge,
      proCode: proCode ?? this.proCode,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (lptSummaryId.present) {
      map['lpt_summary_id'] = d.Variable<int>(lptSummaryId.value);
    }
    if (quadrant.present) {
      map['quadrant'] = d.Variable<String>(quadrant.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (siteType.present) {
      map['site_type'] = d.Variable<String>(siteType.value);
    }
    if (boreDOB.present) {
      map['bore_d_o_b'] = d.Variable<double>(boreDOB.value);
    }
    if (boreHt.present) {
      map['bore_ht'] = d.Variable<double>(boreHt.value);
    }
    if (suitHt.present) {
      map['suit_ht'] = d.Variable<String>(suitHt.value);
    }
    if (suitAge.present) {
      map['suit_age'] = d.Variable<String>(suitAge.value);
    }
    if (fieldAge.present) {
      map['field_age'] = d.Variable<int>(fieldAge.value);
    }
    if (proCode.present) {
      map['pro_code'] = d.Variable<String>(proCode.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeAgeCompanion(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('quadrant: $quadrant, ')
          ..write('treeNum: $treeNum, ')
          ..write('siteType: $siteType, ')
          ..write('boreDOB: $boreDOB, ')
          ..write('boreHt: $boreHt, ')
          ..write('suitHt: $suitHt, ')
          ..write('suitAge: $suitAge, ')
          ..write('fieldAge: $fieldAge, ')
          ..write('proCode: $proCode')
          ..write(')'))
        .toString();
  }
}

class $LtpTreeRenamedTable extends LtpTreeRenamed
    with d.TableInfo<$LtpTreeRenamedTable, LtpTreeRenamedData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LtpTreeRenamedTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _lptSummaryIdMeta =
      const d.VerificationMeta('lptSummaryId');
  @override
  late final d.GeneratedColumn<int> lptSummaryId = d.GeneratedColumn<int>(
      'lpt_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES ltp_summary (id)'));
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _treeNumPrevMeta =
      const d.VerificationMeta('treeNumPrev');
  @override
  late final d.GeneratedColumn<int> treeNumPrev = d.GeneratedColumn<int>(
      'tree_num_prev', aliasedName, false,
      check: () => treeNumPrev.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, lptSummaryId, treeNum, treeNumPrev];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ltp_tree_renamed';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<LtpTreeRenamedData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('lpt_summary_id')) {
      context.handle(
          _lptSummaryIdMeta,
          lptSummaryId.isAcceptableOrUnknown(
              data['lpt_summary_id']!, _lptSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_lptSummaryIdMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('tree_num_prev')) {
      context.handle(
          _treeNumPrevMeta,
          treeNumPrev.isAcceptableOrUnknown(
              data['tree_num_prev']!, _treeNumPrevMeta));
    } else if (isInserting) {
      context.missing(_treeNumPrevMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  LtpTreeRenamedData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LtpTreeRenamedData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      lptSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lpt_summary_id'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      treeNumPrev: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num_prev'])!,
    );
  }

  @override
  $LtpTreeRenamedTable createAlias(String alias) {
    return $LtpTreeRenamedTable(attachedDatabase, alias);
  }
}

class LtpTreeRenamedData extends d.DataClass
    implements d.Insertable<LtpTreeRenamedData> {
  final int id;
  final int lptSummaryId;
  final int treeNum;
  final int treeNumPrev;
  const LtpTreeRenamedData(
      {required this.id,
      required this.lptSummaryId,
      required this.treeNum,
      required this.treeNumPrev});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['lpt_summary_id'] = d.Variable<int>(lptSummaryId);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['tree_num_prev'] = d.Variable<int>(treeNumPrev);
    return map;
  }

  LtpTreeRenamedCompanion toCompanion(bool nullToAbsent) {
    return LtpTreeRenamedCompanion(
      id: d.Value(id),
      lptSummaryId: d.Value(lptSummaryId),
      treeNum: d.Value(treeNum),
      treeNumPrev: d.Value(treeNumPrev),
    );
  }

  factory LtpTreeRenamedData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return LtpTreeRenamedData(
      id: serializer.fromJson<int>(json['id']),
      lptSummaryId: serializer.fromJson<int>(json['lptSummaryId']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      treeNumPrev: serializer.fromJson<int>(json['treeNumPrev']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'lptSummaryId': serializer.toJson<int>(lptSummaryId),
      'treeNum': serializer.toJson<int>(treeNum),
      'treeNumPrev': serializer.toJson<int>(treeNumPrev),
    };
  }

  LtpTreeRenamedData copyWith(
          {int? id, int? lptSummaryId, int? treeNum, int? treeNumPrev}) =>
      LtpTreeRenamedData(
        id: id ?? this.id,
        lptSummaryId: lptSummaryId ?? this.lptSummaryId,
        treeNum: treeNum ?? this.treeNum,
        treeNumPrev: treeNumPrev ?? this.treeNumPrev,
      );
  @override
  String toString() {
    return (StringBuffer('LtpTreeRenamedData(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('treeNumPrev: $treeNumPrev')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, lptSummaryId, treeNum, treeNumPrev);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LtpTreeRenamedData &&
          other.id == this.id &&
          other.lptSummaryId == this.lptSummaryId &&
          other.treeNum == this.treeNum &&
          other.treeNumPrev == this.treeNumPrev);
}

class LtpTreeRenamedCompanion extends d.UpdateCompanion<LtpTreeRenamedData> {
  final d.Value<int> id;
  final d.Value<int> lptSummaryId;
  final d.Value<int> treeNum;
  final d.Value<int> treeNumPrev;
  const LtpTreeRenamedCompanion({
    this.id = const d.Value.absent(),
    this.lptSummaryId = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.treeNumPrev = const d.Value.absent(),
  });
  LtpTreeRenamedCompanion.insert({
    this.id = const d.Value.absent(),
    required int lptSummaryId,
    required int treeNum,
    required int treeNumPrev,
  })  : lptSummaryId = d.Value(lptSummaryId),
        treeNum = d.Value(treeNum),
        treeNumPrev = d.Value(treeNumPrev);
  static d.Insertable<LtpTreeRenamedData> custom({
    d.Expression<int>? id,
    d.Expression<int>? lptSummaryId,
    d.Expression<int>? treeNum,
    d.Expression<int>? treeNumPrev,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (lptSummaryId != null) 'lpt_summary_id': lptSummaryId,
      if (treeNum != null) 'tree_num': treeNum,
      if (treeNumPrev != null) 'tree_num_prev': treeNumPrev,
    });
  }

  LtpTreeRenamedCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? lptSummaryId,
      d.Value<int>? treeNum,
      d.Value<int>? treeNumPrev}) {
    return LtpTreeRenamedCompanion(
      id: id ?? this.id,
      lptSummaryId: lptSummaryId ?? this.lptSummaryId,
      treeNum: treeNum ?? this.treeNum,
      treeNumPrev: treeNumPrev ?? this.treeNumPrev,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (lptSummaryId.present) {
      map['lpt_summary_id'] = d.Variable<int>(lptSummaryId.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (treeNumPrev.present) {
      map['tree_num_prev'] = d.Variable<int>(treeNumPrev.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LtpTreeRenamedCompanion(')
          ..write('id: $id, ')
          ..write('lptSummaryId: $lptSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('treeNumPrev: $treeNumPrev')
          ..write(')'))
        .toString();
  }
}

class $StpSummaryTable extends StpSummary
    with d.TableInfo<$StpSummaryTable, StpSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _plotTypeMeta =
      const d.VerificationMeta('plotType');
  @override
  late final d.GeneratedColumn<String> plotType = d.GeneratedColumn<String>(
      'plot_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nomPlotSizeMeta =
      const d.VerificationMeta('nomPlotSize');
  @override
  late final d.GeneratedColumn<double> nomPlotSize = d.GeneratedColumn<double>(
      'nom_plot_size', aliasedName, true,
      check: () => nomPlotSize.isBetweenValues(-1, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _measPlotSizeMeta =
      const d.VerificationMeta('measPlotSize');
  @override
  late final d.GeneratedColumn<double> measPlotSize = d.GeneratedColumn<double>(
      'meas_plot_size', aliasedName, true,
      check: () => measPlotSize.isBetweenValues(0.0005, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        measDate,
        plotType,
        nomPlotSize,
        measPlotSize,
        notAssessed,
        complete
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_summary';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<StpSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('plot_type')) {
      context.handle(_plotTypeMeta,
          plotType.isAcceptableOrUnknown(data['plot_type']!, _plotTypeMeta));
    } else if (isInserting) {
      context.missing(_plotTypeMeta);
    }
    if (data.containsKey('nom_plot_size')) {
      context.handle(
          _nomPlotSizeMeta,
          nomPlotSize.isAcceptableOrUnknown(
              data['nom_plot_size']!, _nomPlotSizeMeta));
    }
    if (data.containsKey('meas_plot_size')) {
      context.handle(
          _measPlotSizeMeta,
          measPlotSize.isAcceptableOrUnknown(
              data['meas_plot_size']!, _measPlotSizeMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  StpSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      plotType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}plot_type'])!,
      nomPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_plot_size']),
      measPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}meas_plot_size']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $StpSummaryTable createAlias(String alias) {
    return $StpSummaryTable(attachedDatabase, alias);
  }
}

class StpSummaryData extends d.DataClass
    implements d.Insertable<StpSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final String plotType;
  final double? nomPlotSize;
  final double? measPlotSize;
  final bool notAssessed;
  final bool complete;
  const StpSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      required this.plotType,
      this.nomPlotSize,
      this.measPlotSize,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['plot_type'] = d.Variable<String>(plotType);
    if (!nullToAbsent || nomPlotSize != null) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize);
    }
    if (!nullToAbsent || measPlotSize != null) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  StpSummaryCompanion toCompanion(bool nullToAbsent) {
    return StpSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      plotType: d.Value(plotType),
      nomPlotSize: nomPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomPlotSize),
      measPlotSize: measPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(measPlotSize),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory StpSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      plotType: serializer.fromJson<String>(json['plotType']),
      nomPlotSize: serializer.fromJson<double?>(json['nomPlotSize']),
      measPlotSize: serializer.fromJson<double?>(json['measPlotSize']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'plotType': serializer.toJson<String>(plotType),
      'nomPlotSize': serializer.toJson<double?>(nomPlotSize),
      'measPlotSize': serializer.toJson<double?>(measPlotSize),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  StpSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          String? plotType,
          d.Value<double?> nomPlotSize = const d.Value.absent(),
          d.Value<double?> measPlotSize = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      StpSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        plotType: plotType ?? this.plotType,
        nomPlotSize: nomPlotSize.present ? nomPlotSize.value : this.nomPlotSize,
        measPlotSize:
            measPlotSize.present ? measPlotSize.value : this.measPlotSize,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('StpSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, measDate, plotType, nomPlotSize,
      measPlotSize, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.plotType == this.plotType &&
          other.nomPlotSize == this.nomPlotSize &&
          other.measPlotSize == this.measPlotSize &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class StpSummaryCompanion extends d.UpdateCompanion<StpSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<String> plotType;
  final d.Value<double?> nomPlotSize;
  final d.Value<double?> measPlotSize;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const StpSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  StpSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    required String plotType,
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate),
        plotType = d.Value(plotType);
  static d.Insertable<StpSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<String>? plotType,
    d.Expression<double>? nomPlotSize,
    d.Expression<double>? measPlotSize,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (plotType != null) 'plot_type': plotType,
      if (nomPlotSize != null) 'nom_plot_size': nomPlotSize,
      if (measPlotSize != null) 'meas_plot_size': measPlotSize,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  StpSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<String>? plotType,
      d.Value<double?>? nomPlotSize,
      d.Value<double?>? measPlotSize,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return StpSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      plotType: plotType ?? this.plotType,
      nomPlotSize: nomPlotSize ?? this.nomPlotSize,
      measPlotSize: measPlotSize ?? this.measPlotSize,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (plotType.present) {
      map['plot_type'] = d.Variable<String>(plotType.value);
    }
    if (nomPlotSize.present) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize.value);
    }
    if (measPlotSize.present) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $StpSpeciesTable extends StpSpecies
    with d.TableInfo<$StpSpeciesTable, StpSpeciesData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StpSpeciesTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _stpSummaryIdMeta =
      const d.VerificationMeta('stpSummaryId');
  @override
  late final d.GeneratedColumn<int> stpSummaryId = d.GeneratedColumn<int>(
      'stp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES stp_summary (id)'));
  static const d.VerificationMeta _treeNumMeta =
      const d.VerificationMeta('treeNum');
  @override
  late final d.GeneratedColumn<int> treeNum = d.GeneratedColumn<int>(
      'tree_num', aliasedName, false,
      check: () => treeNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _origPlotAreaMeta =
      const d.VerificationMeta('origPlotArea');
  @override
  late final d.GeneratedColumn<String> origPlotArea = d.GeneratedColumn<String>(
      'orig_plot_area', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _genusMeta =
      const d.VerificationMeta('genus');
  @override
  late final d.GeneratedColumn<String> genus = d.GeneratedColumn<String>(
      'genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 4, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _speciesMeta =
      const d.VerificationMeta('species');
  @override
  late final d.GeneratedColumn<String> species = d.GeneratedColumn<String>(
      'species', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _varietyMeta =
      const d.VerificationMeta('variety');
  @override
  late final d.GeneratedColumn<String> variety = d.GeneratedColumn<String>(
      'variety', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _statusMeta =
      const d.VerificationMeta('status');
  @override
  late final d.GeneratedColumn<String> status = d.GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _dbhMeta = const d.VerificationMeta('dbh');
  @override
  late final d.GeneratedColumn<double> dbh = d.GeneratedColumn<double>(
      'dbh', aliasedName, false,
      check: () => dbh.isBetweenValues(-1, 8.9),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _heightMeta =
      const d.VerificationMeta('height');
  @override
  late final d.GeneratedColumn<double> height = d.GeneratedColumn<double>(
      'height', aliasedName, false,
      check: () => height.isBetweenValues(-1, 20),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _measHeightMeta =
      const d.VerificationMeta('measHeight');
  @override
  late final d.GeneratedColumn<String> measHeight = d.GeneratedColumn<String>(
      'meas_height', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stemConditionMeta =
      const d.VerificationMeta('stemCondition');
  @override
  late final d.GeneratedColumn<String> stemCondition =
      d.GeneratedColumn<String>('stem_condition', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 1, maxTextLength: 1),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        stpSummaryId,
        treeNum,
        origPlotArea,
        genus,
        species,
        variety,
        status,
        dbh,
        height,
        measHeight,
        stemCondition
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stp_species';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<StpSpeciesData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('stp_summary_id')) {
      context.handle(
          _stpSummaryIdMeta,
          stpSummaryId.isAcceptableOrUnknown(
              data['stp_summary_id']!, _stpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_stpSummaryIdMeta);
    }
    if (data.containsKey('tree_num')) {
      context.handle(_treeNumMeta,
          treeNum.isAcceptableOrUnknown(data['tree_num']!, _treeNumMeta));
    } else if (isInserting) {
      context.missing(_treeNumMeta);
    }
    if (data.containsKey('orig_plot_area')) {
      context.handle(
          _origPlotAreaMeta,
          origPlotArea.isAcceptableOrUnknown(
              data['orig_plot_area']!, _origPlotAreaMeta));
    } else if (isInserting) {
      context.missing(_origPlotAreaMeta);
    }
    if (data.containsKey('genus')) {
      context.handle(
          _genusMeta, genus.isAcceptableOrUnknown(data['genus']!, _genusMeta));
    } else if (isInserting) {
      context.missing(_genusMeta);
    }
    if (data.containsKey('species')) {
      context.handle(_speciesMeta,
          species.isAcceptableOrUnknown(data['species']!, _speciesMeta));
    } else if (isInserting) {
      context.missing(_speciesMeta);
    }
    if (data.containsKey('variety')) {
      context.handle(_varietyMeta,
          variety.isAcceptableOrUnknown(data['variety']!, _varietyMeta));
    } else if (isInserting) {
      context.missing(_varietyMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('dbh')) {
      context.handle(
          _dbhMeta, dbh.isAcceptableOrUnknown(data['dbh']!, _dbhMeta));
    } else if (isInserting) {
      context.missing(_dbhMeta);
    }
    if (data.containsKey('height')) {
      context.handle(_heightMeta,
          height.isAcceptableOrUnknown(data['height']!, _heightMeta));
    } else if (isInserting) {
      context.missing(_heightMeta);
    }
    if (data.containsKey('meas_height')) {
      context.handle(
          _measHeightMeta,
          measHeight.isAcceptableOrUnknown(
              data['meas_height']!, _measHeightMeta));
    } else if (isInserting) {
      context.missing(_measHeightMeta);
    }
    if (data.containsKey('stem_condition')) {
      context.handle(
          _stemConditionMeta,
          stemCondition.isAcceptableOrUnknown(
              data['stem_condition']!, _stemConditionMeta));
    } else if (isInserting) {
      context.missing(_stemConditionMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  StpSpeciesData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StpSpeciesData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      stpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}stp_summary_id'])!,
      treeNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tree_num'])!,
      origPlotArea: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}orig_plot_area'])!,
      genus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genus'])!,
      species: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}species'])!,
      variety: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}variety'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      dbh: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}dbh'])!,
      height: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}height'])!,
      measHeight: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}meas_height'])!,
      stemCondition: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stem_condition'])!,
    );
  }

  @override
  $StpSpeciesTable createAlias(String alias) {
    return $StpSpeciesTable(attachedDatabase, alias);
  }
}

class StpSpeciesData extends d.DataClass
    implements d.Insertable<StpSpeciesData> {
  final int id;
  final int stpSummaryId;
  final int treeNum;
  final String origPlotArea;
  final String genus;
  final String species;
  final String variety;
  final String status;
  final double dbh;
  final double height;
  final String measHeight;
  final String stemCondition;
  const StpSpeciesData(
      {required this.id,
      required this.stpSummaryId,
      required this.treeNum,
      required this.origPlotArea,
      required this.genus,
      required this.species,
      required this.variety,
      required this.status,
      required this.dbh,
      required this.height,
      required this.measHeight,
      required this.stemCondition});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['stp_summary_id'] = d.Variable<int>(stpSummaryId);
    map['tree_num'] = d.Variable<int>(treeNum);
    map['orig_plot_area'] = d.Variable<String>(origPlotArea);
    map['genus'] = d.Variable<String>(genus);
    map['species'] = d.Variable<String>(species);
    map['variety'] = d.Variable<String>(variety);
    map['status'] = d.Variable<String>(status);
    map['dbh'] = d.Variable<double>(dbh);
    map['height'] = d.Variable<double>(height);
    map['meas_height'] = d.Variable<String>(measHeight);
    map['stem_condition'] = d.Variable<String>(stemCondition);
    return map;
  }

  StpSpeciesCompanion toCompanion(bool nullToAbsent) {
    return StpSpeciesCompanion(
      id: d.Value(id),
      stpSummaryId: d.Value(stpSummaryId),
      treeNum: d.Value(treeNum),
      origPlotArea: d.Value(origPlotArea),
      genus: d.Value(genus),
      species: d.Value(species),
      variety: d.Value(variety),
      status: d.Value(status),
      dbh: d.Value(dbh),
      height: d.Value(height),
      measHeight: d.Value(measHeight),
      stemCondition: d.Value(stemCondition),
    );
  }

  factory StpSpeciesData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StpSpeciesData(
      id: serializer.fromJson<int>(json['id']),
      stpSummaryId: serializer.fromJson<int>(json['stpSummaryId']),
      treeNum: serializer.fromJson<int>(json['treeNum']),
      origPlotArea: serializer.fromJson<String>(json['origPlotArea']),
      genus: serializer.fromJson<String>(json['genus']),
      species: serializer.fromJson<String>(json['species']),
      variety: serializer.fromJson<String>(json['variety']),
      status: serializer.fromJson<String>(json['status']),
      dbh: serializer.fromJson<double>(json['dbh']),
      height: serializer.fromJson<double>(json['height']),
      measHeight: serializer.fromJson<String>(json['measHeight']),
      stemCondition: serializer.fromJson<String>(json['stemCondition']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'stpSummaryId': serializer.toJson<int>(stpSummaryId),
      'treeNum': serializer.toJson<int>(treeNum),
      'origPlotArea': serializer.toJson<String>(origPlotArea),
      'genus': serializer.toJson<String>(genus),
      'species': serializer.toJson<String>(species),
      'variety': serializer.toJson<String>(variety),
      'status': serializer.toJson<String>(status),
      'dbh': serializer.toJson<double>(dbh),
      'height': serializer.toJson<double>(height),
      'measHeight': serializer.toJson<String>(measHeight),
      'stemCondition': serializer.toJson<String>(stemCondition),
    };
  }

  StpSpeciesData copyWith(
          {int? id,
          int? stpSummaryId,
          int? treeNum,
          String? origPlotArea,
          String? genus,
          String? species,
          String? variety,
          String? status,
          double? dbh,
          double? height,
          String? measHeight,
          String? stemCondition}) =>
      StpSpeciesData(
        id: id ?? this.id,
        stpSummaryId: stpSummaryId ?? this.stpSummaryId,
        treeNum: treeNum ?? this.treeNum,
        origPlotArea: origPlotArea ?? this.origPlotArea,
        genus: genus ?? this.genus,
        species: species ?? this.species,
        variety: variety ?? this.variety,
        status: status ?? this.status,
        dbh: dbh ?? this.dbh,
        height: height ?? this.height,
        measHeight: measHeight ?? this.measHeight,
        stemCondition: stemCondition ?? this.stemCondition,
      );
  @override
  String toString() {
    return (StringBuffer('StpSpeciesData(')
          ..write('id: $id, ')
          ..write('stpSummaryId: $stpSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety, ')
          ..write('status: $status, ')
          ..write('dbh: $dbh, ')
          ..write('height: $height, ')
          ..write('measHeight: $measHeight, ')
          ..write('stemCondition: $stemCondition')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, stpSummaryId, treeNum, origPlotArea,
      genus, species, variety, status, dbh, height, measHeight, stemCondition);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StpSpeciesData &&
          other.id == this.id &&
          other.stpSummaryId == this.stpSummaryId &&
          other.treeNum == this.treeNum &&
          other.origPlotArea == this.origPlotArea &&
          other.genus == this.genus &&
          other.species == this.species &&
          other.variety == this.variety &&
          other.status == this.status &&
          other.dbh == this.dbh &&
          other.height == this.height &&
          other.measHeight == this.measHeight &&
          other.stemCondition == this.stemCondition);
}

class StpSpeciesCompanion extends d.UpdateCompanion<StpSpeciesData> {
  final d.Value<int> id;
  final d.Value<int> stpSummaryId;
  final d.Value<int> treeNum;
  final d.Value<String> origPlotArea;
  final d.Value<String> genus;
  final d.Value<String> species;
  final d.Value<String> variety;
  final d.Value<String> status;
  final d.Value<double> dbh;
  final d.Value<double> height;
  final d.Value<String> measHeight;
  final d.Value<String> stemCondition;
  const StpSpeciesCompanion({
    this.id = const d.Value.absent(),
    this.stpSummaryId = const d.Value.absent(),
    this.treeNum = const d.Value.absent(),
    this.origPlotArea = const d.Value.absent(),
    this.genus = const d.Value.absent(),
    this.species = const d.Value.absent(),
    this.variety = const d.Value.absent(),
    this.status = const d.Value.absent(),
    this.dbh = const d.Value.absent(),
    this.height = const d.Value.absent(),
    this.measHeight = const d.Value.absent(),
    this.stemCondition = const d.Value.absent(),
  });
  StpSpeciesCompanion.insert({
    this.id = const d.Value.absent(),
    required int stpSummaryId,
    required int treeNum,
    required String origPlotArea,
    required String genus,
    required String species,
    required String variety,
    required String status,
    required double dbh,
    required double height,
    required String measHeight,
    required String stemCondition,
  })  : stpSummaryId = d.Value(stpSummaryId),
        treeNum = d.Value(treeNum),
        origPlotArea = d.Value(origPlotArea),
        genus = d.Value(genus),
        species = d.Value(species),
        variety = d.Value(variety),
        status = d.Value(status),
        dbh = d.Value(dbh),
        height = d.Value(height),
        measHeight = d.Value(measHeight),
        stemCondition = d.Value(stemCondition);
  static d.Insertable<StpSpeciesData> custom({
    d.Expression<int>? id,
    d.Expression<int>? stpSummaryId,
    d.Expression<int>? treeNum,
    d.Expression<String>? origPlotArea,
    d.Expression<String>? genus,
    d.Expression<String>? species,
    d.Expression<String>? variety,
    d.Expression<String>? status,
    d.Expression<double>? dbh,
    d.Expression<double>? height,
    d.Expression<String>? measHeight,
    d.Expression<String>? stemCondition,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (stpSummaryId != null) 'stp_summary_id': stpSummaryId,
      if (treeNum != null) 'tree_num': treeNum,
      if (origPlotArea != null) 'orig_plot_area': origPlotArea,
      if (genus != null) 'genus': genus,
      if (species != null) 'species': species,
      if (variety != null) 'variety': variety,
      if (status != null) 'status': status,
      if (dbh != null) 'dbh': dbh,
      if (height != null) 'height': height,
      if (measHeight != null) 'meas_height': measHeight,
      if (stemCondition != null) 'stem_condition': stemCondition,
    });
  }

  StpSpeciesCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? stpSummaryId,
      d.Value<int>? treeNum,
      d.Value<String>? origPlotArea,
      d.Value<String>? genus,
      d.Value<String>? species,
      d.Value<String>? variety,
      d.Value<String>? status,
      d.Value<double>? dbh,
      d.Value<double>? height,
      d.Value<String>? measHeight,
      d.Value<String>? stemCondition}) {
    return StpSpeciesCompanion(
      id: id ?? this.id,
      stpSummaryId: stpSummaryId ?? this.stpSummaryId,
      treeNum: treeNum ?? this.treeNum,
      origPlotArea: origPlotArea ?? this.origPlotArea,
      genus: genus ?? this.genus,
      species: species ?? this.species,
      variety: variety ?? this.variety,
      status: status ?? this.status,
      dbh: dbh ?? this.dbh,
      height: height ?? this.height,
      measHeight: measHeight ?? this.measHeight,
      stemCondition: stemCondition ?? this.stemCondition,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (stpSummaryId.present) {
      map['stp_summary_id'] = d.Variable<int>(stpSummaryId.value);
    }
    if (treeNum.present) {
      map['tree_num'] = d.Variable<int>(treeNum.value);
    }
    if (origPlotArea.present) {
      map['orig_plot_area'] = d.Variable<String>(origPlotArea.value);
    }
    if (genus.present) {
      map['genus'] = d.Variable<String>(genus.value);
    }
    if (species.present) {
      map['species'] = d.Variable<String>(species.value);
    }
    if (variety.present) {
      map['variety'] = d.Variable<String>(variety.value);
    }
    if (status.present) {
      map['status'] = d.Variable<String>(status.value);
    }
    if (dbh.present) {
      map['dbh'] = d.Variable<double>(dbh.value);
    }
    if (height.present) {
      map['height'] = d.Variable<double>(height.value);
    }
    if (measHeight.present) {
      map['meas_height'] = d.Variable<String>(measHeight.value);
    }
    if (stemCondition.present) {
      map['stem_condition'] = d.Variable<String>(stemCondition.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StpSpeciesCompanion(')
          ..write('id: $id, ')
          ..write('stpSummaryId: $stpSummaryId, ')
          ..write('treeNum: $treeNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('genus: $genus, ')
          ..write('species: $species, ')
          ..write('variety: $variety, ')
          ..write('status: $status, ')
          ..write('dbh: $dbh, ')
          ..write('height: $height, ')
          ..write('measHeight: $measHeight, ')
          ..write('stemCondition: $stemCondition')
          ..write(')'))
        .toString();
  }
}

class $ShrubSummaryTable extends ShrubSummary
    with d.TableInfo<$ShrubSummaryTable, ShrubSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShrubSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _plotTypeMeta =
      const d.VerificationMeta('plotType');
  @override
  late final d.GeneratedColumn<String> plotType = d.GeneratedColumn<String>(
      'plot_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nomPlotSizeMeta =
      const d.VerificationMeta('nomPlotSize');
  @override
  late final d.GeneratedColumn<double> nomPlotSize = d.GeneratedColumn<double>(
      'nom_plot_size', aliasedName, true,
      check: () => nomPlotSize.isBetweenValues(-1, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _measPlotSizeMeta =
      const d.VerificationMeta('measPlotSize');
  @override
  late final d.GeneratedColumn<double> measPlotSize = d.GeneratedColumn<double>(
      'meas_plot_size', aliasedName, true,
      check: () => measPlotSize.isBetweenValues(0.0005, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        measDate,
        plotType,
        nomPlotSize,
        measPlotSize,
        notAssessed,
        complete
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shrub_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<ShrubSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('plot_type')) {
      context.handle(_plotTypeMeta,
          plotType.isAcceptableOrUnknown(data['plot_type']!, _plotTypeMeta));
    } else if (isInserting) {
      context.missing(_plotTypeMeta);
    }
    if (data.containsKey('nom_plot_size')) {
      context.handle(
          _nomPlotSizeMeta,
          nomPlotSize.isAcceptableOrUnknown(
              data['nom_plot_size']!, _nomPlotSizeMeta));
    }
    if (data.containsKey('meas_plot_size')) {
      context.handle(
          _measPlotSizeMeta,
          measPlotSize.isAcceptableOrUnknown(
              data['meas_plot_size']!, _measPlotSizeMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  ShrubSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShrubSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      plotType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}plot_type'])!,
      nomPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_plot_size']),
      measPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}meas_plot_size']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $ShrubSummaryTable createAlias(String alias) {
    return $ShrubSummaryTable(attachedDatabase, alias);
  }
}

class ShrubSummaryData extends d.DataClass
    implements d.Insertable<ShrubSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final String plotType;
  final double? nomPlotSize;
  final double? measPlotSize;
  final bool notAssessed;
  final bool complete;
  const ShrubSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      required this.plotType,
      this.nomPlotSize,
      this.measPlotSize,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['plot_type'] = d.Variable<String>(plotType);
    if (!nullToAbsent || nomPlotSize != null) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize);
    }
    if (!nullToAbsent || measPlotSize != null) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  ShrubSummaryCompanion toCompanion(bool nullToAbsent) {
    return ShrubSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      plotType: d.Value(plotType),
      nomPlotSize: nomPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomPlotSize),
      measPlotSize: measPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(measPlotSize),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory ShrubSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return ShrubSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      plotType: serializer.fromJson<String>(json['plotType']),
      nomPlotSize: serializer.fromJson<double?>(json['nomPlotSize']),
      measPlotSize: serializer.fromJson<double?>(json['measPlotSize']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'plotType': serializer.toJson<String>(plotType),
      'nomPlotSize': serializer.toJson<double?>(nomPlotSize),
      'measPlotSize': serializer.toJson<double?>(measPlotSize),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  ShrubSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          String? plotType,
          d.Value<double?> nomPlotSize = const d.Value.absent(),
          d.Value<double?> measPlotSize = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      ShrubSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        plotType: plotType ?? this.plotType,
        nomPlotSize: nomPlotSize.present ? nomPlotSize.value : this.nomPlotSize,
        measPlotSize:
            measPlotSize.present ? measPlotSize.value : this.measPlotSize,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('ShrubSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, measDate, plotType, nomPlotSize,
      measPlotSize, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShrubSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.plotType == this.plotType &&
          other.nomPlotSize == this.nomPlotSize &&
          other.measPlotSize == this.measPlotSize &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class ShrubSummaryCompanion extends d.UpdateCompanion<ShrubSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<String> plotType;
  final d.Value<double?> nomPlotSize;
  final d.Value<double?> measPlotSize;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const ShrubSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  ShrubSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    required String plotType,
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate),
        plotType = d.Value(plotType);
  static d.Insertable<ShrubSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<String>? plotType,
    d.Expression<double>? nomPlotSize,
    d.Expression<double>? measPlotSize,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (plotType != null) 'plot_type': plotType,
      if (nomPlotSize != null) 'nom_plot_size': nomPlotSize,
      if (measPlotSize != null) 'meas_plot_size': measPlotSize,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  ShrubSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<String>? plotType,
      d.Value<double?>? nomPlotSize,
      d.Value<double?>? measPlotSize,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return ShrubSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      plotType: plotType ?? this.plotType,
      nomPlotSize: nomPlotSize ?? this.nomPlotSize,
      measPlotSize: measPlotSize ?? this.measPlotSize,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (plotType.present) {
      map['plot_type'] = d.Variable<String>(plotType.value);
    }
    if (nomPlotSize.present) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize.value);
    }
    if (measPlotSize.present) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShrubSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $ShrubListEntryTable extends ShrubListEntry
    with d.TableInfo<$ShrubListEntryTable, ShrubListEntryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShrubListEntryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _shrubSummaryIdMeta =
      const d.VerificationMeta('shrubSummaryId');
  @override
  late final d.GeneratedColumn<int> shrubSummaryId = d.GeneratedColumn<int>(
      'shrub_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES shrub_summary (id)'));
  static const d.VerificationMeta _recordNumMeta =
      const d.VerificationMeta('recordNum');
  @override
  late final d.GeneratedColumn<int> recordNum = d.GeneratedColumn<int>(
      'record_num', aliasedName, false,
      check: () => recordNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _shrubGenusMeta =
      const d.VerificationMeta('shrubGenus');
  @override
  late final d.GeneratedColumn<String> shrubGenus = d.GeneratedColumn<String>(
      'shrub_genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _shrubSpeciesMeta =
      const d.VerificationMeta('shrubSpecies');
  @override
  late final d.GeneratedColumn<String> shrubSpecies = d.GeneratedColumn<String>(
      'shrub_species', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _shrubVarietyMeta =
      const d.VerificationMeta('shrubVariety');
  @override
  late final d.GeneratedColumn<String> shrubVariety = d.GeneratedColumn<String>(
      'shrub_variety', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _shrubStatusMeta =
      const d.VerificationMeta('shrubStatus');
  @override
  late final d.GeneratedColumn<String> shrubStatus = d.GeneratedColumn<String>(
      'shrub_status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _bdClassMeta =
      const d.VerificationMeta('bdClass');
  @override
  late final d.GeneratedColumn<int> bdClass = d.GeneratedColumn<int>(
      'bd_class', aliasedName, false,
      check: () => bdClass.isBetweenValues(0, 10) | bdClass.equals(-1),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _frequencyMeta =
      const d.VerificationMeta('frequency');
  @override
  late final d.GeneratedColumn<int> frequency = d.GeneratedColumn<int>(
      'frequency', aliasedName, false,
      check: () => frequency.isBetweenValues(1, 999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        shrubSummaryId,
        recordNum,
        shrubGenus,
        shrubSpecies,
        shrubVariety,
        shrubStatus,
        bdClass,
        frequency
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shrub_list_entry';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<ShrubListEntryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('shrub_summary_id')) {
      context.handle(
          _shrubSummaryIdMeta,
          shrubSummaryId.isAcceptableOrUnknown(
              data['shrub_summary_id']!, _shrubSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_shrubSummaryIdMeta);
    }
    if (data.containsKey('record_num')) {
      context.handle(_recordNumMeta,
          recordNum.isAcceptableOrUnknown(data['record_num']!, _recordNumMeta));
    } else if (isInserting) {
      context.missing(_recordNumMeta);
    }
    if (data.containsKey('shrub_genus')) {
      context.handle(
          _shrubGenusMeta,
          shrubGenus.isAcceptableOrUnknown(
              data['shrub_genus']!, _shrubGenusMeta));
    } else if (isInserting) {
      context.missing(_shrubGenusMeta);
    }
    if (data.containsKey('shrub_species')) {
      context.handle(
          _shrubSpeciesMeta,
          shrubSpecies.isAcceptableOrUnknown(
              data['shrub_species']!, _shrubSpeciesMeta));
    } else if (isInserting) {
      context.missing(_shrubSpeciesMeta);
    }
    if (data.containsKey('shrub_variety')) {
      context.handle(
          _shrubVarietyMeta,
          shrubVariety.isAcceptableOrUnknown(
              data['shrub_variety']!, _shrubVarietyMeta));
    } else if (isInserting) {
      context.missing(_shrubVarietyMeta);
    }
    if (data.containsKey('shrub_status')) {
      context.handle(
          _shrubStatusMeta,
          shrubStatus.isAcceptableOrUnknown(
              data['shrub_status']!, _shrubStatusMeta));
    } else if (isInserting) {
      context.missing(_shrubStatusMeta);
    }
    if (data.containsKey('bd_class')) {
      context.handle(_bdClassMeta,
          bdClass.isAcceptableOrUnknown(data['bd_class']!, _bdClassMeta));
    } else if (isInserting) {
      context.missing(_bdClassMeta);
    }
    if (data.containsKey('frequency')) {
      context.handle(_frequencyMeta,
          frequency.isAcceptableOrUnknown(data['frequency']!, _frequencyMeta));
    } else if (isInserting) {
      context.missing(_frequencyMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  ShrubListEntryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShrubListEntryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      shrubSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}shrub_summary_id'])!,
      recordNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}record_num'])!,
      shrubGenus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shrub_genus'])!,
      shrubSpecies: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shrub_species'])!,
      shrubVariety: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shrub_variety'])!,
      shrubStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shrub_status'])!,
      bdClass: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}bd_class'])!,
      frequency: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}frequency'])!,
    );
  }

  @override
  $ShrubListEntryTable createAlias(String alias) {
    return $ShrubListEntryTable(attachedDatabase, alias);
  }
}

class ShrubListEntryData extends d.DataClass
    implements d.Insertable<ShrubListEntryData> {
  final int id;
  final int shrubSummaryId;
  final int recordNum;
  final String shrubGenus;
  final String shrubSpecies;
  final String shrubVariety;
  final String shrubStatus;
  final int bdClass;
  final int frequency;
  const ShrubListEntryData(
      {required this.id,
      required this.shrubSummaryId,
      required this.recordNum,
      required this.shrubGenus,
      required this.shrubSpecies,
      required this.shrubVariety,
      required this.shrubStatus,
      required this.bdClass,
      required this.frequency});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['shrub_summary_id'] = d.Variable<int>(shrubSummaryId);
    map['record_num'] = d.Variable<int>(recordNum);
    map['shrub_genus'] = d.Variable<String>(shrubGenus);
    map['shrub_species'] = d.Variable<String>(shrubSpecies);
    map['shrub_variety'] = d.Variable<String>(shrubVariety);
    map['shrub_status'] = d.Variable<String>(shrubStatus);
    map['bd_class'] = d.Variable<int>(bdClass);
    map['frequency'] = d.Variable<int>(frequency);
    return map;
  }

  ShrubListEntryCompanion toCompanion(bool nullToAbsent) {
    return ShrubListEntryCompanion(
      id: d.Value(id),
      shrubSummaryId: d.Value(shrubSummaryId),
      recordNum: d.Value(recordNum),
      shrubGenus: d.Value(shrubGenus),
      shrubSpecies: d.Value(shrubSpecies),
      shrubVariety: d.Value(shrubVariety),
      shrubStatus: d.Value(shrubStatus),
      bdClass: d.Value(bdClass),
      frequency: d.Value(frequency),
    );
  }

  factory ShrubListEntryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return ShrubListEntryData(
      id: serializer.fromJson<int>(json['id']),
      shrubSummaryId: serializer.fromJson<int>(json['shrubSummaryId']),
      recordNum: serializer.fromJson<int>(json['recordNum']),
      shrubGenus: serializer.fromJson<String>(json['shrubGenus']),
      shrubSpecies: serializer.fromJson<String>(json['shrubSpecies']),
      shrubVariety: serializer.fromJson<String>(json['shrubVariety']),
      shrubStatus: serializer.fromJson<String>(json['shrubStatus']),
      bdClass: serializer.fromJson<int>(json['bdClass']),
      frequency: serializer.fromJson<int>(json['frequency']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'shrubSummaryId': serializer.toJson<int>(shrubSummaryId),
      'recordNum': serializer.toJson<int>(recordNum),
      'shrubGenus': serializer.toJson<String>(shrubGenus),
      'shrubSpecies': serializer.toJson<String>(shrubSpecies),
      'shrubVariety': serializer.toJson<String>(shrubVariety),
      'shrubStatus': serializer.toJson<String>(shrubStatus),
      'bdClass': serializer.toJson<int>(bdClass),
      'frequency': serializer.toJson<int>(frequency),
    };
  }

  ShrubListEntryData copyWith(
          {int? id,
          int? shrubSummaryId,
          int? recordNum,
          String? shrubGenus,
          String? shrubSpecies,
          String? shrubVariety,
          String? shrubStatus,
          int? bdClass,
          int? frequency}) =>
      ShrubListEntryData(
        id: id ?? this.id,
        shrubSummaryId: shrubSummaryId ?? this.shrubSummaryId,
        recordNum: recordNum ?? this.recordNum,
        shrubGenus: shrubGenus ?? this.shrubGenus,
        shrubSpecies: shrubSpecies ?? this.shrubSpecies,
        shrubVariety: shrubVariety ?? this.shrubVariety,
        shrubStatus: shrubStatus ?? this.shrubStatus,
        bdClass: bdClass ?? this.bdClass,
        frequency: frequency ?? this.frequency,
      );
  @override
  String toString() {
    return (StringBuffer('ShrubListEntryData(')
          ..write('id: $id, ')
          ..write('shrubSummaryId: $shrubSummaryId, ')
          ..write('recordNum: $recordNum, ')
          ..write('shrubGenus: $shrubGenus, ')
          ..write('shrubSpecies: $shrubSpecies, ')
          ..write('shrubVariety: $shrubVariety, ')
          ..write('shrubStatus: $shrubStatus, ')
          ..write('bdClass: $bdClass, ')
          ..write('frequency: $frequency')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, shrubSummaryId, recordNum, shrubGenus,
      shrubSpecies, shrubVariety, shrubStatus, bdClass, frequency);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShrubListEntryData &&
          other.id == this.id &&
          other.shrubSummaryId == this.shrubSummaryId &&
          other.recordNum == this.recordNum &&
          other.shrubGenus == this.shrubGenus &&
          other.shrubSpecies == this.shrubSpecies &&
          other.shrubVariety == this.shrubVariety &&
          other.shrubStatus == this.shrubStatus &&
          other.bdClass == this.bdClass &&
          other.frequency == this.frequency);
}

class ShrubListEntryCompanion extends d.UpdateCompanion<ShrubListEntryData> {
  final d.Value<int> id;
  final d.Value<int> shrubSummaryId;
  final d.Value<int> recordNum;
  final d.Value<String> shrubGenus;
  final d.Value<String> shrubSpecies;
  final d.Value<String> shrubVariety;
  final d.Value<String> shrubStatus;
  final d.Value<int> bdClass;
  final d.Value<int> frequency;
  const ShrubListEntryCompanion({
    this.id = const d.Value.absent(),
    this.shrubSummaryId = const d.Value.absent(),
    this.recordNum = const d.Value.absent(),
    this.shrubGenus = const d.Value.absent(),
    this.shrubSpecies = const d.Value.absent(),
    this.shrubVariety = const d.Value.absent(),
    this.shrubStatus = const d.Value.absent(),
    this.bdClass = const d.Value.absent(),
    this.frequency = const d.Value.absent(),
  });
  ShrubListEntryCompanion.insert({
    this.id = const d.Value.absent(),
    required int shrubSummaryId,
    required int recordNum,
    required String shrubGenus,
    required String shrubSpecies,
    required String shrubVariety,
    required String shrubStatus,
    required int bdClass,
    required int frequency,
  })  : shrubSummaryId = d.Value(shrubSummaryId),
        recordNum = d.Value(recordNum),
        shrubGenus = d.Value(shrubGenus),
        shrubSpecies = d.Value(shrubSpecies),
        shrubVariety = d.Value(shrubVariety),
        shrubStatus = d.Value(shrubStatus),
        bdClass = d.Value(bdClass),
        frequency = d.Value(frequency);
  static d.Insertable<ShrubListEntryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? shrubSummaryId,
    d.Expression<int>? recordNum,
    d.Expression<String>? shrubGenus,
    d.Expression<String>? shrubSpecies,
    d.Expression<String>? shrubVariety,
    d.Expression<String>? shrubStatus,
    d.Expression<int>? bdClass,
    d.Expression<int>? frequency,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (shrubSummaryId != null) 'shrub_summary_id': shrubSummaryId,
      if (recordNum != null) 'record_num': recordNum,
      if (shrubGenus != null) 'shrub_genus': shrubGenus,
      if (shrubSpecies != null) 'shrub_species': shrubSpecies,
      if (shrubVariety != null) 'shrub_variety': shrubVariety,
      if (shrubStatus != null) 'shrub_status': shrubStatus,
      if (bdClass != null) 'bd_class': bdClass,
      if (frequency != null) 'frequency': frequency,
    });
  }

  ShrubListEntryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? shrubSummaryId,
      d.Value<int>? recordNum,
      d.Value<String>? shrubGenus,
      d.Value<String>? shrubSpecies,
      d.Value<String>? shrubVariety,
      d.Value<String>? shrubStatus,
      d.Value<int>? bdClass,
      d.Value<int>? frequency}) {
    return ShrubListEntryCompanion(
      id: id ?? this.id,
      shrubSummaryId: shrubSummaryId ?? this.shrubSummaryId,
      recordNum: recordNum ?? this.recordNum,
      shrubGenus: shrubGenus ?? this.shrubGenus,
      shrubSpecies: shrubSpecies ?? this.shrubSpecies,
      shrubVariety: shrubVariety ?? this.shrubVariety,
      shrubStatus: shrubStatus ?? this.shrubStatus,
      bdClass: bdClass ?? this.bdClass,
      frequency: frequency ?? this.frequency,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (shrubSummaryId.present) {
      map['shrub_summary_id'] = d.Variable<int>(shrubSummaryId.value);
    }
    if (recordNum.present) {
      map['record_num'] = d.Variable<int>(recordNum.value);
    }
    if (shrubGenus.present) {
      map['shrub_genus'] = d.Variable<String>(shrubGenus.value);
    }
    if (shrubSpecies.present) {
      map['shrub_species'] = d.Variable<String>(shrubSpecies.value);
    }
    if (shrubVariety.present) {
      map['shrub_variety'] = d.Variable<String>(shrubVariety.value);
    }
    if (shrubStatus.present) {
      map['shrub_status'] = d.Variable<String>(shrubStatus.value);
    }
    if (bdClass.present) {
      map['bd_class'] = d.Variable<int>(bdClass.value);
    }
    if (frequency.present) {
      map['frequency'] = d.Variable<int>(frequency.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShrubListEntryCompanion(')
          ..write('id: $id, ')
          ..write('shrubSummaryId: $shrubSummaryId, ')
          ..write('recordNum: $recordNum, ')
          ..write('shrubGenus: $shrubGenus, ')
          ..write('shrubSpecies: $shrubSpecies, ')
          ..write('shrubVariety: $shrubVariety, ')
          ..write('shrubStatus: $shrubStatus, ')
          ..write('bdClass: $bdClass, ')
          ..write('frequency: $frequency')
          ..write(')'))
        .toString();
  }
}

class $StumpSummaryTable extends StumpSummary
    with d.TableInfo<$StumpSummaryTable, StumpSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StumpSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _plotTypeMeta =
      const d.VerificationMeta('plotType');
  @override
  late final d.GeneratedColumn<String> plotType = d.GeneratedColumn<String>(
      'plot_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _nomPlotSizeMeta =
      const d.VerificationMeta('nomPlotSize');
  @override
  late final d.GeneratedColumn<double> nomPlotSize = d.GeneratedColumn<double>(
      'nom_plot_size', aliasedName, true,
      check: () => nomPlotSize.isBetweenValues(-1, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _measPlotSizeMeta =
      const d.VerificationMeta('measPlotSize');
  @override
  late final d.GeneratedColumn<double> measPlotSize = d.GeneratedColumn<double>(
      'meas_plot_size', aliasedName, true,
      check: () => measPlotSize.isBetweenValues(0.0005, 0.04),
      type: DriftSqlType.double,
      requiredDuringInsert: false);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        surveyId,
        measDate,
        plotType,
        nomPlotSize,
        measPlotSize,
        notAssessed,
        complete
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stump_summary';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<StumpSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('plot_type')) {
      context.handle(_plotTypeMeta,
          plotType.isAcceptableOrUnknown(data['plot_type']!, _plotTypeMeta));
    } else if (isInserting) {
      context.missing(_plotTypeMeta);
    }
    if (data.containsKey('nom_plot_size')) {
      context.handle(
          _nomPlotSizeMeta,
          nomPlotSize.isAcceptableOrUnknown(
              data['nom_plot_size']!, _nomPlotSizeMeta));
    }
    if (data.containsKey('meas_plot_size')) {
      context.handle(
          _measPlotSizeMeta,
          measPlotSize.isAcceptableOrUnknown(
              data['meas_plot_size']!, _measPlotSizeMeta));
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  StumpSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StumpSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      plotType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}plot_type'])!,
      nomPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}nom_plot_size']),
      measPlotSize: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}meas_plot_size']),
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $StumpSummaryTable createAlias(String alias) {
    return $StumpSummaryTable(attachedDatabase, alias);
  }
}

class StumpSummaryData extends d.DataClass
    implements d.Insertable<StumpSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final String plotType;
  final double? nomPlotSize;
  final double? measPlotSize;
  final bool notAssessed;
  final bool complete;
  const StumpSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      required this.plotType,
      this.nomPlotSize,
      this.measPlotSize,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['plot_type'] = d.Variable<String>(plotType);
    if (!nullToAbsent || nomPlotSize != null) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize);
    }
    if (!nullToAbsent || measPlotSize != null) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize);
    }
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  StumpSummaryCompanion toCompanion(bool nullToAbsent) {
    return StumpSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      plotType: d.Value(plotType),
      nomPlotSize: nomPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(nomPlotSize),
      measPlotSize: measPlotSize == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(measPlotSize),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory StumpSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StumpSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      plotType: serializer.fromJson<String>(json['plotType']),
      nomPlotSize: serializer.fromJson<double?>(json['nomPlotSize']),
      measPlotSize: serializer.fromJson<double?>(json['measPlotSize']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'plotType': serializer.toJson<String>(plotType),
      'nomPlotSize': serializer.toJson<double?>(nomPlotSize),
      'measPlotSize': serializer.toJson<double?>(measPlotSize),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  StumpSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          String? plotType,
          d.Value<double?> nomPlotSize = const d.Value.absent(),
          d.Value<double?> measPlotSize = const d.Value.absent(),
          bool? notAssessed,
          bool? complete}) =>
      StumpSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        plotType: plotType ?? this.plotType,
        nomPlotSize: nomPlotSize.present ? nomPlotSize.value : this.nomPlotSize,
        measPlotSize:
            measPlotSize.present ? measPlotSize.value : this.measPlotSize,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('StumpSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, surveyId, measDate, plotType, nomPlotSize,
      measPlotSize, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StumpSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.plotType == this.plotType &&
          other.nomPlotSize == this.nomPlotSize &&
          other.measPlotSize == this.measPlotSize &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class StumpSummaryCompanion extends d.UpdateCompanion<StumpSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<String> plotType;
  final d.Value<double?> nomPlotSize;
  final d.Value<double?> measPlotSize;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const StumpSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.plotType = const d.Value.absent(),
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  StumpSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    required String plotType,
    this.nomPlotSize = const d.Value.absent(),
    this.measPlotSize = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate),
        plotType = d.Value(plotType);
  static d.Insertable<StumpSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<String>? plotType,
    d.Expression<double>? nomPlotSize,
    d.Expression<double>? measPlotSize,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (plotType != null) 'plot_type': plotType,
      if (nomPlotSize != null) 'nom_plot_size': nomPlotSize,
      if (measPlotSize != null) 'meas_plot_size': measPlotSize,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  StumpSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<String>? plotType,
      d.Value<double?>? nomPlotSize,
      d.Value<double?>? measPlotSize,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return StumpSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      plotType: plotType ?? this.plotType,
      nomPlotSize: nomPlotSize ?? this.nomPlotSize,
      measPlotSize: measPlotSize ?? this.measPlotSize,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (plotType.present) {
      map['plot_type'] = d.Variable<String>(plotType.value);
    }
    if (nomPlotSize.present) {
      map['nom_plot_size'] = d.Variable<double>(nomPlotSize.value);
    }
    if (measPlotSize.present) {
      map['meas_plot_size'] = d.Variable<double>(measPlotSize.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StumpSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('plotType: $plotType, ')
          ..write('nomPlotSize: $nomPlotSize, ')
          ..write('measPlotSize: $measPlotSize, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $StumpEntryTable extends StumpEntry
    with d.TableInfo<$StumpEntryTable, StumpEntryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StumpEntryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _stumpSummaryIdMeta =
      const d.VerificationMeta('stumpSummaryId');
  @override
  late final d.GeneratedColumn<int> stumpSummaryId = d.GeneratedColumn<int>(
      'stump_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES stump_summary (id)'));
  static const d.VerificationMeta _stumpNumMeta =
      const d.VerificationMeta('stumpNum');
  @override
  late final d.GeneratedColumn<int> stumpNum = d.GeneratedColumn<int>(
      'stump_num', aliasedName, false,
      check: () => stumpNum.isBetweenValues(1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _origPlotAreaMeta =
      const d.VerificationMeta('origPlotArea');
  @override
  late final d.GeneratedColumn<String> origPlotArea = d.GeneratedColumn<String>(
      'orig_plot_area', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _stumpGenusMeta =
      const d.VerificationMeta('stumpGenus');
  @override
  late final d.GeneratedColumn<String> stumpGenus = d.GeneratedColumn<String>(
      'stump_genus', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stumpSpeciesMeta =
      const d.VerificationMeta('stumpSpecies');
  @override
  late final d.GeneratedColumn<String> stumpSpecies = d.GeneratedColumn<String>(
      'stump_species', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stumpVarietyMeta =
      const d.VerificationMeta('stumpVariety');
  @override
  late final d.GeneratedColumn<String> stumpVariety = d.GeneratedColumn<String>(
      'stump_variety', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const d.VerificationMeta _stumpDibMeta =
      const d.VerificationMeta('stumpDib');
  @override
  late final d.GeneratedColumn<double> stumpDib = d.GeneratedColumn<double>(
      'stump_dib', aliasedName, false,
      check: () => stumpDib.isBetweenValues(4.0, 999.9) | stumpDib.equals(-1.0),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stumpDiameterMeta =
      const d.VerificationMeta('stumpDiameter');
  @override
  late final d.GeneratedColumn<double> stumpDiameter =
      d.GeneratedColumn<double>('stump_diameter', aliasedName, false,
          check: () =>
              stumpDiameter.isBetweenValues(4.0, 999.9) |
              stumpDiameter.equals(-1.0),
          type: DriftSqlType.double,
          requiredDuringInsert: true);
  static const d.VerificationMeta _stumpDecayMeta =
      const d.VerificationMeta('stumpDecay');
  @override
  late final d.GeneratedColumn<int> stumpDecay = d.GeneratedColumn<int>(
      'stump_decay', aliasedName, false,
      check: () => stumpDecay.isBetweenValues(-1, 5),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _stumpLengthMeta =
      const d.VerificationMeta('stumpLength');
  @override
  late final d.GeneratedColumn<double> stumpLength = d.GeneratedColumn<double>(
      'stump_length', aliasedName, false,
      check: () =>
          stumpLength.isBetweenValues(0.01, 1.29) | stumpLength.equals(-1.0),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        stumpSummaryId,
        stumpNum,
        origPlotArea,
        stumpGenus,
        stumpSpecies,
        stumpVariety,
        stumpDib,
        stumpDiameter,
        stumpDecay,
        stumpLength
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stump_entry';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<StumpEntryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('stump_summary_id')) {
      context.handle(
          _stumpSummaryIdMeta,
          stumpSummaryId.isAcceptableOrUnknown(
              data['stump_summary_id']!, _stumpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_stumpSummaryIdMeta);
    }
    if (data.containsKey('stump_num')) {
      context.handle(_stumpNumMeta,
          stumpNum.isAcceptableOrUnknown(data['stump_num']!, _stumpNumMeta));
    } else if (isInserting) {
      context.missing(_stumpNumMeta);
    }
    if (data.containsKey('orig_plot_area')) {
      context.handle(
          _origPlotAreaMeta,
          origPlotArea.isAcceptableOrUnknown(
              data['orig_plot_area']!, _origPlotAreaMeta));
    } else if (isInserting) {
      context.missing(_origPlotAreaMeta);
    }
    if (data.containsKey('stump_genus')) {
      context.handle(
          _stumpGenusMeta,
          stumpGenus.isAcceptableOrUnknown(
              data['stump_genus']!, _stumpGenusMeta));
    } else if (isInserting) {
      context.missing(_stumpGenusMeta);
    }
    if (data.containsKey('stump_species')) {
      context.handle(
          _stumpSpeciesMeta,
          stumpSpecies.isAcceptableOrUnknown(
              data['stump_species']!, _stumpSpeciesMeta));
    } else if (isInserting) {
      context.missing(_stumpSpeciesMeta);
    }
    if (data.containsKey('stump_variety')) {
      context.handle(
          _stumpVarietyMeta,
          stumpVariety.isAcceptableOrUnknown(
              data['stump_variety']!, _stumpVarietyMeta));
    } else if (isInserting) {
      context.missing(_stumpVarietyMeta);
    }
    if (data.containsKey('stump_dib')) {
      context.handle(_stumpDibMeta,
          stumpDib.isAcceptableOrUnknown(data['stump_dib']!, _stumpDibMeta));
    } else if (isInserting) {
      context.missing(_stumpDibMeta);
    }
    if (data.containsKey('stump_diameter')) {
      context.handle(
          _stumpDiameterMeta,
          stumpDiameter.isAcceptableOrUnknown(
              data['stump_diameter']!, _stumpDiameterMeta));
    } else if (isInserting) {
      context.missing(_stumpDiameterMeta);
    }
    if (data.containsKey('stump_decay')) {
      context.handle(
          _stumpDecayMeta,
          stumpDecay.isAcceptableOrUnknown(
              data['stump_decay']!, _stumpDecayMeta));
    } else if (isInserting) {
      context.missing(_stumpDecayMeta);
    }
    if (data.containsKey('stump_length')) {
      context.handle(
          _stumpLengthMeta,
          stumpLength.isAcceptableOrUnknown(
              data['stump_length']!, _stumpLengthMeta));
    } else if (isInserting) {
      context.missing(_stumpLengthMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  StumpEntryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StumpEntryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      stumpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}stump_summary_id'])!,
      stumpNum: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}stump_num'])!,
      origPlotArea: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}orig_plot_area'])!,
      stumpGenus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stump_genus'])!,
      stumpSpecies: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stump_species'])!,
      stumpVariety: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stump_variety'])!,
      stumpDib: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stump_dib'])!,
      stumpDiameter: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stump_diameter'])!,
      stumpDecay: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}stump_decay'])!,
      stumpLength: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}stump_length'])!,
    );
  }

  @override
  $StumpEntryTable createAlias(String alias) {
    return $StumpEntryTable(attachedDatabase, alias);
  }
}

class StumpEntryData extends d.DataClass
    implements d.Insertable<StumpEntryData> {
  final int id;
  final int stumpSummaryId;
  final int stumpNum;
  final String origPlotArea;
  final String stumpGenus;
  final String stumpSpecies;
  final String stumpVariety;
  final double stumpDib;
  final double stumpDiameter;
  final int stumpDecay;
  final double stumpLength;
  const StumpEntryData(
      {required this.id,
      required this.stumpSummaryId,
      required this.stumpNum,
      required this.origPlotArea,
      required this.stumpGenus,
      required this.stumpSpecies,
      required this.stumpVariety,
      required this.stumpDib,
      required this.stumpDiameter,
      required this.stumpDecay,
      required this.stumpLength});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['stump_summary_id'] = d.Variable<int>(stumpSummaryId);
    map['stump_num'] = d.Variable<int>(stumpNum);
    map['orig_plot_area'] = d.Variable<String>(origPlotArea);
    map['stump_genus'] = d.Variable<String>(stumpGenus);
    map['stump_species'] = d.Variable<String>(stumpSpecies);
    map['stump_variety'] = d.Variable<String>(stumpVariety);
    map['stump_dib'] = d.Variable<double>(stumpDib);
    map['stump_diameter'] = d.Variable<double>(stumpDiameter);
    map['stump_decay'] = d.Variable<int>(stumpDecay);
    map['stump_length'] = d.Variable<double>(stumpLength);
    return map;
  }

  StumpEntryCompanion toCompanion(bool nullToAbsent) {
    return StumpEntryCompanion(
      id: d.Value(id),
      stumpSummaryId: d.Value(stumpSummaryId),
      stumpNum: d.Value(stumpNum),
      origPlotArea: d.Value(origPlotArea),
      stumpGenus: d.Value(stumpGenus),
      stumpSpecies: d.Value(stumpSpecies),
      stumpVariety: d.Value(stumpVariety),
      stumpDib: d.Value(stumpDib),
      stumpDiameter: d.Value(stumpDiameter),
      stumpDecay: d.Value(stumpDecay),
      stumpLength: d.Value(stumpLength),
    );
  }

  factory StumpEntryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return StumpEntryData(
      id: serializer.fromJson<int>(json['id']),
      stumpSummaryId: serializer.fromJson<int>(json['stumpSummaryId']),
      stumpNum: serializer.fromJson<int>(json['stumpNum']),
      origPlotArea: serializer.fromJson<String>(json['origPlotArea']),
      stumpGenus: serializer.fromJson<String>(json['stumpGenus']),
      stumpSpecies: serializer.fromJson<String>(json['stumpSpecies']),
      stumpVariety: serializer.fromJson<String>(json['stumpVariety']),
      stumpDib: serializer.fromJson<double>(json['stumpDib']),
      stumpDiameter: serializer.fromJson<double>(json['stumpDiameter']),
      stumpDecay: serializer.fromJson<int>(json['stumpDecay']),
      stumpLength: serializer.fromJson<double>(json['stumpLength']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'stumpSummaryId': serializer.toJson<int>(stumpSummaryId),
      'stumpNum': serializer.toJson<int>(stumpNum),
      'origPlotArea': serializer.toJson<String>(origPlotArea),
      'stumpGenus': serializer.toJson<String>(stumpGenus),
      'stumpSpecies': serializer.toJson<String>(stumpSpecies),
      'stumpVariety': serializer.toJson<String>(stumpVariety),
      'stumpDib': serializer.toJson<double>(stumpDib),
      'stumpDiameter': serializer.toJson<double>(stumpDiameter),
      'stumpDecay': serializer.toJson<int>(stumpDecay),
      'stumpLength': serializer.toJson<double>(stumpLength),
    };
  }

  StumpEntryData copyWith(
          {int? id,
          int? stumpSummaryId,
          int? stumpNum,
          String? origPlotArea,
          String? stumpGenus,
          String? stumpSpecies,
          String? stumpVariety,
          double? stumpDib,
          double? stumpDiameter,
          int? stumpDecay,
          double? stumpLength}) =>
      StumpEntryData(
        id: id ?? this.id,
        stumpSummaryId: stumpSummaryId ?? this.stumpSummaryId,
        stumpNum: stumpNum ?? this.stumpNum,
        origPlotArea: origPlotArea ?? this.origPlotArea,
        stumpGenus: stumpGenus ?? this.stumpGenus,
        stumpSpecies: stumpSpecies ?? this.stumpSpecies,
        stumpVariety: stumpVariety ?? this.stumpVariety,
        stumpDib: stumpDib ?? this.stumpDib,
        stumpDiameter: stumpDiameter ?? this.stumpDiameter,
        stumpDecay: stumpDecay ?? this.stumpDecay,
        stumpLength: stumpLength ?? this.stumpLength,
      );
  @override
  String toString() {
    return (StringBuffer('StumpEntryData(')
          ..write('id: $id, ')
          ..write('stumpSummaryId: $stumpSummaryId, ')
          ..write('stumpNum: $stumpNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('stumpGenus: $stumpGenus, ')
          ..write('stumpSpecies: $stumpSpecies, ')
          ..write('stumpVariety: $stumpVariety, ')
          ..write('stumpDib: $stumpDib, ')
          ..write('stumpDiameter: $stumpDiameter, ')
          ..write('stumpDecay: $stumpDecay, ')
          ..write('stumpLength: $stumpLength')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      stumpSummaryId,
      stumpNum,
      origPlotArea,
      stumpGenus,
      stumpSpecies,
      stumpVariety,
      stumpDib,
      stumpDiameter,
      stumpDecay,
      stumpLength);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StumpEntryData &&
          other.id == this.id &&
          other.stumpSummaryId == this.stumpSummaryId &&
          other.stumpNum == this.stumpNum &&
          other.origPlotArea == this.origPlotArea &&
          other.stumpGenus == this.stumpGenus &&
          other.stumpSpecies == this.stumpSpecies &&
          other.stumpVariety == this.stumpVariety &&
          other.stumpDib == this.stumpDib &&
          other.stumpDiameter == this.stumpDiameter &&
          other.stumpDecay == this.stumpDecay &&
          other.stumpLength == this.stumpLength);
}

class StumpEntryCompanion extends d.UpdateCompanion<StumpEntryData> {
  final d.Value<int> id;
  final d.Value<int> stumpSummaryId;
  final d.Value<int> stumpNum;
  final d.Value<String> origPlotArea;
  final d.Value<String> stumpGenus;
  final d.Value<String> stumpSpecies;
  final d.Value<String> stumpVariety;
  final d.Value<double> stumpDib;
  final d.Value<double> stumpDiameter;
  final d.Value<int> stumpDecay;
  final d.Value<double> stumpLength;
  const StumpEntryCompanion({
    this.id = const d.Value.absent(),
    this.stumpSummaryId = const d.Value.absent(),
    this.stumpNum = const d.Value.absent(),
    this.origPlotArea = const d.Value.absent(),
    this.stumpGenus = const d.Value.absent(),
    this.stumpSpecies = const d.Value.absent(),
    this.stumpVariety = const d.Value.absent(),
    this.stumpDib = const d.Value.absent(),
    this.stumpDiameter = const d.Value.absent(),
    this.stumpDecay = const d.Value.absent(),
    this.stumpLength = const d.Value.absent(),
  });
  StumpEntryCompanion.insert({
    this.id = const d.Value.absent(),
    required int stumpSummaryId,
    required int stumpNum,
    required String origPlotArea,
    required String stumpGenus,
    required String stumpSpecies,
    required String stumpVariety,
    required double stumpDib,
    required double stumpDiameter,
    required int stumpDecay,
    required double stumpLength,
  })  : stumpSummaryId = d.Value(stumpSummaryId),
        stumpNum = d.Value(stumpNum),
        origPlotArea = d.Value(origPlotArea),
        stumpGenus = d.Value(stumpGenus),
        stumpSpecies = d.Value(stumpSpecies),
        stumpVariety = d.Value(stumpVariety),
        stumpDib = d.Value(stumpDib),
        stumpDiameter = d.Value(stumpDiameter),
        stumpDecay = d.Value(stumpDecay),
        stumpLength = d.Value(stumpLength);
  static d.Insertable<StumpEntryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? stumpSummaryId,
    d.Expression<int>? stumpNum,
    d.Expression<String>? origPlotArea,
    d.Expression<String>? stumpGenus,
    d.Expression<String>? stumpSpecies,
    d.Expression<String>? stumpVariety,
    d.Expression<double>? stumpDib,
    d.Expression<double>? stumpDiameter,
    d.Expression<int>? stumpDecay,
    d.Expression<double>? stumpLength,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (stumpSummaryId != null) 'stump_summary_id': stumpSummaryId,
      if (stumpNum != null) 'stump_num': stumpNum,
      if (origPlotArea != null) 'orig_plot_area': origPlotArea,
      if (stumpGenus != null) 'stump_genus': stumpGenus,
      if (stumpSpecies != null) 'stump_species': stumpSpecies,
      if (stumpVariety != null) 'stump_variety': stumpVariety,
      if (stumpDib != null) 'stump_dib': stumpDib,
      if (stumpDiameter != null) 'stump_diameter': stumpDiameter,
      if (stumpDecay != null) 'stump_decay': stumpDecay,
      if (stumpLength != null) 'stump_length': stumpLength,
    });
  }

  StumpEntryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? stumpSummaryId,
      d.Value<int>? stumpNum,
      d.Value<String>? origPlotArea,
      d.Value<String>? stumpGenus,
      d.Value<String>? stumpSpecies,
      d.Value<String>? stumpVariety,
      d.Value<double>? stumpDib,
      d.Value<double>? stumpDiameter,
      d.Value<int>? stumpDecay,
      d.Value<double>? stumpLength}) {
    return StumpEntryCompanion(
      id: id ?? this.id,
      stumpSummaryId: stumpSummaryId ?? this.stumpSummaryId,
      stumpNum: stumpNum ?? this.stumpNum,
      origPlotArea: origPlotArea ?? this.origPlotArea,
      stumpGenus: stumpGenus ?? this.stumpGenus,
      stumpSpecies: stumpSpecies ?? this.stumpSpecies,
      stumpVariety: stumpVariety ?? this.stumpVariety,
      stumpDib: stumpDib ?? this.stumpDib,
      stumpDiameter: stumpDiameter ?? this.stumpDiameter,
      stumpDecay: stumpDecay ?? this.stumpDecay,
      stumpLength: stumpLength ?? this.stumpLength,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (stumpSummaryId.present) {
      map['stump_summary_id'] = d.Variable<int>(stumpSummaryId.value);
    }
    if (stumpNum.present) {
      map['stump_num'] = d.Variable<int>(stumpNum.value);
    }
    if (origPlotArea.present) {
      map['orig_plot_area'] = d.Variable<String>(origPlotArea.value);
    }
    if (stumpGenus.present) {
      map['stump_genus'] = d.Variable<String>(stumpGenus.value);
    }
    if (stumpSpecies.present) {
      map['stump_species'] = d.Variable<String>(stumpSpecies.value);
    }
    if (stumpVariety.present) {
      map['stump_variety'] = d.Variable<String>(stumpVariety.value);
    }
    if (stumpDib.present) {
      map['stump_dib'] = d.Variable<double>(stumpDib.value);
    }
    if (stumpDiameter.present) {
      map['stump_diameter'] = d.Variable<double>(stumpDiameter.value);
    }
    if (stumpDecay.present) {
      map['stump_decay'] = d.Variable<int>(stumpDecay.value);
    }
    if (stumpLength.present) {
      map['stump_length'] = d.Variable<double>(stumpLength.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StumpEntryCompanion(')
          ..write('id: $id, ')
          ..write('stumpSummaryId: $stumpSummaryId, ')
          ..write('stumpNum: $stumpNum, ')
          ..write('origPlotArea: $origPlotArea, ')
          ..write('stumpGenus: $stumpGenus, ')
          ..write('stumpSpecies: $stumpSpecies, ')
          ..write('stumpVariety: $stumpVariety, ')
          ..write('stumpDib: $stumpDib, ')
          ..write('stumpDiameter: $stumpDiameter, ')
          ..write('stumpDecay: $stumpDecay, ')
          ..write('stumpLength: $stumpLength')
          ..write(')'))
        .toString();
  }
}

class $GpSummaryTable extends GpSummary
    with d.TableInfo<$GpSummaryTable, GpSummaryData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSummaryTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _surveyIdMeta =
      const d.VerificationMeta('surveyId');
  @override
  late final d.GeneratedColumn<int> surveyId = d.GeneratedColumn<int>(
      'survey_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'UNIQUE REFERENCES survey_headers (id)'));
  static const d.VerificationMeta _measDateMeta =
      const d.VerificationMeta('measDate');
  @override
  late final d.GeneratedColumn<DateTime> measDate = d.GeneratedColumn<DateTime>(
      'meas_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const d.VerificationMeta _notAssessedMeta =
      const d.VerificationMeta('notAssessed');
  @override
  late final d.GeneratedColumn<bool> notAssessed = d.GeneratedColumn<bool>(
      'not_assessed', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("not_assessed" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  static const d.VerificationMeta _completeMeta =
      const d.VerificationMeta('complete');
  @override
  late final d.GeneratedColumn<bool> complete = d.GeneratedColumn<bool>(
      'complete', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("complete" IN (0, 1))'),
      defaultValue: const d.Constant(false));
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, surveyId, measDate, notAssessed, complete];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_summary';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<GpSummaryData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('survey_id')) {
      context.handle(_surveyIdMeta,
          surveyId.isAcceptableOrUnknown(data['survey_id']!, _surveyIdMeta));
    } else if (isInserting) {
      context.missing(_surveyIdMeta);
    }
    if (data.containsKey('meas_date')) {
      context.handle(_measDateMeta,
          measDate.isAcceptableOrUnknown(data['meas_date']!, _measDateMeta));
    } else if (isInserting) {
      context.missing(_measDateMeta);
    }
    if (data.containsKey('not_assessed')) {
      context.handle(
          _notAssessedMeta,
          notAssessed.isAcceptableOrUnknown(
              data['not_assessed']!, _notAssessedMeta));
    }
    if (data.containsKey('complete')) {
      context.handle(_completeMeta,
          complete.isAcceptableOrUnknown(data['complete']!, _completeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  GpSummaryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSummaryData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      surveyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}survey_id'])!,
      measDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}meas_date'])!,
      notAssessed: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}not_assessed'])!,
      complete: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}complete'])!,
    );
  }

  @override
  $GpSummaryTable createAlias(String alias) {
    return $GpSummaryTable(attachedDatabase, alias);
  }
}

class GpSummaryData extends d.DataClass implements d.Insertable<GpSummaryData> {
  final int id;
  final int surveyId;
  final DateTime measDate;
  final bool notAssessed;
  final bool complete;
  const GpSummaryData(
      {required this.id,
      required this.surveyId,
      required this.measDate,
      required this.notAssessed,
      required this.complete});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['survey_id'] = d.Variable<int>(surveyId);
    map['meas_date'] = d.Variable<DateTime>(measDate);
    map['not_assessed'] = d.Variable<bool>(notAssessed);
    map['complete'] = d.Variable<bool>(complete);
    return map;
  }

  GpSummaryCompanion toCompanion(bool nullToAbsent) {
    return GpSummaryCompanion(
      id: d.Value(id),
      surveyId: d.Value(surveyId),
      measDate: d.Value(measDate),
      notAssessed: d.Value(notAssessed),
      complete: d.Value(complete),
    );
  }

  factory GpSummaryData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSummaryData(
      id: serializer.fromJson<int>(json['id']),
      surveyId: serializer.fromJson<int>(json['surveyId']),
      measDate: serializer.fromJson<DateTime>(json['measDate']),
      notAssessed: serializer.fromJson<bool>(json['notAssessed']),
      complete: serializer.fromJson<bool>(json['complete']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'surveyId': serializer.toJson<int>(surveyId),
      'measDate': serializer.toJson<DateTime>(measDate),
      'notAssessed': serializer.toJson<bool>(notAssessed),
      'complete': serializer.toJson<bool>(complete),
    };
  }

  GpSummaryData copyWith(
          {int? id,
          int? surveyId,
          DateTime? measDate,
          bool? notAssessed,
          bool? complete}) =>
      GpSummaryData(
        id: id ?? this.id,
        surveyId: surveyId ?? this.surveyId,
        measDate: measDate ?? this.measDate,
        notAssessed: notAssessed ?? this.notAssessed,
        complete: complete ?? this.complete,
      );
  @override
  String toString() {
    return (StringBuffer('GpSummaryData(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, surveyId, measDate, notAssessed, complete);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSummaryData &&
          other.id == this.id &&
          other.surveyId == this.surveyId &&
          other.measDate == this.measDate &&
          other.notAssessed == this.notAssessed &&
          other.complete == this.complete);
}

class GpSummaryCompanion extends d.UpdateCompanion<GpSummaryData> {
  final d.Value<int> id;
  final d.Value<int> surveyId;
  final d.Value<DateTime> measDate;
  final d.Value<bool> notAssessed;
  final d.Value<bool> complete;
  const GpSummaryCompanion({
    this.id = const d.Value.absent(),
    this.surveyId = const d.Value.absent(),
    this.measDate = const d.Value.absent(),
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  });
  GpSummaryCompanion.insert({
    this.id = const d.Value.absent(),
    required int surveyId,
    required DateTime measDate,
    this.notAssessed = const d.Value.absent(),
    this.complete = const d.Value.absent(),
  })  : surveyId = d.Value(surveyId),
        measDate = d.Value(measDate);
  static d.Insertable<GpSummaryData> custom({
    d.Expression<int>? id,
    d.Expression<int>? surveyId,
    d.Expression<DateTime>? measDate,
    d.Expression<bool>? notAssessed,
    d.Expression<bool>? complete,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (surveyId != null) 'survey_id': surveyId,
      if (measDate != null) 'meas_date': measDate,
      if (notAssessed != null) 'not_assessed': notAssessed,
      if (complete != null) 'complete': complete,
    });
  }

  GpSummaryCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? surveyId,
      d.Value<DateTime>? measDate,
      d.Value<bool>? notAssessed,
      d.Value<bool>? complete}) {
    return GpSummaryCompanion(
      id: id ?? this.id,
      surveyId: surveyId ?? this.surveyId,
      measDate: measDate ?? this.measDate,
      notAssessed: notAssessed ?? this.notAssessed,
      complete: complete ?? this.complete,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (surveyId.present) {
      map['survey_id'] = d.Variable<int>(surveyId.value);
    }
    if (measDate.present) {
      map['meas_date'] = d.Variable<DateTime>(measDate.value);
    }
    if (notAssessed.present) {
      map['not_assessed'] = d.Variable<bool>(notAssessed.value);
    }
    if (complete.present) {
      map['complete'] = d.Variable<bool>(complete.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSummaryCompanion(')
          ..write('id: $id, ')
          ..write('surveyId: $surveyId, ')
          ..write('measDate: $measDate, ')
          ..write('notAssessed: $notAssessed, ')
          ..write('complete: $complete')
          ..write(')'))
        .toString();
  }
}

class $GpSiteInfoTable extends GpSiteInfo
    with d.TableInfo<$GpSiteInfoTable, GpSiteInfoData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpSiteInfoTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _gpSummaryIdMeta =
      const d.VerificationMeta('gpSummaryId');
  @override
  late final d.GeneratedColumn<int> gpSummaryId = d.GeneratedColumn<int>(
      'gp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES gp_summary (id)'));
  static const d.VerificationMeta _plotCompletionMeta =
      const d.VerificationMeta('plotCompletion');
  @override
  late final d.GeneratedColumn<String> plotCompletion =
      d.GeneratedColumn<String>('plot_completion', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 1, maxTextLength: 1),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _incompReasonMeta =
      const d.VerificationMeta('incompReason');
  @override
  late final d.GeneratedColumn<String> incompReason = d.GeneratedColumn<String>(
      'incomp_reason', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _ecozoneMeta =
      const d.VerificationMeta('ecozone');
  @override
  late final d.GeneratedColumn<int> ecozone = d.GeneratedColumn<int>(
      'ecozone', aliasedName, false,
      check: () => ecozone.isBetweenValues(1, 15),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _provEcoTypeMeta =
      const d.VerificationMeta('provEcoType');
  @override
  late final d.GeneratedColumn<String> provEcoType = d.GeneratedColumn<String>(
      'prov_eco_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _provEcoRefMeta =
      const d.VerificationMeta('provEcoRef');
  @override
  late final d.GeneratedColumn<int> provEcoRef = d.GeneratedColumn<int>(
      'prov_eco_ref', aliasedName, false,
      check: () => provEcoRef.isBetweenValues(-1, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _postProcessingMeta =
      const d.VerificationMeta('postProcessing');
  @override
  late final d.GeneratedColumn<String> postProcessing =
      d.GeneratedColumn<String>('post_processing', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 1, maxTextLength: 1),
          type: DriftSqlType.string,
          requiredDuringInsert: true);
  static const d.VerificationMeta _utmNMeta = const d.VerificationMeta('utmN');
  @override
  late final d.GeneratedColumn<int> utmN = d.GeneratedColumn<int>(
      'utm_n', aliasedName, false,
      check: () => utmN.isBetweenValues(4614000, 9297000),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _utmNAccuracyMeta =
      const d.VerificationMeta('utmNAccuracy');
  @override
  late final d.GeneratedColumn<double> utmNAccuracy = d.GeneratedColumn<double>(
      'utm_n_accuracy', aliasedName, false,
      check: () => utmNAccuracy.isBetweenValues(-1, 40.000),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _utmEMeta = const d.VerificationMeta('utmE');
  @override
  late final d.GeneratedColumn<int> utmE = d.GeneratedColumn<int>(
      'utm_e', aliasedName, false,
      check: () => utmE.isBetweenValues(250000, 750000),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _utmEAccuracyMeta =
      const d.VerificationMeta('utmEAccuracy');
  @override
  late final d.GeneratedColumn<double> utmEAccuracy = d.GeneratedColumn<double>(
      'utm_e_accuracy', aliasedName, false,
      check: () => utmEAccuracy.isBetweenValues(-1, 40.000),
      type: DriftSqlType.double,
      requiredDuringInsert: true);
  static const d.VerificationMeta _utmZoneMeta =
      const d.VerificationMeta('utmZone');
  @override
  late final d.GeneratedColumn<int> utmZone = d.GeneratedColumn<int>(
      'utm_zone', aliasedName, false,
      check: () => utmZone.isBetweenValues(7, 22),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _slopeMeta =
      const d.VerificationMeta('slope');
  @override
  late final d.GeneratedColumn<int> slope = d.GeneratedColumn<int>(
      'slope', aliasedName, false,
      check: () => slope.isBetweenValues(-1, 150),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _aspectMeta =
      const d.VerificationMeta('aspect');
  @override
  late final d.GeneratedColumn<int> aspect = d.GeneratedColumn<int>(
      'aspect', aliasedName, false,
      check: () => (aspect.isBetweenValues(-1, 999)),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _elevationMeta =
      const d.VerificationMeta('elevation');
  @override
  late final d.GeneratedColumn<int> elevation = d.GeneratedColumn<int>(
      'elevation', aliasedName, false,
      check: () => elevation.isBetweenValues(-1, 5951),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _landBaseMeta =
      const d.VerificationMeta('landBase');
  @override
  late final d.GeneratedColumn<String> landBase = d.GeneratedColumn<String>(
      'land_base', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _landCoverMeta =
      const d.VerificationMeta('landCover');
  @override
  late final d.GeneratedColumn<String> landCover = d.GeneratedColumn<String>(
      'land_cover', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _landPosMeta =
      const d.VerificationMeta('landPos');
  @override
  late final d.GeneratedColumn<String> landPos = d.GeneratedColumn<String>(
      'land_pos', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _vegTypeMeta =
      const d.VerificationMeta('vegType');
  @override
  late final d.GeneratedColumn<String> vegType = d.GeneratedColumn<String>(
      'veg_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _densityClMeta =
      const d.VerificationMeta('densityCl');
  @override
  late final d.GeneratedColumn<String> densityCl = d.GeneratedColumn<String>(
      'density_cl', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _standStruMeta =
      const d.VerificationMeta('standStru');
  @override
  late final d.GeneratedColumn<String> standStru = d.GeneratedColumn<String>(
      'stand_stru', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _succStageMeta =
      const d.VerificationMeta('succStage');
  @override
  late final d.GeneratedColumn<String> succStage = d.GeneratedColumn<String>(
      'succ_stage', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _wetlandClassMeta =
      const d.VerificationMeta('wetlandClass');
  @override
  late final d.GeneratedColumn<String> wetlandClass = d.GeneratedColumn<String>(
      'wetland_class', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 1),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _userInfoMeta =
      const d.VerificationMeta('userInfo');
  @override
  late final d.GeneratedColumn<String> userInfo = d.GeneratedColumn<String>(
      'user_info', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const d.VerificationMeta _gpsMakeMeta =
      const d.VerificationMeta('gpsMake');
  @override
  late final d.GeneratedColumn<String> gpsMake = d.GeneratedColumn<String>(
      'gps_make', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 25),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _gpsModelMeta =
      const d.VerificationMeta('gpsModel');
  @override
  late final d.GeneratedColumn<String> gpsModel = d.GeneratedColumn<String>(
      'gps_model', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 25),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _gpsPointMeta =
      const d.VerificationMeta('gpsPoint');
  @override
  late final d.GeneratedColumn<int> gpsPoint = d.GeneratedColumn<int>(
      'gps_point', aliasedName, false,
      check: () => elevation.isBetweenValues(-1, 999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        gpSummaryId,
        plotCompletion,
        incompReason,
        ecozone,
        provEcoType,
        provEcoRef,
        postProcessing,
        utmN,
        utmNAccuracy,
        utmE,
        utmEAccuracy,
        utmZone,
        slope,
        aspect,
        elevation,
        landBase,
        landCover,
        landPos,
        vegType,
        densityCl,
        standStru,
        succStage,
        wetlandClass,
        userInfo,
        gpsMake,
        gpsModel,
        gpsPoint
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_site_info';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<GpSiteInfoData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('gp_summary_id')) {
      context.handle(
          _gpSummaryIdMeta,
          gpSummaryId.isAcceptableOrUnknown(
              data['gp_summary_id']!, _gpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_gpSummaryIdMeta);
    }
    if (data.containsKey('plot_completion')) {
      context.handle(
          _plotCompletionMeta,
          plotCompletion.isAcceptableOrUnknown(
              data['plot_completion']!, _plotCompletionMeta));
    } else if (isInserting) {
      context.missing(_plotCompletionMeta);
    }
    if (data.containsKey('incomp_reason')) {
      context.handle(
          _incompReasonMeta,
          incompReason.isAcceptableOrUnknown(
              data['incomp_reason']!, _incompReasonMeta));
    } else if (isInserting) {
      context.missing(_incompReasonMeta);
    }
    if (data.containsKey('ecozone')) {
      context.handle(_ecozoneMeta,
          ecozone.isAcceptableOrUnknown(data['ecozone']!, _ecozoneMeta));
    } else if (isInserting) {
      context.missing(_ecozoneMeta);
    }
    if (data.containsKey('prov_eco_type')) {
      context.handle(
          _provEcoTypeMeta,
          provEcoType.isAcceptableOrUnknown(
              data['prov_eco_type']!, _provEcoTypeMeta));
    }
    if (data.containsKey('prov_eco_ref')) {
      context.handle(
          _provEcoRefMeta,
          provEcoRef.isAcceptableOrUnknown(
              data['prov_eco_ref']!, _provEcoRefMeta));
    } else if (isInserting) {
      context.missing(_provEcoRefMeta);
    }
    if (data.containsKey('post_processing')) {
      context.handle(
          _postProcessingMeta,
          postProcessing.isAcceptableOrUnknown(
              data['post_processing']!, _postProcessingMeta));
    } else if (isInserting) {
      context.missing(_postProcessingMeta);
    }
    if (data.containsKey('utm_n')) {
      context.handle(
          _utmNMeta, utmN.isAcceptableOrUnknown(data['utm_n']!, _utmNMeta));
    } else if (isInserting) {
      context.missing(_utmNMeta);
    }
    if (data.containsKey('utm_n_accuracy')) {
      context.handle(
          _utmNAccuracyMeta,
          utmNAccuracy.isAcceptableOrUnknown(
              data['utm_n_accuracy']!, _utmNAccuracyMeta));
    } else if (isInserting) {
      context.missing(_utmNAccuracyMeta);
    }
    if (data.containsKey('utm_e')) {
      context.handle(
          _utmEMeta, utmE.isAcceptableOrUnknown(data['utm_e']!, _utmEMeta));
    } else if (isInserting) {
      context.missing(_utmEMeta);
    }
    if (data.containsKey('utm_e_accuracy')) {
      context.handle(
          _utmEAccuracyMeta,
          utmEAccuracy.isAcceptableOrUnknown(
              data['utm_e_accuracy']!, _utmEAccuracyMeta));
    } else if (isInserting) {
      context.missing(_utmEAccuracyMeta);
    }
    if (data.containsKey('utm_zone')) {
      context.handle(_utmZoneMeta,
          utmZone.isAcceptableOrUnknown(data['utm_zone']!, _utmZoneMeta));
    } else if (isInserting) {
      context.missing(_utmZoneMeta);
    }
    if (data.containsKey('slope')) {
      context.handle(
          _slopeMeta, slope.isAcceptableOrUnknown(data['slope']!, _slopeMeta));
    } else if (isInserting) {
      context.missing(_slopeMeta);
    }
    if (data.containsKey('aspect')) {
      context.handle(_aspectMeta,
          aspect.isAcceptableOrUnknown(data['aspect']!, _aspectMeta));
    } else if (isInserting) {
      context.missing(_aspectMeta);
    }
    if (data.containsKey('elevation')) {
      context.handle(_elevationMeta,
          elevation.isAcceptableOrUnknown(data['elevation']!, _elevationMeta));
    } else if (isInserting) {
      context.missing(_elevationMeta);
    }
    if (data.containsKey('land_base')) {
      context.handle(_landBaseMeta,
          landBase.isAcceptableOrUnknown(data['land_base']!, _landBaseMeta));
    } else if (isInserting) {
      context.missing(_landBaseMeta);
    }
    if (data.containsKey('land_cover')) {
      context.handle(_landCoverMeta,
          landCover.isAcceptableOrUnknown(data['land_cover']!, _landCoverMeta));
    } else if (isInserting) {
      context.missing(_landCoverMeta);
    }
    if (data.containsKey('land_pos')) {
      context.handle(_landPosMeta,
          landPos.isAcceptableOrUnknown(data['land_pos']!, _landPosMeta));
    } else if (isInserting) {
      context.missing(_landPosMeta);
    }
    if (data.containsKey('veg_type')) {
      context.handle(_vegTypeMeta,
          vegType.isAcceptableOrUnknown(data['veg_type']!, _vegTypeMeta));
    } else if (isInserting) {
      context.missing(_vegTypeMeta);
    }
    if (data.containsKey('density_cl')) {
      context.handle(_densityClMeta,
          densityCl.isAcceptableOrUnknown(data['density_cl']!, _densityClMeta));
    } else if (isInserting) {
      context.missing(_densityClMeta);
    }
    if (data.containsKey('stand_stru')) {
      context.handle(_standStruMeta,
          standStru.isAcceptableOrUnknown(data['stand_stru']!, _standStruMeta));
    } else if (isInserting) {
      context.missing(_standStruMeta);
    }
    if (data.containsKey('succ_stage')) {
      context.handle(_succStageMeta,
          succStage.isAcceptableOrUnknown(data['succ_stage']!, _succStageMeta));
    } else if (isInserting) {
      context.missing(_succStageMeta);
    }
    if (data.containsKey('wetland_class')) {
      context.handle(
          _wetlandClassMeta,
          wetlandClass.isAcceptableOrUnknown(
              data['wetland_class']!, _wetlandClassMeta));
    } else if (isInserting) {
      context.missing(_wetlandClassMeta);
    }
    if (data.containsKey('user_info')) {
      context.handle(_userInfoMeta,
          userInfo.isAcceptableOrUnknown(data['user_info']!, _userInfoMeta));
    }
    if (data.containsKey('gps_make')) {
      context.handle(_gpsMakeMeta,
          gpsMake.isAcceptableOrUnknown(data['gps_make']!, _gpsMakeMeta));
    } else if (isInserting) {
      context.missing(_gpsMakeMeta);
    }
    if (data.containsKey('gps_model')) {
      context.handle(_gpsModelMeta,
          gpsModel.isAcceptableOrUnknown(data['gps_model']!, _gpsModelMeta));
    } else if (isInserting) {
      context.missing(_gpsModelMeta);
    }
    if (data.containsKey('gps_point')) {
      context.handle(_gpsPointMeta,
          gpsPoint.isAcceptableOrUnknown(data['gps_point']!, _gpsPointMeta));
    } else if (isInserting) {
      context.missing(_gpsPointMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  GpSiteInfoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpSiteInfoData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      gpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gp_summary_id'])!,
      plotCompletion: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}plot_completion'])!,
      incompReason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}incomp_reason'])!,
      ecozone: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ecozone'])!,
      provEcoType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}prov_eco_type']),
      provEcoRef: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}prov_eco_ref'])!,
      postProcessing: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}post_processing'])!,
      utmN: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}utm_n'])!,
      utmNAccuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}utm_n_accuracy'])!,
      utmE: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}utm_e'])!,
      utmEAccuracy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}utm_e_accuracy'])!,
      utmZone: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}utm_zone'])!,
      slope: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}slope'])!,
      aspect: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}aspect'])!,
      elevation: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}elevation'])!,
      landBase: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}land_base'])!,
      landCover: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}land_cover'])!,
      landPos: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}land_pos'])!,
      vegType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}veg_type'])!,
      densityCl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}density_cl'])!,
      standStru: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stand_stru'])!,
      succStage: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}succ_stage'])!,
      wetlandClass: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}wetland_class'])!,
      userInfo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_info']),
      gpsMake: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gps_make'])!,
      gpsModel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gps_model'])!,
      gpsPoint: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gps_point'])!,
    );
  }

  @override
  $GpSiteInfoTable createAlias(String alias) {
    return $GpSiteInfoTable(attachedDatabase, alias);
  }
}

class GpSiteInfoData extends d.DataClass
    implements d.Insertable<GpSiteInfoData> {
  final int id;
  final int gpSummaryId;
  final String plotCompletion;
  final String incompReason;
  final int ecozone;
  final String? provEcoType;
  final int provEcoRef;
  final String postProcessing;
  final int utmN;
  final double utmNAccuracy;
  final int utmE;
  final double utmEAccuracy;
  final int utmZone;
  final int slope;
  final int aspect;
  final int elevation;
  final String landBase;
  final String landCover;
  final String landPos;
  final String vegType;
  final String densityCl;
  final String standStru;
  final String succStage;
  final String wetlandClass;
  final String? userInfo;
  final String gpsMake;
  final String gpsModel;
  final int gpsPoint;
  const GpSiteInfoData(
      {required this.id,
      required this.gpSummaryId,
      required this.plotCompletion,
      required this.incompReason,
      required this.ecozone,
      this.provEcoType,
      required this.provEcoRef,
      required this.postProcessing,
      required this.utmN,
      required this.utmNAccuracy,
      required this.utmE,
      required this.utmEAccuracy,
      required this.utmZone,
      required this.slope,
      required this.aspect,
      required this.elevation,
      required this.landBase,
      required this.landCover,
      required this.landPos,
      required this.vegType,
      required this.densityCl,
      required this.standStru,
      required this.succStage,
      required this.wetlandClass,
      this.userInfo,
      required this.gpsMake,
      required this.gpsModel,
      required this.gpsPoint});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['gp_summary_id'] = d.Variable<int>(gpSummaryId);
    map['plot_completion'] = d.Variable<String>(plotCompletion);
    map['incomp_reason'] = d.Variable<String>(incompReason);
    map['ecozone'] = d.Variable<int>(ecozone);
    if (!nullToAbsent || provEcoType != null) {
      map['prov_eco_type'] = d.Variable<String>(provEcoType);
    }
    map['prov_eco_ref'] = d.Variable<int>(provEcoRef);
    map['post_processing'] = d.Variable<String>(postProcessing);
    map['utm_n'] = d.Variable<int>(utmN);
    map['utm_n_accuracy'] = d.Variable<double>(utmNAccuracy);
    map['utm_e'] = d.Variable<int>(utmE);
    map['utm_e_accuracy'] = d.Variable<double>(utmEAccuracy);
    map['utm_zone'] = d.Variable<int>(utmZone);
    map['slope'] = d.Variable<int>(slope);
    map['aspect'] = d.Variable<int>(aspect);
    map['elevation'] = d.Variable<int>(elevation);
    map['land_base'] = d.Variable<String>(landBase);
    map['land_cover'] = d.Variable<String>(landCover);
    map['land_pos'] = d.Variable<String>(landPos);
    map['veg_type'] = d.Variable<String>(vegType);
    map['density_cl'] = d.Variable<String>(densityCl);
    map['stand_stru'] = d.Variable<String>(standStru);
    map['succ_stage'] = d.Variable<String>(succStage);
    map['wetland_class'] = d.Variable<String>(wetlandClass);
    if (!nullToAbsent || userInfo != null) {
      map['user_info'] = d.Variable<String>(userInfo);
    }
    map['gps_make'] = d.Variable<String>(gpsMake);
    map['gps_model'] = d.Variable<String>(gpsModel);
    map['gps_point'] = d.Variable<int>(gpsPoint);
    return map;
  }

  GpSiteInfoCompanion toCompanion(bool nullToAbsent) {
    return GpSiteInfoCompanion(
      id: d.Value(id),
      gpSummaryId: d.Value(gpSummaryId),
      plotCompletion: d.Value(plotCompletion),
      incompReason: d.Value(incompReason),
      ecozone: d.Value(ecozone),
      provEcoType: provEcoType == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(provEcoType),
      provEcoRef: d.Value(provEcoRef),
      postProcessing: d.Value(postProcessing),
      utmN: d.Value(utmN),
      utmNAccuracy: d.Value(utmNAccuracy),
      utmE: d.Value(utmE),
      utmEAccuracy: d.Value(utmEAccuracy),
      utmZone: d.Value(utmZone),
      slope: d.Value(slope),
      aspect: d.Value(aspect),
      elevation: d.Value(elevation),
      landBase: d.Value(landBase),
      landCover: d.Value(landCover),
      landPos: d.Value(landPos),
      vegType: d.Value(vegType),
      densityCl: d.Value(densityCl),
      standStru: d.Value(standStru),
      succStage: d.Value(succStage),
      wetlandClass: d.Value(wetlandClass),
      userInfo: userInfo == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(userInfo),
      gpsMake: d.Value(gpsMake),
      gpsModel: d.Value(gpsModel),
      gpsPoint: d.Value(gpsPoint),
    );
  }

  factory GpSiteInfoData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpSiteInfoData(
      id: serializer.fromJson<int>(json['id']),
      gpSummaryId: serializer.fromJson<int>(json['gpSummaryId']),
      plotCompletion: serializer.fromJson<String>(json['plotCompletion']),
      incompReason: serializer.fromJson<String>(json['incompReason']),
      ecozone: serializer.fromJson<int>(json['ecozone']),
      provEcoType: serializer.fromJson<String?>(json['provEcoType']),
      provEcoRef: serializer.fromJson<int>(json['provEcoRef']),
      postProcessing: serializer.fromJson<String>(json['postProcessing']),
      utmN: serializer.fromJson<int>(json['utmN']),
      utmNAccuracy: serializer.fromJson<double>(json['utmNAccuracy']),
      utmE: serializer.fromJson<int>(json['utmE']),
      utmEAccuracy: serializer.fromJson<double>(json['utmEAccuracy']),
      utmZone: serializer.fromJson<int>(json['utmZone']),
      slope: serializer.fromJson<int>(json['slope']),
      aspect: serializer.fromJson<int>(json['aspect']),
      elevation: serializer.fromJson<int>(json['elevation']),
      landBase: serializer.fromJson<String>(json['landBase']),
      landCover: serializer.fromJson<String>(json['landCover']),
      landPos: serializer.fromJson<String>(json['landPos']),
      vegType: serializer.fromJson<String>(json['vegType']),
      densityCl: serializer.fromJson<String>(json['densityCl']),
      standStru: serializer.fromJson<String>(json['standStru']),
      succStage: serializer.fromJson<String>(json['succStage']),
      wetlandClass: serializer.fromJson<String>(json['wetlandClass']),
      userInfo: serializer.fromJson<String?>(json['userInfo']),
      gpsMake: serializer.fromJson<String>(json['gpsMake']),
      gpsModel: serializer.fromJson<String>(json['gpsModel']),
      gpsPoint: serializer.fromJson<int>(json['gpsPoint']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'gpSummaryId': serializer.toJson<int>(gpSummaryId),
      'plotCompletion': serializer.toJson<String>(plotCompletion),
      'incompReason': serializer.toJson<String>(incompReason),
      'ecozone': serializer.toJson<int>(ecozone),
      'provEcoType': serializer.toJson<String?>(provEcoType),
      'provEcoRef': serializer.toJson<int>(provEcoRef),
      'postProcessing': serializer.toJson<String>(postProcessing),
      'utmN': serializer.toJson<int>(utmN),
      'utmNAccuracy': serializer.toJson<double>(utmNAccuracy),
      'utmE': serializer.toJson<int>(utmE),
      'utmEAccuracy': serializer.toJson<double>(utmEAccuracy),
      'utmZone': serializer.toJson<int>(utmZone),
      'slope': serializer.toJson<int>(slope),
      'aspect': serializer.toJson<int>(aspect),
      'elevation': serializer.toJson<int>(elevation),
      'landBase': serializer.toJson<String>(landBase),
      'landCover': serializer.toJson<String>(landCover),
      'landPos': serializer.toJson<String>(landPos),
      'vegType': serializer.toJson<String>(vegType),
      'densityCl': serializer.toJson<String>(densityCl),
      'standStru': serializer.toJson<String>(standStru),
      'succStage': serializer.toJson<String>(succStage),
      'wetlandClass': serializer.toJson<String>(wetlandClass),
      'userInfo': serializer.toJson<String?>(userInfo),
      'gpsMake': serializer.toJson<String>(gpsMake),
      'gpsModel': serializer.toJson<String>(gpsModel),
      'gpsPoint': serializer.toJson<int>(gpsPoint),
    };
  }

  GpSiteInfoData copyWith(
          {int? id,
          int? gpSummaryId,
          String? plotCompletion,
          String? incompReason,
          int? ecozone,
          d.Value<String?> provEcoType = const d.Value.absent(),
          int? provEcoRef,
          String? postProcessing,
          int? utmN,
          double? utmNAccuracy,
          int? utmE,
          double? utmEAccuracy,
          int? utmZone,
          int? slope,
          int? aspect,
          int? elevation,
          String? landBase,
          String? landCover,
          String? landPos,
          String? vegType,
          String? densityCl,
          String? standStru,
          String? succStage,
          String? wetlandClass,
          d.Value<String?> userInfo = const d.Value.absent(),
          String? gpsMake,
          String? gpsModel,
          int? gpsPoint}) =>
      GpSiteInfoData(
        id: id ?? this.id,
        gpSummaryId: gpSummaryId ?? this.gpSummaryId,
        plotCompletion: plotCompletion ?? this.plotCompletion,
        incompReason: incompReason ?? this.incompReason,
        ecozone: ecozone ?? this.ecozone,
        provEcoType: provEcoType.present ? provEcoType.value : this.provEcoType,
        provEcoRef: provEcoRef ?? this.provEcoRef,
        postProcessing: postProcessing ?? this.postProcessing,
        utmN: utmN ?? this.utmN,
        utmNAccuracy: utmNAccuracy ?? this.utmNAccuracy,
        utmE: utmE ?? this.utmE,
        utmEAccuracy: utmEAccuracy ?? this.utmEAccuracy,
        utmZone: utmZone ?? this.utmZone,
        slope: slope ?? this.slope,
        aspect: aspect ?? this.aspect,
        elevation: elevation ?? this.elevation,
        landBase: landBase ?? this.landBase,
        landCover: landCover ?? this.landCover,
        landPos: landPos ?? this.landPos,
        vegType: vegType ?? this.vegType,
        densityCl: densityCl ?? this.densityCl,
        standStru: standStru ?? this.standStru,
        succStage: succStage ?? this.succStage,
        wetlandClass: wetlandClass ?? this.wetlandClass,
        userInfo: userInfo.present ? userInfo.value : this.userInfo,
        gpsMake: gpsMake ?? this.gpsMake,
        gpsModel: gpsModel ?? this.gpsModel,
        gpsPoint: gpsPoint ?? this.gpsPoint,
      );
  @override
  String toString() {
    return (StringBuffer('GpSiteInfoData(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('plotCompletion: $plotCompletion, ')
          ..write('incompReason: $incompReason, ')
          ..write('ecozone: $ecozone, ')
          ..write('provEcoType: $provEcoType, ')
          ..write('provEcoRef: $provEcoRef, ')
          ..write('postProcessing: $postProcessing, ')
          ..write('utmN: $utmN, ')
          ..write('utmNAccuracy: $utmNAccuracy, ')
          ..write('utmE: $utmE, ')
          ..write('utmEAccuracy: $utmEAccuracy, ')
          ..write('utmZone: $utmZone, ')
          ..write('slope: $slope, ')
          ..write('aspect: $aspect, ')
          ..write('elevation: $elevation, ')
          ..write('landBase: $landBase, ')
          ..write('landCover: $landCover, ')
          ..write('landPos: $landPos, ')
          ..write('vegType: $vegType, ')
          ..write('densityCl: $densityCl, ')
          ..write('standStru: $standStru, ')
          ..write('succStage: $succStage, ')
          ..write('wetlandClass: $wetlandClass, ')
          ..write('userInfo: $userInfo, ')
          ..write('gpsMake: $gpsMake, ')
          ..write('gpsModel: $gpsModel, ')
          ..write('gpsPoint: $gpsPoint')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        gpSummaryId,
        plotCompletion,
        incompReason,
        ecozone,
        provEcoType,
        provEcoRef,
        postProcessing,
        utmN,
        utmNAccuracy,
        utmE,
        utmEAccuracy,
        utmZone,
        slope,
        aspect,
        elevation,
        landBase,
        landCover,
        landPos,
        vegType,
        densityCl,
        standStru,
        succStage,
        wetlandClass,
        userInfo,
        gpsMake,
        gpsModel,
        gpsPoint
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpSiteInfoData &&
          other.id == this.id &&
          other.gpSummaryId == this.gpSummaryId &&
          other.plotCompletion == this.plotCompletion &&
          other.incompReason == this.incompReason &&
          other.ecozone == this.ecozone &&
          other.provEcoType == this.provEcoType &&
          other.provEcoRef == this.provEcoRef &&
          other.postProcessing == this.postProcessing &&
          other.utmN == this.utmN &&
          other.utmNAccuracy == this.utmNAccuracy &&
          other.utmE == this.utmE &&
          other.utmEAccuracy == this.utmEAccuracy &&
          other.utmZone == this.utmZone &&
          other.slope == this.slope &&
          other.aspect == this.aspect &&
          other.elevation == this.elevation &&
          other.landBase == this.landBase &&
          other.landCover == this.landCover &&
          other.landPos == this.landPos &&
          other.vegType == this.vegType &&
          other.densityCl == this.densityCl &&
          other.standStru == this.standStru &&
          other.succStage == this.succStage &&
          other.wetlandClass == this.wetlandClass &&
          other.userInfo == this.userInfo &&
          other.gpsMake == this.gpsMake &&
          other.gpsModel == this.gpsModel &&
          other.gpsPoint == this.gpsPoint);
}

class GpSiteInfoCompanion extends d.UpdateCompanion<GpSiteInfoData> {
  final d.Value<int> id;
  final d.Value<int> gpSummaryId;
  final d.Value<String> plotCompletion;
  final d.Value<String> incompReason;
  final d.Value<int> ecozone;
  final d.Value<String?> provEcoType;
  final d.Value<int> provEcoRef;
  final d.Value<String> postProcessing;
  final d.Value<int> utmN;
  final d.Value<double> utmNAccuracy;
  final d.Value<int> utmE;
  final d.Value<double> utmEAccuracy;
  final d.Value<int> utmZone;
  final d.Value<int> slope;
  final d.Value<int> aspect;
  final d.Value<int> elevation;
  final d.Value<String> landBase;
  final d.Value<String> landCover;
  final d.Value<String> landPos;
  final d.Value<String> vegType;
  final d.Value<String> densityCl;
  final d.Value<String> standStru;
  final d.Value<String> succStage;
  final d.Value<String> wetlandClass;
  final d.Value<String?> userInfo;
  final d.Value<String> gpsMake;
  final d.Value<String> gpsModel;
  final d.Value<int> gpsPoint;
  const GpSiteInfoCompanion({
    this.id = const d.Value.absent(),
    this.gpSummaryId = const d.Value.absent(),
    this.plotCompletion = const d.Value.absent(),
    this.incompReason = const d.Value.absent(),
    this.ecozone = const d.Value.absent(),
    this.provEcoType = const d.Value.absent(),
    this.provEcoRef = const d.Value.absent(),
    this.postProcessing = const d.Value.absent(),
    this.utmN = const d.Value.absent(),
    this.utmNAccuracy = const d.Value.absent(),
    this.utmE = const d.Value.absent(),
    this.utmEAccuracy = const d.Value.absent(),
    this.utmZone = const d.Value.absent(),
    this.slope = const d.Value.absent(),
    this.aspect = const d.Value.absent(),
    this.elevation = const d.Value.absent(),
    this.landBase = const d.Value.absent(),
    this.landCover = const d.Value.absent(),
    this.landPos = const d.Value.absent(),
    this.vegType = const d.Value.absent(),
    this.densityCl = const d.Value.absent(),
    this.standStru = const d.Value.absent(),
    this.succStage = const d.Value.absent(),
    this.wetlandClass = const d.Value.absent(),
    this.userInfo = const d.Value.absent(),
    this.gpsMake = const d.Value.absent(),
    this.gpsModel = const d.Value.absent(),
    this.gpsPoint = const d.Value.absent(),
  });
  GpSiteInfoCompanion.insert({
    this.id = const d.Value.absent(),
    required int gpSummaryId,
    required String plotCompletion,
    required String incompReason,
    required int ecozone,
    this.provEcoType = const d.Value.absent(),
    required int provEcoRef,
    required String postProcessing,
    required int utmN,
    required double utmNAccuracy,
    required int utmE,
    required double utmEAccuracy,
    required int utmZone,
    required int slope,
    required int aspect,
    required int elevation,
    required String landBase,
    required String landCover,
    required String landPos,
    required String vegType,
    required String densityCl,
    required String standStru,
    required String succStage,
    required String wetlandClass,
    this.userInfo = const d.Value.absent(),
    required String gpsMake,
    required String gpsModel,
    required int gpsPoint,
  })  : gpSummaryId = d.Value(gpSummaryId),
        plotCompletion = d.Value(plotCompletion),
        incompReason = d.Value(incompReason),
        ecozone = d.Value(ecozone),
        provEcoRef = d.Value(provEcoRef),
        postProcessing = d.Value(postProcessing),
        utmN = d.Value(utmN),
        utmNAccuracy = d.Value(utmNAccuracy),
        utmE = d.Value(utmE),
        utmEAccuracy = d.Value(utmEAccuracy),
        utmZone = d.Value(utmZone),
        slope = d.Value(slope),
        aspect = d.Value(aspect),
        elevation = d.Value(elevation),
        landBase = d.Value(landBase),
        landCover = d.Value(landCover),
        landPos = d.Value(landPos),
        vegType = d.Value(vegType),
        densityCl = d.Value(densityCl),
        standStru = d.Value(standStru),
        succStage = d.Value(succStage),
        wetlandClass = d.Value(wetlandClass),
        gpsMake = d.Value(gpsMake),
        gpsModel = d.Value(gpsModel),
        gpsPoint = d.Value(gpsPoint);
  static d.Insertable<GpSiteInfoData> custom({
    d.Expression<int>? id,
    d.Expression<int>? gpSummaryId,
    d.Expression<String>? plotCompletion,
    d.Expression<String>? incompReason,
    d.Expression<int>? ecozone,
    d.Expression<String>? provEcoType,
    d.Expression<int>? provEcoRef,
    d.Expression<String>? postProcessing,
    d.Expression<int>? utmN,
    d.Expression<double>? utmNAccuracy,
    d.Expression<int>? utmE,
    d.Expression<double>? utmEAccuracy,
    d.Expression<int>? utmZone,
    d.Expression<int>? slope,
    d.Expression<int>? aspect,
    d.Expression<int>? elevation,
    d.Expression<String>? landBase,
    d.Expression<String>? landCover,
    d.Expression<String>? landPos,
    d.Expression<String>? vegType,
    d.Expression<String>? densityCl,
    d.Expression<String>? standStru,
    d.Expression<String>? succStage,
    d.Expression<String>? wetlandClass,
    d.Expression<String>? userInfo,
    d.Expression<String>? gpsMake,
    d.Expression<String>? gpsModel,
    d.Expression<int>? gpsPoint,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (gpSummaryId != null) 'gp_summary_id': gpSummaryId,
      if (plotCompletion != null) 'plot_completion': plotCompletion,
      if (incompReason != null) 'incomp_reason': incompReason,
      if (ecozone != null) 'ecozone': ecozone,
      if (provEcoType != null) 'prov_eco_type': provEcoType,
      if (provEcoRef != null) 'prov_eco_ref': provEcoRef,
      if (postProcessing != null) 'post_processing': postProcessing,
      if (utmN != null) 'utm_n': utmN,
      if (utmNAccuracy != null) 'utm_n_accuracy': utmNAccuracy,
      if (utmE != null) 'utm_e': utmE,
      if (utmEAccuracy != null) 'utm_e_accuracy': utmEAccuracy,
      if (utmZone != null) 'utm_zone': utmZone,
      if (slope != null) 'slope': slope,
      if (aspect != null) 'aspect': aspect,
      if (elevation != null) 'elevation': elevation,
      if (landBase != null) 'land_base': landBase,
      if (landCover != null) 'land_cover': landCover,
      if (landPos != null) 'land_pos': landPos,
      if (vegType != null) 'veg_type': vegType,
      if (densityCl != null) 'density_cl': densityCl,
      if (standStru != null) 'stand_stru': standStru,
      if (succStage != null) 'succ_stage': succStage,
      if (wetlandClass != null) 'wetland_class': wetlandClass,
      if (userInfo != null) 'user_info': userInfo,
      if (gpsMake != null) 'gps_make': gpsMake,
      if (gpsModel != null) 'gps_model': gpsModel,
      if (gpsPoint != null) 'gps_point': gpsPoint,
    });
  }

  GpSiteInfoCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? gpSummaryId,
      d.Value<String>? plotCompletion,
      d.Value<String>? incompReason,
      d.Value<int>? ecozone,
      d.Value<String?>? provEcoType,
      d.Value<int>? provEcoRef,
      d.Value<String>? postProcessing,
      d.Value<int>? utmN,
      d.Value<double>? utmNAccuracy,
      d.Value<int>? utmE,
      d.Value<double>? utmEAccuracy,
      d.Value<int>? utmZone,
      d.Value<int>? slope,
      d.Value<int>? aspect,
      d.Value<int>? elevation,
      d.Value<String>? landBase,
      d.Value<String>? landCover,
      d.Value<String>? landPos,
      d.Value<String>? vegType,
      d.Value<String>? densityCl,
      d.Value<String>? standStru,
      d.Value<String>? succStage,
      d.Value<String>? wetlandClass,
      d.Value<String?>? userInfo,
      d.Value<String>? gpsMake,
      d.Value<String>? gpsModel,
      d.Value<int>? gpsPoint}) {
    return GpSiteInfoCompanion(
      id: id ?? this.id,
      gpSummaryId: gpSummaryId ?? this.gpSummaryId,
      plotCompletion: plotCompletion ?? this.plotCompletion,
      incompReason: incompReason ?? this.incompReason,
      ecozone: ecozone ?? this.ecozone,
      provEcoType: provEcoType ?? this.provEcoType,
      provEcoRef: provEcoRef ?? this.provEcoRef,
      postProcessing: postProcessing ?? this.postProcessing,
      utmN: utmN ?? this.utmN,
      utmNAccuracy: utmNAccuracy ?? this.utmNAccuracy,
      utmE: utmE ?? this.utmE,
      utmEAccuracy: utmEAccuracy ?? this.utmEAccuracy,
      utmZone: utmZone ?? this.utmZone,
      slope: slope ?? this.slope,
      aspect: aspect ?? this.aspect,
      elevation: elevation ?? this.elevation,
      landBase: landBase ?? this.landBase,
      landCover: landCover ?? this.landCover,
      landPos: landPos ?? this.landPos,
      vegType: vegType ?? this.vegType,
      densityCl: densityCl ?? this.densityCl,
      standStru: standStru ?? this.standStru,
      succStage: succStage ?? this.succStage,
      wetlandClass: wetlandClass ?? this.wetlandClass,
      userInfo: userInfo ?? this.userInfo,
      gpsMake: gpsMake ?? this.gpsMake,
      gpsModel: gpsModel ?? this.gpsModel,
      gpsPoint: gpsPoint ?? this.gpsPoint,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (gpSummaryId.present) {
      map['gp_summary_id'] = d.Variable<int>(gpSummaryId.value);
    }
    if (plotCompletion.present) {
      map['plot_completion'] = d.Variable<String>(plotCompletion.value);
    }
    if (incompReason.present) {
      map['incomp_reason'] = d.Variable<String>(incompReason.value);
    }
    if (ecozone.present) {
      map['ecozone'] = d.Variable<int>(ecozone.value);
    }
    if (provEcoType.present) {
      map['prov_eco_type'] = d.Variable<String>(provEcoType.value);
    }
    if (provEcoRef.present) {
      map['prov_eco_ref'] = d.Variable<int>(provEcoRef.value);
    }
    if (postProcessing.present) {
      map['post_processing'] = d.Variable<String>(postProcessing.value);
    }
    if (utmN.present) {
      map['utm_n'] = d.Variable<int>(utmN.value);
    }
    if (utmNAccuracy.present) {
      map['utm_n_accuracy'] = d.Variable<double>(utmNAccuracy.value);
    }
    if (utmE.present) {
      map['utm_e'] = d.Variable<int>(utmE.value);
    }
    if (utmEAccuracy.present) {
      map['utm_e_accuracy'] = d.Variable<double>(utmEAccuracy.value);
    }
    if (utmZone.present) {
      map['utm_zone'] = d.Variable<int>(utmZone.value);
    }
    if (slope.present) {
      map['slope'] = d.Variable<int>(slope.value);
    }
    if (aspect.present) {
      map['aspect'] = d.Variable<int>(aspect.value);
    }
    if (elevation.present) {
      map['elevation'] = d.Variable<int>(elevation.value);
    }
    if (landBase.present) {
      map['land_base'] = d.Variable<String>(landBase.value);
    }
    if (landCover.present) {
      map['land_cover'] = d.Variable<String>(landCover.value);
    }
    if (landPos.present) {
      map['land_pos'] = d.Variable<String>(landPos.value);
    }
    if (vegType.present) {
      map['veg_type'] = d.Variable<String>(vegType.value);
    }
    if (densityCl.present) {
      map['density_cl'] = d.Variable<String>(densityCl.value);
    }
    if (standStru.present) {
      map['stand_stru'] = d.Variable<String>(standStru.value);
    }
    if (succStage.present) {
      map['succ_stage'] = d.Variable<String>(succStage.value);
    }
    if (wetlandClass.present) {
      map['wetland_class'] = d.Variable<String>(wetlandClass.value);
    }
    if (userInfo.present) {
      map['user_info'] = d.Variable<String>(userInfo.value);
    }
    if (gpsMake.present) {
      map['gps_make'] = d.Variable<String>(gpsMake.value);
    }
    if (gpsModel.present) {
      map['gps_model'] = d.Variable<String>(gpsModel.value);
    }
    if (gpsPoint.present) {
      map['gps_point'] = d.Variable<int>(gpsPoint.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpSiteInfoCompanion(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('plotCompletion: $plotCompletion, ')
          ..write('incompReason: $incompReason, ')
          ..write('ecozone: $ecozone, ')
          ..write('provEcoType: $provEcoType, ')
          ..write('provEcoRef: $provEcoRef, ')
          ..write('postProcessing: $postProcessing, ')
          ..write('utmN: $utmN, ')
          ..write('utmNAccuracy: $utmNAccuracy, ')
          ..write('utmE: $utmE, ')
          ..write('utmEAccuracy: $utmEAccuracy, ')
          ..write('utmZone: $utmZone, ')
          ..write('slope: $slope, ')
          ..write('aspect: $aspect, ')
          ..write('elevation: $elevation, ')
          ..write('landBase: $landBase, ')
          ..write('landCover: $landCover, ')
          ..write('landPos: $landPos, ')
          ..write('vegType: $vegType, ')
          ..write('densityCl: $densityCl, ')
          ..write('standStru: $standStru, ')
          ..write('succStage: $succStage, ')
          ..write('wetlandClass: $wetlandClass, ')
          ..write('userInfo: $userInfo, ')
          ..write('gpsMake: $gpsMake, ')
          ..write('gpsModel: $gpsModel, ')
          ..write('gpsPoint: $gpsPoint')
          ..write(')'))
        .toString();
  }
}

class $GpDisturbanceTable extends GpDisturbance
    with d.TableInfo<$GpDisturbanceTable, GpDisturbanceData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpDisturbanceTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _gpSummaryIdMeta =
      const d.VerificationMeta('gpSummaryId');
  @override
  late final d.GeneratedColumn<int> gpSummaryId = d.GeneratedColumn<int>(
      'gp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES gp_summary (id)'));
  static const d.VerificationMeta _distAgentMeta =
      const d.VerificationMeta('distAgent');
  @override
  late final d.GeneratedColumn<String> distAgent = d.GeneratedColumn<String>(
      'dist_agent', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _distYrMeta =
      const d.VerificationMeta('distYr');
  @override
  late final d.GeneratedColumn<int> distYr = d.GeneratedColumn<int>(
      'dist_yr', aliasedName, false,
      check: () => distYr.isBetweenValues(-9, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _distPctMeta =
      const d.VerificationMeta('distPct');
  @override
  late final d.GeneratedColumn<int> distPct = d.GeneratedColumn<int>(
      'dist_pct', aliasedName, false,
      check: () => distPct.isBetweenValues(-1, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _mortPctMeta =
      const d.VerificationMeta('mortPct');
  @override
  late final d.GeneratedColumn<int> mortPct = d.GeneratedColumn<int>(
      'mort_pct', aliasedName, false,
      check: () => mortPct.isBetweenValues(-9, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _mortBasisMeta =
      const d.VerificationMeta('mortBasis');
  @override
  late final d.GeneratedColumn<String> mortBasis = d.GeneratedColumn<String>(
      'mort_basis', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _agentTypeMeta =
      const d.VerificationMeta('agentType');
  @override
  late final d.GeneratedColumn<String> agentType = d.GeneratedColumn<String>(
      'agent_type', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 200),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  @override
  List<d.GeneratedColumn> get $columns => [
        id,
        gpSummaryId,
        distAgent,
        distYr,
        distPct,
        mortPct,
        mortBasis,
        agentType
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_disturbance';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpDisturbanceData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('gp_summary_id')) {
      context.handle(
          _gpSummaryIdMeta,
          gpSummaryId.isAcceptableOrUnknown(
              data['gp_summary_id']!, _gpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_gpSummaryIdMeta);
    }
    if (data.containsKey('dist_agent')) {
      context.handle(_distAgentMeta,
          distAgent.isAcceptableOrUnknown(data['dist_agent']!, _distAgentMeta));
    } else if (isInserting) {
      context.missing(_distAgentMeta);
    }
    if (data.containsKey('dist_yr')) {
      context.handle(_distYrMeta,
          distYr.isAcceptableOrUnknown(data['dist_yr']!, _distYrMeta));
    } else if (isInserting) {
      context.missing(_distYrMeta);
    }
    if (data.containsKey('dist_pct')) {
      context.handle(_distPctMeta,
          distPct.isAcceptableOrUnknown(data['dist_pct']!, _distPctMeta));
    } else if (isInserting) {
      context.missing(_distPctMeta);
    }
    if (data.containsKey('mort_pct')) {
      context.handle(_mortPctMeta,
          mortPct.isAcceptableOrUnknown(data['mort_pct']!, _mortPctMeta));
    } else if (isInserting) {
      context.missing(_mortPctMeta);
    }
    if (data.containsKey('mort_basis')) {
      context.handle(_mortBasisMeta,
          mortBasis.isAcceptableOrUnknown(data['mort_basis']!, _mortBasisMeta));
    } else if (isInserting) {
      context.missing(_mortBasisMeta);
    }
    if (data.containsKey('agent_type')) {
      context.handle(_agentTypeMeta,
          agentType.isAcceptableOrUnknown(data['agent_type']!, _agentTypeMeta));
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  GpDisturbanceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpDisturbanceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      gpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gp_summary_id'])!,
      distAgent: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}dist_agent'])!,
      distYr: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}dist_yr'])!,
      distPct: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}dist_pct'])!,
      mortPct: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}mort_pct'])!,
      mortBasis: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mort_basis'])!,
      agentType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}agent_type']),
    );
  }

  @override
  $GpDisturbanceTable createAlias(String alias) {
    return $GpDisturbanceTable(attachedDatabase, alias);
  }
}

class GpDisturbanceData extends d.DataClass
    implements d.Insertable<GpDisturbanceData> {
  final int id;
  final int gpSummaryId;
  final String distAgent;
  final int distYr;
  final int distPct;
  final int mortPct;
  final String mortBasis;
  final String? agentType;
  const GpDisturbanceData(
      {required this.id,
      required this.gpSummaryId,
      required this.distAgent,
      required this.distYr,
      required this.distPct,
      required this.mortPct,
      required this.mortBasis,
      this.agentType});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['gp_summary_id'] = d.Variable<int>(gpSummaryId);
    map['dist_agent'] = d.Variable<String>(distAgent);
    map['dist_yr'] = d.Variable<int>(distYr);
    map['dist_pct'] = d.Variable<int>(distPct);
    map['mort_pct'] = d.Variable<int>(mortPct);
    map['mort_basis'] = d.Variable<String>(mortBasis);
    if (!nullToAbsent || agentType != null) {
      map['agent_type'] = d.Variable<String>(agentType);
    }
    return map;
  }

  GpDisturbanceCompanion toCompanion(bool nullToAbsent) {
    return GpDisturbanceCompanion(
      id: d.Value(id),
      gpSummaryId: d.Value(gpSummaryId),
      distAgent: d.Value(distAgent),
      distYr: d.Value(distYr),
      distPct: d.Value(distPct),
      mortPct: d.Value(mortPct),
      mortBasis: d.Value(mortBasis),
      agentType: agentType == null && nullToAbsent
          ? const d.Value.absent()
          : d.Value(agentType),
    );
  }

  factory GpDisturbanceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpDisturbanceData(
      id: serializer.fromJson<int>(json['id']),
      gpSummaryId: serializer.fromJson<int>(json['gpSummaryId']),
      distAgent: serializer.fromJson<String>(json['distAgent']),
      distYr: serializer.fromJson<int>(json['distYr']),
      distPct: serializer.fromJson<int>(json['distPct']),
      mortPct: serializer.fromJson<int>(json['mortPct']),
      mortBasis: serializer.fromJson<String>(json['mortBasis']),
      agentType: serializer.fromJson<String?>(json['agentType']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'gpSummaryId': serializer.toJson<int>(gpSummaryId),
      'distAgent': serializer.toJson<String>(distAgent),
      'distYr': serializer.toJson<int>(distYr),
      'distPct': serializer.toJson<int>(distPct),
      'mortPct': serializer.toJson<int>(mortPct),
      'mortBasis': serializer.toJson<String>(mortBasis),
      'agentType': serializer.toJson<String?>(agentType),
    };
  }

  GpDisturbanceData copyWith(
          {int? id,
          int? gpSummaryId,
          String? distAgent,
          int? distYr,
          int? distPct,
          int? mortPct,
          String? mortBasis,
          d.Value<String?> agentType = const d.Value.absent()}) =>
      GpDisturbanceData(
        id: id ?? this.id,
        gpSummaryId: gpSummaryId ?? this.gpSummaryId,
        distAgent: distAgent ?? this.distAgent,
        distYr: distYr ?? this.distYr,
        distPct: distPct ?? this.distPct,
        mortPct: mortPct ?? this.mortPct,
        mortBasis: mortBasis ?? this.mortBasis,
        agentType: agentType.present ? agentType.value : this.agentType,
      );
  @override
  String toString() {
    return (StringBuffer('GpDisturbanceData(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('distAgent: $distAgent, ')
          ..write('distYr: $distYr, ')
          ..write('distPct: $distPct, ')
          ..write('mortPct: $mortPct, ')
          ..write('mortBasis: $mortBasis, ')
          ..write('agentType: $agentType')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, gpSummaryId, distAgent, distYr, distPct,
      mortPct, mortBasis, agentType);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpDisturbanceData &&
          other.id == this.id &&
          other.gpSummaryId == this.gpSummaryId &&
          other.distAgent == this.distAgent &&
          other.distYr == this.distYr &&
          other.distPct == this.distPct &&
          other.mortPct == this.mortPct &&
          other.mortBasis == this.mortBasis &&
          other.agentType == this.agentType);
}

class GpDisturbanceCompanion extends d.UpdateCompanion<GpDisturbanceData> {
  final d.Value<int> id;
  final d.Value<int> gpSummaryId;
  final d.Value<String> distAgent;
  final d.Value<int> distYr;
  final d.Value<int> distPct;
  final d.Value<int> mortPct;
  final d.Value<String> mortBasis;
  final d.Value<String?> agentType;
  const GpDisturbanceCompanion({
    this.id = const d.Value.absent(),
    this.gpSummaryId = const d.Value.absent(),
    this.distAgent = const d.Value.absent(),
    this.distYr = const d.Value.absent(),
    this.distPct = const d.Value.absent(),
    this.mortPct = const d.Value.absent(),
    this.mortBasis = const d.Value.absent(),
    this.agentType = const d.Value.absent(),
  });
  GpDisturbanceCompanion.insert({
    this.id = const d.Value.absent(),
    required int gpSummaryId,
    required String distAgent,
    required int distYr,
    required int distPct,
    required int mortPct,
    required String mortBasis,
    this.agentType = const d.Value.absent(),
  })  : gpSummaryId = d.Value(gpSummaryId),
        distAgent = d.Value(distAgent),
        distYr = d.Value(distYr),
        distPct = d.Value(distPct),
        mortPct = d.Value(mortPct),
        mortBasis = d.Value(mortBasis);
  static d.Insertable<GpDisturbanceData> custom({
    d.Expression<int>? id,
    d.Expression<int>? gpSummaryId,
    d.Expression<String>? distAgent,
    d.Expression<int>? distYr,
    d.Expression<int>? distPct,
    d.Expression<int>? mortPct,
    d.Expression<String>? mortBasis,
    d.Expression<String>? agentType,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (gpSummaryId != null) 'gp_summary_id': gpSummaryId,
      if (distAgent != null) 'dist_agent': distAgent,
      if (distYr != null) 'dist_yr': distYr,
      if (distPct != null) 'dist_pct': distPct,
      if (mortPct != null) 'mort_pct': mortPct,
      if (mortBasis != null) 'mort_basis': mortBasis,
      if (agentType != null) 'agent_type': agentType,
    });
  }

  GpDisturbanceCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? gpSummaryId,
      d.Value<String>? distAgent,
      d.Value<int>? distYr,
      d.Value<int>? distPct,
      d.Value<int>? mortPct,
      d.Value<String>? mortBasis,
      d.Value<String?>? agentType}) {
    return GpDisturbanceCompanion(
      id: id ?? this.id,
      gpSummaryId: gpSummaryId ?? this.gpSummaryId,
      distAgent: distAgent ?? this.distAgent,
      distYr: distYr ?? this.distYr,
      distPct: distPct ?? this.distPct,
      mortPct: mortPct ?? this.mortPct,
      mortBasis: mortBasis ?? this.mortBasis,
      agentType: agentType ?? this.agentType,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (gpSummaryId.present) {
      map['gp_summary_id'] = d.Variable<int>(gpSummaryId.value);
    }
    if (distAgent.present) {
      map['dist_agent'] = d.Variable<String>(distAgent.value);
    }
    if (distYr.present) {
      map['dist_yr'] = d.Variable<int>(distYr.value);
    }
    if (distPct.present) {
      map['dist_pct'] = d.Variable<int>(distPct.value);
    }
    if (mortPct.present) {
      map['mort_pct'] = d.Variable<int>(mortPct.value);
    }
    if (mortBasis.present) {
      map['mort_basis'] = d.Variable<String>(mortBasis.value);
    }
    if (agentType.present) {
      map['agent_type'] = d.Variable<String>(agentType.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpDisturbanceCompanion(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('distAgent: $distAgent, ')
          ..write('distYr: $distYr, ')
          ..write('distPct: $distPct, ')
          ..write('mortPct: $mortPct, ')
          ..write('mortBasis: $mortBasis, ')
          ..write('agentType: $agentType')
          ..write(')'))
        .toString();
  }
}

class $GpOriginTable extends GpOrigin
    with d.TableInfo<$GpOriginTable, GpOriginData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpOriginTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _gpSummaryIdMeta =
      const d.VerificationMeta('gpSummaryId');
  @override
  late final d.GeneratedColumn<int> gpSummaryId = d.GeneratedColumn<int>(
      'gp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES gp_summary (id)'));
  static const d.VerificationMeta _vegOrigMeta =
      const d.VerificationMeta('vegOrig');
  @override
  late final d.GeneratedColumn<String> vegOrig = d.GeneratedColumn<String>(
      'veg_orig', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 4),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _regenTypeMeta =
      const d.VerificationMeta('regenType');
  @override
  late final d.GeneratedColumn<String> regenType = d.GeneratedColumn<String>(
      'regen_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 3),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _regenYrMeta =
      const d.VerificationMeta('regenYr');
  @override
  late final d.GeneratedColumn<int> regenYr = d.GeneratedColumn<int>(
      'regen_yr', aliasedName, false,
      check: () => regenYr.isBetweenValues(-9, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, gpSummaryId, vegOrig, regenType, regenYr];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_origin';
  @override
  d.VerificationContext validateIntegrity(d.Insertable<GpOriginData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('gp_summary_id')) {
      context.handle(
          _gpSummaryIdMeta,
          gpSummaryId.isAcceptableOrUnknown(
              data['gp_summary_id']!, _gpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_gpSummaryIdMeta);
    }
    if (data.containsKey('veg_orig')) {
      context.handle(_vegOrigMeta,
          vegOrig.isAcceptableOrUnknown(data['veg_orig']!, _vegOrigMeta));
    } else if (isInserting) {
      context.missing(_vegOrigMeta);
    }
    if (data.containsKey('regen_type')) {
      context.handle(_regenTypeMeta,
          regenType.isAcceptableOrUnknown(data['regen_type']!, _regenTypeMeta));
    } else if (isInserting) {
      context.missing(_regenTypeMeta);
    }
    if (data.containsKey('regen_yr')) {
      context.handle(_regenYrMeta,
          regenYr.isAcceptableOrUnknown(data['regen_yr']!, _regenYrMeta));
    } else if (isInserting) {
      context.missing(_regenYrMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  GpOriginData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpOriginData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      gpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gp_summary_id'])!,
      vegOrig: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}veg_orig'])!,
      regenType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}regen_type'])!,
      regenYr: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}regen_yr'])!,
    );
  }

  @override
  $GpOriginTable createAlias(String alias) {
    return $GpOriginTable(attachedDatabase, alias);
  }
}

class GpOriginData extends d.DataClass implements d.Insertable<GpOriginData> {
  final int id;
  final int gpSummaryId;
  final String vegOrig;
  final String regenType;
  final int regenYr;
  const GpOriginData(
      {required this.id,
      required this.gpSummaryId,
      required this.vegOrig,
      required this.regenType,
      required this.regenYr});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['gp_summary_id'] = d.Variable<int>(gpSummaryId);
    map['veg_orig'] = d.Variable<String>(vegOrig);
    map['regen_type'] = d.Variable<String>(regenType);
    map['regen_yr'] = d.Variable<int>(regenYr);
    return map;
  }

  GpOriginCompanion toCompanion(bool nullToAbsent) {
    return GpOriginCompanion(
      id: d.Value(id),
      gpSummaryId: d.Value(gpSummaryId),
      vegOrig: d.Value(vegOrig),
      regenType: d.Value(regenType),
      regenYr: d.Value(regenYr),
    );
  }

  factory GpOriginData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpOriginData(
      id: serializer.fromJson<int>(json['id']),
      gpSummaryId: serializer.fromJson<int>(json['gpSummaryId']),
      vegOrig: serializer.fromJson<String>(json['vegOrig']),
      regenType: serializer.fromJson<String>(json['regenType']),
      regenYr: serializer.fromJson<int>(json['regenYr']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'gpSummaryId': serializer.toJson<int>(gpSummaryId),
      'vegOrig': serializer.toJson<String>(vegOrig),
      'regenType': serializer.toJson<String>(regenType),
      'regenYr': serializer.toJson<int>(regenYr),
    };
  }

  GpOriginData copyWith(
          {int? id,
          int? gpSummaryId,
          String? vegOrig,
          String? regenType,
          int? regenYr}) =>
      GpOriginData(
        id: id ?? this.id,
        gpSummaryId: gpSummaryId ?? this.gpSummaryId,
        vegOrig: vegOrig ?? this.vegOrig,
        regenType: regenType ?? this.regenType,
        regenYr: regenYr ?? this.regenYr,
      );
  @override
  String toString() {
    return (StringBuffer('GpOriginData(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('vegOrig: $vegOrig, ')
          ..write('regenType: $regenType, ')
          ..write('regenYr: $regenYr')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, gpSummaryId, vegOrig, regenType, regenYr);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpOriginData &&
          other.id == this.id &&
          other.gpSummaryId == this.gpSummaryId &&
          other.vegOrig == this.vegOrig &&
          other.regenType == this.regenType &&
          other.regenYr == this.regenYr);
}

class GpOriginCompanion extends d.UpdateCompanion<GpOriginData> {
  final d.Value<int> id;
  final d.Value<int> gpSummaryId;
  final d.Value<String> vegOrig;
  final d.Value<String> regenType;
  final d.Value<int> regenYr;
  const GpOriginCompanion({
    this.id = const d.Value.absent(),
    this.gpSummaryId = const d.Value.absent(),
    this.vegOrig = const d.Value.absent(),
    this.regenType = const d.Value.absent(),
    this.regenYr = const d.Value.absent(),
  });
  GpOriginCompanion.insert({
    this.id = const d.Value.absent(),
    required int gpSummaryId,
    required String vegOrig,
    required String regenType,
    required int regenYr,
  })  : gpSummaryId = d.Value(gpSummaryId),
        vegOrig = d.Value(vegOrig),
        regenType = d.Value(regenType),
        regenYr = d.Value(regenYr);
  static d.Insertable<GpOriginData> custom({
    d.Expression<int>? id,
    d.Expression<int>? gpSummaryId,
    d.Expression<String>? vegOrig,
    d.Expression<String>? regenType,
    d.Expression<int>? regenYr,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (gpSummaryId != null) 'gp_summary_id': gpSummaryId,
      if (vegOrig != null) 'veg_orig': vegOrig,
      if (regenType != null) 'regen_type': regenType,
      if (regenYr != null) 'regen_yr': regenYr,
    });
  }

  GpOriginCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? gpSummaryId,
      d.Value<String>? vegOrig,
      d.Value<String>? regenType,
      d.Value<int>? regenYr}) {
    return GpOriginCompanion(
      id: id ?? this.id,
      gpSummaryId: gpSummaryId ?? this.gpSummaryId,
      vegOrig: vegOrig ?? this.vegOrig,
      regenType: regenType ?? this.regenType,
      regenYr: regenYr ?? this.regenYr,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (gpSummaryId.present) {
      map['gp_summary_id'] = d.Variable<int>(gpSummaryId.value);
    }
    if (vegOrig.present) {
      map['veg_orig'] = d.Variable<String>(vegOrig.value);
    }
    if (regenType.present) {
      map['regen_type'] = d.Variable<String>(regenType.value);
    }
    if (regenYr.present) {
      map['regen_yr'] = d.Variable<int>(regenYr.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpOriginCompanion(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('vegOrig: $vegOrig, ')
          ..write('regenType: $regenType, ')
          ..write('regenYr: $regenYr')
          ..write(')'))
        .toString();
  }
}

class $GpTreatmentTable extends GpTreatment
    with d.TableInfo<$GpTreatmentTable, GpTreatmentData> {
  @override
  final d.GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GpTreatmentTable(this.attachedDatabase, [this._alias]);
  static const d.VerificationMeta _idMeta = const d.VerificationMeta('id');
  @override
  late final d.GeneratedColumn<int> id = d.GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const d.VerificationMeta _gpSummaryIdMeta =
      const d.VerificationMeta('gpSummaryId');
  @override
  late final d.GeneratedColumn<int> gpSummaryId = d.GeneratedColumn<int>(
      'gp_summary_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES gp_summary (id)'));
  static const d.VerificationMeta _treatTypeMeta =
      const d.VerificationMeta('treatType');
  @override
  late final d.GeneratedColumn<String> treatType = d.GeneratedColumn<String>(
      'treat_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 2),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const d.VerificationMeta _treatYrMeta =
      const d.VerificationMeta('treatYr');
  @override
  late final d.GeneratedColumn<int> treatYr = d.GeneratedColumn<int>(
      'treat_yr', aliasedName, false,
      check: () => treatYr.isBetweenValues(-9, 9999),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  static const d.VerificationMeta _treatPctMeta =
      const d.VerificationMeta('treatPct');
  @override
  late final d.GeneratedColumn<int> treatPct = d.GeneratedColumn<int>(
      'treat_pct', aliasedName, false,
      check: () => treatPct.isBetweenValues(-9, 100),
      type: DriftSqlType.int,
      requiredDuringInsert: true);
  @override
  List<d.GeneratedColumn> get $columns =>
      [id, gpSummaryId, treatType, treatYr, treatPct];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'gp_treatment';
  @override
  d.VerificationContext validateIntegrity(
      d.Insertable<GpTreatmentData> instance,
      {bool isInserting = false}) {
    final context = d.VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('gp_summary_id')) {
      context.handle(
          _gpSummaryIdMeta,
          gpSummaryId.isAcceptableOrUnknown(
              data['gp_summary_id']!, _gpSummaryIdMeta));
    } else if (isInserting) {
      context.missing(_gpSummaryIdMeta);
    }
    if (data.containsKey('treat_type')) {
      context.handle(_treatTypeMeta,
          treatType.isAcceptableOrUnknown(data['treat_type']!, _treatTypeMeta));
    } else if (isInserting) {
      context.missing(_treatTypeMeta);
    }
    if (data.containsKey('treat_yr')) {
      context.handle(_treatYrMeta,
          treatYr.isAcceptableOrUnknown(data['treat_yr']!, _treatYrMeta));
    } else if (isInserting) {
      context.missing(_treatYrMeta);
    }
    if (data.containsKey('treat_pct')) {
      context.handle(_treatPctMeta,
          treatPct.isAcceptableOrUnknown(data['treat_pct']!, _treatPctMeta));
    } else if (isInserting) {
      context.missing(_treatPctMeta);
    }
    return context;
  }

  @override
  Set<d.GeneratedColumn> get $primaryKey => {id};
  @override
  GpTreatmentData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GpTreatmentData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      gpSummaryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gp_summary_id'])!,
      treatType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}treat_type'])!,
      treatYr: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}treat_yr'])!,
      treatPct: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}treat_pct'])!,
    );
  }

  @override
  $GpTreatmentTable createAlias(String alias) {
    return $GpTreatmentTable(attachedDatabase, alias);
  }
}

class GpTreatmentData extends d.DataClass
    implements d.Insertable<GpTreatmentData> {
  final int id;
  final int gpSummaryId;
  final String treatType;
  final int treatYr;
  final int treatPct;
  const GpTreatmentData(
      {required this.id,
      required this.gpSummaryId,
      required this.treatType,
      required this.treatYr,
      required this.treatPct});
  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    map['id'] = d.Variable<int>(id);
    map['gp_summary_id'] = d.Variable<int>(gpSummaryId);
    map['treat_type'] = d.Variable<String>(treatType);
    map['treat_yr'] = d.Variable<int>(treatYr);
    map['treat_pct'] = d.Variable<int>(treatPct);
    return map;
  }

  GpTreatmentCompanion toCompanion(bool nullToAbsent) {
    return GpTreatmentCompanion(
      id: d.Value(id),
      gpSummaryId: d.Value(gpSummaryId),
      treatType: d.Value(treatType),
      treatYr: d.Value(treatYr),
      treatPct: d.Value(treatPct),
    );
  }

  factory GpTreatmentData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return GpTreatmentData(
      id: serializer.fromJson<int>(json['id']),
      gpSummaryId: serializer.fromJson<int>(json['gpSummaryId']),
      treatType: serializer.fromJson<String>(json['treatType']),
      treatYr: serializer.fromJson<int>(json['treatYr']),
      treatPct: serializer.fromJson<int>(json['treatPct']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= d.driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'gpSummaryId': serializer.toJson<int>(gpSummaryId),
      'treatType': serializer.toJson<String>(treatType),
      'treatYr': serializer.toJson<int>(treatYr),
      'treatPct': serializer.toJson<int>(treatPct),
    };
  }

  GpTreatmentData copyWith(
          {int? id,
          int? gpSummaryId,
          String? treatType,
          int? treatYr,
          int? treatPct}) =>
      GpTreatmentData(
        id: id ?? this.id,
        gpSummaryId: gpSummaryId ?? this.gpSummaryId,
        treatType: treatType ?? this.treatType,
        treatYr: treatYr ?? this.treatYr,
        treatPct: treatPct ?? this.treatPct,
      );
  @override
  String toString() {
    return (StringBuffer('GpTreatmentData(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('treatType: $treatType, ')
          ..write('treatYr: $treatYr, ')
          ..write('treatPct: $treatPct')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, gpSummaryId, treatType, treatYr, treatPct);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GpTreatmentData &&
          other.id == this.id &&
          other.gpSummaryId == this.gpSummaryId &&
          other.treatType == this.treatType &&
          other.treatYr == this.treatYr &&
          other.treatPct == this.treatPct);
}

class GpTreatmentCompanion extends d.UpdateCompanion<GpTreatmentData> {
  final d.Value<int> id;
  final d.Value<int> gpSummaryId;
  final d.Value<String> treatType;
  final d.Value<int> treatYr;
  final d.Value<int> treatPct;
  const GpTreatmentCompanion({
    this.id = const d.Value.absent(),
    this.gpSummaryId = const d.Value.absent(),
    this.treatType = const d.Value.absent(),
    this.treatYr = const d.Value.absent(),
    this.treatPct = const d.Value.absent(),
  });
  GpTreatmentCompanion.insert({
    this.id = const d.Value.absent(),
    required int gpSummaryId,
    required String treatType,
    required int treatYr,
    required int treatPct,
  })  : gpSummaryId = d.Value(gpSummaryId),
        treatType = d.Value(treatType),
        treatYr = d.Value(treatYr),
        treatPct = d.Value(treatPct);
  static d.Insertable<GpTreatmentData> custom({
    d.Expression<int>? id,
    d.Expression<int>? gpSummaryId,
    d.Expression<String>? treatType,
    d.Expression<int>? treatYr,
    d.Expression<int>? treatPct,
  }) {
    return d.RawValuesInsertable({
      if (id != null) 'id': id,
      if (gpSummaryId != null) 'gp_summary_id': gpSummaryId,
      if (treatType != null) 'treat_type': treatType,
      if (treatYr != null) 'treat_yr': treatYr,
      if (treatPct != null) 'treat_pct': treatPct,
    });
  }

  GpTreatmentCompanion copyWith(
      {d.Value<int>? id,
      d.Value<int>? gpSummaryId,
      d.Value<String>? treatType,
      d.Value<int>? treatYr,
      d.Value<int>? treatPct}) {
    return GpTreatmentCompanion(
      id: id ?? this.id,
      gpSummaryId: gpSummaryId ?? this.gpSummaryId,
      treatType: treatType ?? this.treatType,
      treatYr: treatYr ?? this.treatYr,
      treatPct: treatPct ?? this.treatPct,
    );
  }

  @override
  Map<String, d.Expression> toColumns(bool nullToAbsent) {
    final map = <String, d.Expression>{};
    if (id.present) {
      map['id'] = d.Variable<int>(id.value);
    }
    if (gpSummaryId.present) {
      map['gp_summary_id'] = d.Variable<int>(gpSummaryId.value);
    }
    if (treatType.present) {
      map['treat_type'] = d.Variable<String>(treatType.value);
    }
    if (treatYr.present) {
      map['treat_yr'] = d.Variable<int>(treatYr.value);
    }
    if (treatPct.present) {
      map['treat_pct'] = d.Variable<int>(treatPct.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GpTreatmentCompanion(')
          ..write('id: $id, ')
          ..write('gpSummaryId: $gpSummaryId, ')
          ..write('treatType: $treatType, ')
          ..write('treatYr: $treatYr, ')
          ..write('treatPct: $treatPct')
          ..write(')'))
        .toString();
  }
}

abstract class _$Database extends d.GeneratedDatabase {
  _$Database(QueryExecutor e) : super(e);
  _$DatabaseManager get managers => _$DatabaseManager(this);
  late final $JurisdictionsTable jurisdictions = $JurisdictionsTable(this);
  late final $PlotsTable plots = $PlotsTable(this);
  late final $TreeGenusTable treeGenus = $TreeGenusTable(this);
  late final $SubstrateTypeTable substrateType = $SubstrateTypeTable(this);
  late final $SsDepthLimitTable ssDepthLimit = $SsDepthLimitTable(this);
  late final $EcpGenusTable ecpGenus = $EcpGenusTable(this);
  late final $EcpLayerTable ecpLayer = $EcpLayerTable(this);
  late final $EcpPlotTypeTable ecpPlotType = $EcpPlotTypeTable(this);
  late final $SoilPitClassificationTable soilPitClassification =
      $SoilPitClassificationTable(this);
  late final $SoilDrainageClassTable soilDrainageClass =
      $SoilDrainageClassTable(this);
  late final $SoilMoistureClassTable soilMoistureClass =
      $SoilMoistureClassTable(this);
  late final $SoilDepositionTable soilDeposition = $SoilDepositionTable(this);
  late final $SoilHumusFormTable soilHumusForm = $SoilHumusFormTable(this);
  late final $SoilPitCodeTable soilPitCode = $SoilPitCodeTable(this);
  late final $SoilPitFeatureClassTable soilPitFeatureClass =
      $SoilPitFeatureClassTable(this);
  late final $SoilHorizonDesignationTable soilHorizonDesignation =
      $SoilHorizonDesignationTable(this);
  late final $SoilColorTable soilColor = $SoilColorTable(this);
  late final $SoilTextureTable soilTexture = $SoilTextureTable(this);
  late final $StpTypeTable stpType = $StpTypeTable(this);
  late final $StpOrigPlotAreaTable stpOrigPlotArea =
      $StpOrigPlotAreaTable(this);
  late final $StpStatusFieldTable stpStatusField = $StpStatusFieldTable(this);
  late final $StpHeightTable stpHeight = $StpHeightTable(this);
  late final $StpStemConditionTable stpStemCondition =
      $StpStemConditionTable(this);
  late final $ShrubPlotTypeTable shrubPlotType = $ShrubPlotTypeTable(this);
  late final $ShrubStatusFieldTable shrubStatusField =
      $ShrubStatusFieldTable(this);
  late final $ShrubBasalDiameterTable shrubBasalDiameter =
      $ShrubBasalDiameterTable(this);
  late final $StumpPlotTypeTable stumpPlotType = $StumpPlotTypeTable(this);
  late final $StumpOrigPlotAreaTable stumpOrigPlotArea =
      $StumpOrigPlotAreaTable(this);
  late final $LtpPlotTypeTable ltpPlotType = $LtpPlotTypeTable(this);
  late final $LtpPlotSplitTable ltpPlotSplit = $LtpPlotSplitTable(this);
  late final $LtpOrigPlotAreaTable ltpOrigPlotArea =
      $LtpOrigPlotAreaTable(this);
  late final $LtpStatusFieldTable ltpStatusField = $LtpStatusFieldTable(this);
  late final $LtpGenusTable ltpGenus = $LtpGenusTable(this);
  late final $LtpCrownClassFieldTable ltpCrownClassField =
      $LtpCrownClassFieldTable(this);
  late final $LtpBarkConditionTable ltpBarkCondition =
      $LtpBarkConditionTable(this);
  late final $LtpCrownConditionTable ltpCrownCondition =
      $LtpCrownConditionTable(this);
  late final $LtpStemConditionTable ltpStemCondition =
      $LtpStemConditionTable(this);
  late final $LtpWoodConditionTable ltpWoodCondition =
      $LtpWoodConditionTable(this);
  late final $LtpQuadrantTable ltpQuadrant = $LtpQuadrantTable(this);
  late final $LtpTreeTypeTable ltpTreeType = $LtpTreeTypeTable(this);
  late final $LtpSiteHeightSuitabilityTable ltpSiteHeightSuitability =
      $LtpSiteHeightSuitabilityTable(this);
  late final $LtpSiteAgeSuitabilityTable ltpSiteAgeSuitability =
      $LtpSiteAgeSuitabilityTable(this);
  late final $LtpProrateTable ltpProrate = $LtpProrateTable(this);
  late final $GpSiteInfoStandStructureTable gpSiteInfoStandStructure =
      $GpSiteInfoStandStructureTable(this);
  late final $GpSiteInfoSuccessionStageTable gpSiteInfoSuccessionStage =
      $GpSiteInfoSuccessionStageTable(this);
  late final $GpSiteInfoUtmZoneTable gpSiteInfoUtmZone =
      $GpSiteInfoUtmZoneTable(this);
  late final $GpSiteInfoVegTypeTable gpSiteInfoVegType =
      $GpSiteInfoVegTypeTable(this);
  late final $GpSiteInfoWetlandTable gpSiteInfoWetland =
      $GpSiteInfoWetlandTable(this);
  late final $GpSiteInfoEcozoneTable gpSiteInfoEcozone =
      $GpSiteInfoEcozoneTable(this);
  late final $GpSiteInfoPlotCompletionTable gpSiteInfoPlotCompletion =
      $GpSiteInfoPlotCompletionTable(this);
  late final $GpSiteInfoDensityTable gpSiteInfoDensity =
      $GpSiteInfoDensityTable(this);
  late final $GpSiteInfoLandBaseTable gpSiteInfoLandBase =
      $GpSiteInfoLandBaseTable(this);
  late final $GpSiteInfoLandCoverTable gpSiteInfoLandCover =
      $GpSiteInfoLandCoverTable(this);
  late final $GpSiteInfoLandPosTable gpSiteInfoLandPos =
      $GpSiteInfoLandPosTable(this);
  late final $GpSiteInfoPostProcessingTable gpSiteInfoPostProcessing =
      $GpSiteInfoPostProcessingTable(this);
  late final $GpSiteInfoPlotIncompleteReasonTable
      gpSiteInfoPlotIncompleteReason =
      $GpSiteInfoPlotIncompleteReasonTable(this);
  late final $GpDistAgentTable gpDistAgent = $GpDistAgentTable(this);
  late final $SurveyHeadersTable surveyHeaders = $SurveyHeadersTable(this);
  late final $MetaCommentTable metaComment = $MetaCommentTable(this);
  late final $SurveySummaryTable surveySummary = $SurveySummaryTable(this);
  late final $SurveyHeaderGroundPhotoTable surveyHeaderGroundPhoto =
      $SurveyHeaderGroundPhotoTable(this);
  late final $SurveyHeaderTreeTable surveyHeaderTree =
      $SurveyHeaderTreeTable(this);
  late final $SurveyHeaderEcologicalTable surveyHeaderEcological =
      $SurveyHeaderEcologicalTable(this);
  late final $SurveyHeaderSoilTable surveyHeaderSoil =
      $SurveyHeaderSoilTable(this);
  late final $WoodyDebrisSummaryTable woodyDebrisSummary =
      $WoodyDebrisSummaryTable(this);
  late final $WoodyDebrisHeaderTable woodyDebrisHeader =
      $WoodyDebrisHeaderTable(this);
  late final $WoodyDebrisSmallTable woodyDebrisSmall =
      $WoodyDebrisSmallTable(this);
  late final $WoodyDebrisOddTable woodyDebrisOdd = $WoodyDebrisOddTable(this);
  late final $WoodyDebrisRoundTable woodyDebrisRound =
      $WoodyDebrisRoundTable(this);
  late final $SurfaceSubstrateSummaryTable surfaceSubstrateSummary =
      $SurfaceSubstrateSummaryTable(this);
  late final $SurfaceSubstrateHeaderTable surfaceSubstrateHeader =
      $SurfaceSubstrateHeaderTable(this);
  late final $SurfaceSubstrateTallyTable surfaceSubstrateTally =
      $SurfaceSubstrateTallyTable(this);
  late final $EcpSummaryTable ecpSummary = $EcpSummaryTable(this);
  late final $EcpHeaderTable ecpHeader = $EcpHeaderTable(this);
  late final $EcpSpeciesTable ecpSpecies = $EcpSpeciesTable(this);
  late final $SoilPitSummaryTable soilPitSummary = $SoilPitSummaryTable(this);
  late final $SoilSiteInfoTable soilSiteInfo = $SoilSiteInfoTable(this);
  late final $SoilPitFeatureTable soilPitFeature = $SoilPitFeatureTable(this);
  late final $SoilPitHorizonDescriptionTable soilPitHorizonDescription =
      $SoilPitHorizonDescriptionTable(this);
  late final $LtpSummaryTable ltpSummary = $LtpSummaryTable(this);
  late final $LtpTreeTable ltpTree = $LtpTreeTable(this);
  late final $LtpTreeDamageTable ltpTreeDamage = $LtpTreeDamageTable(this);
  late final $LtpTreeRemovedTable ltpTreeRemoved = $LtpTreeRemovedTable(this);
  late final $LtpTreeAgeTable ltpTreeAge = $LtpTreeAgeTable(this);
  late final $LtpTreeRenamedTable ltpTreeRenamed = $LtpTreeRenamedTable(this);
  late final $StpSummaryTable stpSummary = $StpSummaryTable(this);
  late final $StpSpeciesTable stpSpecies = $StpSpeciesTable(this);
  late final $ShrubSummaryTable shrubSummary = $ShrubSummaryTable(this);
  late final $ShrubListEntryTable shrubListEntry = $ShrubListEntryTable(this);
  late final $StumpSummaryTable stumpSummary = $StumpSummaryTable(this);
  late final $StumpEntryTable stumpEntry = $StumpEntryTable(this);
  late final $GpSummaryTable gpSummary = $GpSummaryTable(this);
  late final $GpSiteInfoTable gpSiteInfo = $GpSiteInfoTable(this);
  late final $GpDisturbanceTable gpDisturbance = $GpDisturbanceTable(this);
  late final $GpOriginTable gpOrigin = $GpOriginTable(this);
  late final $GpTreatmentTable gpTreatment = $GpTreatmentTable(this);
  late final ReferenceTablesDao referenceTablesDao =
      ReferenceTablesDao(this as Database);
  late final SurveyInfoTablesDao surveyInfoTablesDao =
      SurveyInfoTablesDao(this as Database);
  late final WoodyDebrisTablesDao woodyDebrisTablesDao =
      WoodyDebrisTablesDao(this as Database);
  late final SurfaceSubstrateTablesDao surfaceSubstrateTablesDao =
      SurfaceSubstrateTablesDao(this as Database);
  late final EcologicalPlotTablesDao ecologicalPlotTablesDao =
      EcologicalPlotTablesDao(this as Database);
  late final SoilPitTablesDao soilPitTablesDao =
      SoilPitTablesDao(this as Database);
  late final SmallTreePlotTablesDao smallTreePlotTablesDao =
      SmallTreePlotTablesDao(this as Database);
  late final ShrubPlotTablesDao shrubPlotTablesDao =
      ShrubPlotTablesDao(this as Database);
  late final StumpPlotTablesDao stumpPlotTablesDao =
      StumpPlotTablesDao(this as Database);
  late final LargeTreePlotTablesDao largeTreePlotTablesDao =
      LargeTreePlotTablesDao(this as Database);
  late final SiteInfoTablesDao siteInfoTablesDao =
      SiteInfoTablesDao(this as Database);
  @override
  Iterable<d.TableInfo<d.Table, Object?>> get allTables =>
      allSchemaEntities.whereType<d.TableInfo<d.Table, Object?>>();
  @override
  List<d.DatabaseSchemaEntity> get allSchemaEntities => [
        jurisdictions,
        plots,
        treeGenus,
        substrateType,
        ssDepthLimit,
        ecpGenus,
        ecpLayer,
        ecpPlotType,
        soilPitClassification,
        soilDrainageClass,
        soilMoistureClass,
        soilDeposition,
        soilHumusForm,
        soilPitCode,
        soilPitFeatureClass,
        soilHorizonDesignation,
        soilColor,
        soilTexture,
        stpType,
        stpOrigPlotArea,
        stpStatusField,
        stpHeight,
        stpStemCondition,
        shrubPlotType,
        shrubStatusField,
        shrubBasalDiameter,
        stumpPlotType,
        stumpOrigPlotArea,
        ltpPlotType,
        ltpPlotSplit,
        ltpOrigPlotArea,
        ltpStatusField,
        ltpGenus,
        ltpCrownClassField,
        ltpBarkCondition,
        ltpCrownCondition,
        ltpStemCondition,
        ltpWoodCondition,
        ltpQuadrant,
        ltpTreeType,
        ltpSiteHeightSuitability,
        ltpSiteAgeSuitability,
        ltpProrate,
        gpSiteInfoStandStructure,
        gpSiteInfoSuccessionStage,
        gpSiteInfoUtmZone,
        gpSiteInfoVegType,
        gpSiteInfoWetland,
        gpSiteInfoEcozone,
        gpSiteInfoPlotCompletion,
        gpSiteInfoDensity,
        gpSiteInfoLandBase,
        gpSiteInfoLandCover,
        gpSiteInfoLandPos,
        gpSiteInfoPostProcessing,
        gpSiteInfoPlotIncompleteReason,
        gpDistAgent,
        surveyHeaders,
        metaComment,
        surveySummary,
        surveyHeaderGroundPhoto,
        surveyHeaderTree,
        surveyHeaderEcological,
        surveyHeaderSoil,
        woodyDebrisSummary,
        woodyDebrisHeader,
        woodyDebrisSmall,
        woodyDebrisOdd,
        woodyDebrisRound,
        surfaceSubstrateSummary,
        surfaceSubstrateHeader,
        surfaceSubstrateTally,
        ecpSummary,
        ecpHeader,
        ecpSpecies,
        soilPitSummary,
        soilSiteInfo,
        soilPitFeature,
        soilPitHorizonDescription,
        ltpSummary,
        ltpTree,
        ltpTreeDamage,
        ltpTreeRemoved,
        ltpTreeAge,
        ltpTreeRenamed,
        stpSummary,
        stpSpecies,
        shrubSummary,
        shrubListEntry,
        stumpSummary,
        stumpEntry,
        gpSummary,
        gpSiteInfo,
        gpDisturbance,
        gpOrigin,
        gpTreatment
      ];
}

typedef $$JurisdictionsTableInsertCompanionBuilder = JurisdictionsCompanion
    Function({
  required String code,
  required String nameEn,
  required String nameFr,
  d.Value<int> rowid,
});
typedef $$JurisdictionsTableUpdateCompanionBuilder = JurisdictionsCompanion
    Function({
  d.Value<String> code,
  d.Value<String> nameEn,
  d.Value<String> nameFr,
  d.Value<int> rowid,
});

class $$JurisdictionsTableTableManager extends d.RootTableManager<
    _$Database,
    $JurisdictionsTable,
    Jurisdiction,
    $$JurisdictionsTableFilterComposer,
    $$JurisdictionsTableOrderingComposer,
    $$JurisdictionsTableProcessedTableManager,
    $$JurisdictionsTableInsertCompanionBuilder,
    $$JurisdictionsTableUpdateCompanionBuilder> {
  $$JurisdictionsTableTableManager(_$Database db, $JurisdictionsTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$JurisdictionsTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$JurisdictionsTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$JurisdictionsTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> nameEn = const d.Value.absent(),
            d.Value<String> nameFr = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              JurisdictionsCompanion(
            code: code,
            nameEn: nameEn,
            nameFr: nameFr,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String nameEn,
            required String nameFr,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              JurisdictionsCompanion.insert(
            code: code,
            nameEn: nameEn,
            nameFr: nameFr,
            rowid: rowid,
          ),
        ));
}

class $$JurisdictionsTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $JurisdictionsTable,
    Jurisdiction,
    $$JurisdictionsTableFilterComposer,
    $$JurisdictionsTableOrderingComposer,
    $$JurisdictionsTableProcessedTableManager,
    $$JurisdictionsTableInsertCompanionBuilder,
    $$JurisdictionsTableUpdateCompanionBuilder> {
  $$JurisdictionsTableProcessedTableManager(super.$state);
}

class $$JurisdictionsTableFilterComposer
    extends d.FilterComposer<_$Database, $JurisdictionsTable> {
  $$JurisdictionsTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ComposableFilter plotsRefs(
      d.ComposableFilter Function($$PlotsTableFilterComposer f) f) {
    final $$PlotsTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.code,
        referencedTable: $state.db.plots,
        getReferencedColumn: (t) => t.code,
        builder: (joinBuilder, parentComposers) => $$PlotsTableFilterComposer(
            d.ComposerState(
                $state.db, $state.db.plots, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveyHeadersRefs(
      d.ComposableFilter Function($$SurveyHeadersTableFilterComposer f) f) {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.code,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.province,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$JurisdictionsTableOrderingComposer
    extends d.OrderingComposer<_$Database, $JurisdictionsTable> {
  $$JurisdictionsTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$PlotsTableInsertCompanionBuilder = PlotsCompanion Function({
  d.Value<int> nfiPlot,
  required String code,
  d.Value<int?> lastMeasNum,
});
typedef $$PlotsTableUpdateCompanionBuilder = PlotsCompanion Function({
  d.Value<int> nfiPlot,
  d.Value<String> code,
  d.Value<int?> lastMeasNum,
});

class $$PlotsTableTableManager extends d.RootTableManager<
    _$Database,
    $PlotsTable,
    Plot,
    $$PlotsTableFilterComposer,
    $$PlotsTableOrderingComposer,
    $$PlotsTableProcessedTableManager,
    $$PlotsTableInsertCompanionBuilder,
    $$PlotsTableUpdateCompanionBuilder> {
  $$PlotsTableTableManager(_$Database db, $PlotsTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$PlotsTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$PlotsTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$PlotsTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> nfiPlot = const d.Value.absent(),
            d.Value<String> code = const d.Value.absent(),
            d.Value<int?> lastMeasNum = const d.Value.absent(),
          }) =>
              PlotsCompanion(
            nfiPlot: nfiPlot,
            code: code,
            lastMeasNum: lastMeasNum,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> nfiPlot = const d.Value.absent(),
            required String code,
            d.Value<int?> lastMeasNum = const d.Value.absent(),
          }) =>
              PlotsCompanion.insert(
            nfiPlot: nfiPlot,
            code: code,
            lastMeasNum: lastMeasNum,
          ),
        ));
}

class $$PlotsTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $PlotsTable,
    Plot,
    $$PlotsTableFilterComposer,
    $$PlotsTableOrderingComposer,
    $$PlotsTableProcessedTableManager,
    $$PlotsTableInsertCompanionBuilder,
    $$PlotsTableUpdateCompanionBuilder> {
  $$PlotsTableProcessedTableManager(super.$state);
}

class $$PlotsTableFilterComposer
    extends d.FilterComposer<_$Database, $PlotsTable> {
  $$PlotsTableFilterComposer(super.$state);
  d.ColumnFilters<int> get lastMeasNum => $state.composableBuilder(
      column: $state.table.lastMeasNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$PlotsTableFilterComposer get nfiPlot {
    final $$PlotsTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.nfiPlot,
        referencedTable: $state.db.plots,
        getReferencedColumn: (t) => t.nfiPlot,
        builder: (joinBuilder, parentComposers) => $$PlotsTableFilterComposer(
            d.ComposerState(
                $state.db, $state.db.plots, joinBuilder, parentComposers)));
    return composer;
  }

  $$JurisdictionsTableFilterComposer get code {
    final $$JurisdictionsTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.code,
        referencedTable: $state.db.jurisdictions,
        getReferencedColumn: (t) => t.code,
        builder: (joinBuilder, parentComposers) =>
            $$JurisdictionsTableFilterComposer(d.ComposerState($state.db,
                $state.db.jurisdictions, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter surveyHeadersRefs(
      d.ComposableFilter Function($$SurveyHeadersTableFilterComposer f) f) {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.nfiPlot,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.nfiPlot,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$PlotsTableOrderingComposer
    extends d.OrderingComposer<_$Database, $PlotsTable> {
  $$PlotsTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get lastMeasNum => $state.composableBuilder(
      column: $state.table.lastMeasNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$PlotsTableOrderingComposer get nfiPlot {
    final $$PlotsTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.nfiPlot,
        referencedTable: $state.db.plots,
        getReferencedColumn: (t) => t.nfiPlot,
        builder: (joinBuilder, parentComposers) => $$PlotsTableOrderingComposer(
            d.ComposerState(
                $state.db, $state.db.plots, joinBuilder, parentComposers)));
    return composer;
  }

  $$JurisdictionsTableOrderingComposer get code {
    final $$JurisdictionsTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.code,
            referencedTable: $state.db.jurisdictions,
            getReferencedColumn: (t) => t.code,
            builder: (joinBuilder, parentComposers) =>
                $$JurisdictionsTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.jurisdictions, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$TreeGenusTableInsertCompanionBuilder = TreeGenusCompanion Function({
  required String genusCode,
  required String speciesCode,
  required String genusLatinName,
  required String speciesLatinName,
  required String commonNameEn,
  required String commonNameFr,
  d.Value<int> rowid,
});
typedef $$TreeGenusTableUpdateCompanionBuilder = TreeGenusCompanion Function({
  d.Value<String> genusCode,
  d.Value<String> speciesCode,
  d.Value<String> genusLatinName,
  d.Value<String> speciesLatinName,
  d.Value<String> commonNameEn,
  d.Value<String> commonNameFr,
  d.Value<int> rowid,
});

class $$TreeGenusTableTableManager extends d.RootTableManager<
    _$Database,
    $TreeGenusTable,
    TreeGenusData,
    $$TreeGenusTableFilterComposer,
    $$TreeGenusTableOrderingComposer,
    $$TreeGenusTableProcessedTableManager,
    $$TreeGenusTableInsertCompanionBuilder,
    $$TreeGenusTableUpdateCompanionBuilder> {
  $$TreeGenusTableTableManager(_$Database db, $TreeGenusTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$TreeGenusTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$TreeGenusTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$TreeGenusTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> genusCode = const d.Value.absent(),
            d.Value<String> speciesCode = const d.Value.absent(),
            d.Value<String> genusLatinName = const d.Value.absent(),
            d.Value<String> speciesLatinName = const d.Value.absent(),
            d.Value<String> commonNameEn = const d.Value.absent(),
            d.Value<String> commonNameFr = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              TreeGenusCompanion(
            genusCode: genusCode,
            speciesCode: speciesCode,
            genusLatinName: genusLatinName,
            speciesLatinName: speciesLatinName,
            commonNameEn: commonNameEn,
            commonNameFr: commonNameFr,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String genusCode,
            required String speciesCode,
            required String genusLatinName,
            required String speciesLatinName,
            required String commonNameEn,
            required String commonNameFr,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              TreeGenusCompanion.insert(
            genusCode: genusCode,
            speciesCode: speciesCode,
            genusLatinName: genusLatinName,
            speciesLatinName: speciesLatinName,
            commonNameEn: commonNameEn,
            commonNameFr: commonNameFr,
            rowid: rowid,
          ),
        ));
}

class $$TreeGenusTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $TreeGenusTable,
    TreeGenusData,
    $$TreeGenusTableFilterComposer,
    $$TreeGenusTableOrderingComposer,
    $$TreeGenusTableProcessedTableManager,
    $$TreeGenusTableInsertCompanionBuilder,
    $$TreeGenusTableUpdateCompanionBuilder> {
  $$TreeGenusTableProcessedTableManager(super.$state);
}

class $$TreeGenusTableFilterComposer
    extends d.FilterComposer<_$Database, $TreeGenusTable> {
  $$TreeGenusTableFilterComposer(super.$state);
  d.ColumnFilters<String> get genusCode => $state.composableBuilder(
      column: $state.table.genusCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get speciesCode => $state.composableBuilder(
      column: $state.table.speciesCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get genusLatinName => $state.composableBuilder(
      column: $state.table.genusLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get speciesLatinName => $state.composableBuilder(
      column: $state.table.speciesLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get commonNameEn => $state.composableBuilder(
      column: $state.table.commonNameEn,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get commonNameFr => $state.composableBuilder(
      column: $state.table.commonNameFr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$TreeGenusTableOrderingComposer
    extends d.OrderingComposer<_$Database, $TreeGenusTable> {
  $$TreeGenusTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get genusCode => $state.composableBuilder(
      column: $state.table.genusCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get speciesCode => $state.composableBuilder(
      column: $state.table.speciesCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get genusLatinName => $state.composableBuilder(
      column: $state.table.genusLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get speciesLatinName => $state.composableBuilder(
      column: $state.table.speciesLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get commonNameEn => $state.composableBuilder(
      column: $state.table.commonNameEn,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get commonNameFr => $state.composableBuilder(
      column: $state.table.commonNameFr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SubstrateTypeTableInsertCompanionBuilder = SubstrateTypeCompanion
    Function({
  required String typeCode,
  required String nameEn,
  required String nameFr,
  required bool hasDepth,
  d.Value<int> rowid,
});
typedef $$SubstrateTypeTableUpdateCompanionBuilder = SubstrateTypeCompanion
    Function({
  d.Value<String> typeCode,
  d.Value<String> nameEn,
  d.Value<String> nameFr,
  d.Value<bool> hasDepth,
  d.Value<int> rowid,
});

class $$SubstrateTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $SubstrateTypeTable,
    SubstrateTypeData,
    $$SubstrateTypeTableFilterComposer,
    $$SubstrateTypeTableOrderingComposer,
    $$SubstrateTypeTableProcessedTableManager,
    $$SubstrateTypeTableInsertCompanionBuilder,
    $$SubstrateTypeTableUpdateCompanionBuilder> {
  $$SubstrateTypeTableTableManager(_$Database db, $SubstrateTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SubstrateTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SubstrateTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SubstrateTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> typeCode = const d.Value.absent(),
            d.Value<String> nameEn = const d.Value.absent(),
            d.Value<String> nameFr = const d.Value.absent(),
            d.Value<bool> hasDepth = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SubstrateTypeCompanion(
            typeCode: typeCode,
            nameEn: nameEn,
            nameFr: nameFr,
            hasDepth: hasDepth,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String typeCode,
            required String nameEn,
            required String nameFr,
            required bool hasDepth,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SubstrateTypeCompanion.insert(
            typeCode: typeCode,
            nameEn: nameEn,
            nameFr: nameFr,
            hasDepth: hasDepth,
            rowid: rowid,
          ),
        ));
}

class $$SubstrateTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SubstrateTypeTable,
    SubstrateTypeData,
    $$SubstrateTypeTableFilterComposer,
    $$SubstrateTypeTableOrderingComposer,
    $$SubstrateTypeTableProcessedTableManager,
    $$SubstrateTypeTableInsertCompanionBuilder,
    $$SubstrateTypeTableUpdateCompanionBuilder> {
  $$SubstrateTypeTableProcessedTableManager(super.$state);
}

class $$SubstrateTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $SubstrateTypeTable> {
  $$SubstrateTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get typeCode => $state.composableBuilder(
      column: $state.table.typeCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get hasDepth => $state.composableBuilder(
      column: $state.table.hasDepth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SubstrateTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SubstrateTypeTable> {
  $$SubstrateTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get typeCode => $state.composableBuilder(
      column: $state.table.typeCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get hasDepth => $state.composableBuilder(
      column: $state.table.hasDepth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SsDepthLimitTableInsertCompanionBuilder = SsDepthLimitCompanion
    Function({
  required int code,
  required String nameEn,
  required String nameFr,
  d.Value<int> rowid,
});
typedef $$SsDepthLimitTableUpdateCompanionBuilder = SsDepthLimitCompanion
    Function({
  d.Value<int> code,
  d.Value<String> nameEn,
  d.Value<String> nameFr,
  d.Value<int> rowid,
});

class $$SsDepthLimitTableTableManager extends d.RootTableManager<
    _$Database,
    $SsDepthLimitTable,
    SsDepthLimitData,
    $$SsDepthLimitTableFilterComposer,
    $$SsDepthLimitTableOrderingComposer,
    $$SsDepthLimitTableProcessedTableManager,
    $$SsDepthLimitTableInsertCompanionBuilder,
    $$SsDepthLimitTableUpdateCompanionBuilder> {
  $$SsDepthLimitTableTableManager(_$Database db, $SsDepthLimitTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SsDepthLimitTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SsDepthLimitTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SsDepthLimitTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> code = const d.Value.absent(),
            d.Value<String> nameEn = const d.Value.absent(),
            d.Value<String> nameFr = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SsDepthLimitCompanion(
            code: code,
            nameEn: nameEn,
            nameFr: nameFr,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required int code,
            required String nameEn,
            required String nameFr,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SsDepthLimitCompanion.insert(
            code: code,
            nameEn: nameEn,
            nameFr: nameFr,
            rowid: rowid,
          ),
        ));
}

class $$SsDepthLimitTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SsDepthLimitTable,
    SsDepthLimitData,
    $$SsDepthLimitTableFilterComposer,
    $$SsDepthLimitTableOrderingComposer,
    $$SsDepthLimitTableProcessedTableManager,
    $$SsDepthLimitTableInsertCompanionBuilder,
    $$SsDepthLimitTableUpdateCompanionBuilder> {
  $$SsDepthLimitTableProcessedTableManager(super.$state);
}

class $$SsDepthLimitTableFilterComposer
    extends d.FilterComposer<_$Database, $SsDepthLimitTable> {
  $$SsDepthLimitTableFilterComposer(super.$state);
  d.ColumnFilters<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SsDepthLimitTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SsDepthLimitTable> {
  $$SsDepthLimitTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameEn => $state.composableBuilder(
      column: $state.table.nameEn,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get nameFr => $state.composableBuilder(
      column: $state.table.nameFr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$EcpGenusTableInsertCompanionBuilder = EcpGenusCompanion Function({
  required String genus,
  required String species,
  required String variety,
  d.Value<int> rowid,
});
typedef $$EcpGenusTableUpdateCompanionBuilder = EcpGenusCompanion Function({
  d.Value<String> genus,
  d.Value<String> species,
  d.Value<String> variety,
  d.Value<int> rowid,
});

class $$EcpGenusTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpGenusTable,
    EcpGenusData,
    $$EcpGenusTableFilterComposer,
    $$EcpGenusTableOrderingComposer,
    $$EcpGenusTableProcessedTableManager,
    $$EcpGenusTableInsertCompanionBuilder,
    $$EcpGenusTableUpdateCompanionBuilder> {
  $$EcpGenusTableTableManager(_$Database db, $EcpGenusTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpGenusTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpGenusTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpGenusTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> genus = const d.Value.absent(),
            d.Value<String> species = const d.Value.absent(),
            d.Value<String> variety = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpGenusCompanion(
            genus: genus,
            species: species,
            variety: variety,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String genus,
            required String species,
            required String variety,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpGenusCompanion.insert(
            genus: genus,
            species: species,
            variety: variety,
            rowid: rowid,
          ),
        ));
}

class $$EcpGenusTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpGenusTable,
    EcpGenusData,
    $$EcpGenusTableFilterComposer,
    $$EcpGenusTableOrderingComposer,
    $$EcpGenusTableProcessedTableManager,
    $$EcpGenusTableInsertCompanionBuilder,
    $$EcpGenusTableUpdateCompanionBuilder> {
  $$EcpGenusTableProcessedTableManager(super.$state);
}

class $$EcpGenusTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpGenusTable> {
  $$EcpGenusTableFilterComposer(super.$state);
  d.ColumnFilters<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$EcpGenusTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpGenusTable> {
  $$EcpGenusTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$EcpLayerTableInsertCompanionBuilder = EcpLayerCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$EcpLayerTableUpdateCompanionBuilder = EcpLayerCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$EcpLayerTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpLayerTable,
    EcpLayerData,
    $$EcpLayerTableFilterComposer,
    $$EcpLayerTableOrderingComposer,
    $$EcpLayerTableProcessedTableManager,
    $$EcpLayerTableInsertCompanionBuilder,
    $$EcpLayerTableUpdateCompanionBuilder> {
  $$EcpLayerTableTableManager(_$Database db, $EcpLayerTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpLayerTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpLayerTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpLayerTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpLayerCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpLayerCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$EcpLayerTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpLayerTable,
    EcpLayerData,
    $$EcpLayerTableFilterComposer,
    $$EcpLayerTableOrderingComposer,
    $$EcpLayerTableProcessedTableManager,
    $$EcpLayerTableInsertCompanionBuilder,
    $$EcpLayerTableUpdateCompanionBuilder> {
  $$EcpLayerTableProcessedTableManager(super.$state);
}

class $$EcpLayerTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpLayerTable> {
  $$EcpLayerTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$EcpLayerTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpLayerTable> {
  $$EcpLayerTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$EcpPlotTypeTableInsertCompanionBuilder = EcpPlotTypeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$EcpPlotTypeTableUpdateCompanionBuilder = EcpPlotTypeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$EcpPlotTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpPlotTypeTable,
    EcpPlotTypeData,
    $$EcpPlotTypeTableFilterComposer,
    $$EcpPlotTypeTableOrderingComposer,
    $$EcpPlotTypeTableProcessedTableManager,
    $$EcpPlotTypeTableInsertCompanionBuilder,
    $$EcpPlotTypeTableUpdateCompanionBuilder> {
  $$EcpPlotTypeTableTableManager(_$Database db, $EcpPlotTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpPlotTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpPlotTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpPlotTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpPlotTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              EcpPlotTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$EcpPlotTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpPlotTypeTable,
    EcpPlotTypeData,
    $$EcpPlotTypeTableFilterComposer,
    $$EcpPlotTypeTableOrderingComposer,
    $$EcpPlotTypeTableProcessedTableManager,
    $$EcpPlotTypeTableInsertCompanionBuilder,
    $$EcpPlotTypeTableUpdateCompanionBuilder> {
  $$EcpPlotTypeTableProcessedTableManager(super.$state);
}

class $$EcpPlotTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpPlotTypeTable> {
  $$EcpPlotTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$EcpPlotTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpPlotTypeTable> {
  $$EcpPlotTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilPitClassificationTableInsertCompanionBuilder
    = SoilPitClassificationCompanion Function({
  required String code,
  required String order,
  required String greatGroup,
  required String subGroup,
  d.Value<int> rowid,
});
typedef $$SoilPitClassificationTableUpdateCompanionBuilder
    = SoilPitClassificationCompanion Function({
  d.Value<String> code,
  d.Value<String> order,
  d.Value<String> greatGroup,
  d.Value<String> subGroup,
  d.Value<int> rowid,
});

class $$SoilPitClassificationTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitClassificationTable,
    SoilPitClassificationData,
    $$SoilPitClassificationTableFilterComposer,
    $$SoilPitClassificationTableOrderingComposer,
    $$SoilPitClassificationTableProcessedTableManager,
    $$SoilPitClassificationTableInsertCompanionBuilder,
    $$SoilPitClassificationTableUpdateCompanionBuilder> {
  $$SoilPitClassificationTableTableManager(
      _$Database db, $SoilPitClassificationTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilPitClassificationTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilPitClassificationTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitClassificationTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> order = const d.Value.absent(),
            d.Value<String> greatGroup = const d.Value.absent(),
            d.Value<String> subGroup = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitClassificationCompanion(
            code: code,
            order: order,
            greatGroup: greatGroup,
            subGroup: subGroup,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String order,
            required String greatGroup,
            required String subGroup,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitClassificationCompanion.insert(
            code: code,
            order: order,
            greatGroup: greatGroup,
            subGroup: subGroup,
            rowid: rowid,
          ),
        ));
}

class $$SoilPitClassificationTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilPitClassificationTable,
        SoilPitClassificationData,
        $$SoilPitClassificationTableFilterComposer,
        $$SoilPitClassificationTableOrderingComposer,
        $$SoilPitClassificationTableProcessedTableManager,
        $$SoilPitClassificationTableInsertCompanionBuilder,
        $$SoilPitClassificationTableUpdateCompanionBuilder> {
  $$SoilPitClassificationTableProcessedTableManager(super.$state);
}

class $$SoilPitClassificationTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitClassificationTable> {
  $$SoilPitClassificationTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get order => $state.composableBuilder(
      column: $state.table.order,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get greatGroup => $state.composableBuilder(
      column: $state.table.greatGroup,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get subGroup => $state.composableBuilder(
      column: $state.table.subGroup,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilPitClassificationTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitClassificationTable> {
  $$SoilPitClassificationTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get order => $state.composableBuilder(
      column: $state.table.order,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get greatGroup => $state.composableBuilder(
      column: $state.table.greatGroup,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get subGroup => $state.composableBuilder(
      column: $state.table.subGroup,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilDrainageClassTableInsertCompanionBuilder
    = SoilDrainageClassCompanion Function({
  required int code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilDrainageClassTableUpdateCompanionBuilder
    = SoilDrainageClassCompanion Function({
  d.Value<int> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilDrainageClassTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilDrainageClassTable,
    SoilDrainageClassData,
    $$SoilDrainageClassTableFilterComposer,
    $$SoilDrainageClassTableOrderingComposer,
    $$SoilDrainageClassTableProcessedTableManager,
    $$SoilDrainageClassTableInsertCompanionBuilder,
    $$SoilDrainageClassTableUpdateCompanionBuilder> {
  $$SoilDrainageClassTableTableManager(
      _$Database db, $SoilDrainageClassTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilDrainageClassTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilDrainageClassTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilDrainageClassTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilDrainageClassCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required int code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilDrainageClassCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilDrainageClassTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilDrainageClassTable,
        SoilDrainageClassData,
        $$SoilDrainageClassTableFilterComposer,
        $$SoilDrainageClassTableOrderingComposer,
        $$SoilDrainageClassTableProcessedTableManager,
        $$SoilDrainageClassTableInsertCompanionBuilder,
        $$SoilDrainageClassTableUpdateCompanionBuilder> {
  $$SoilDrainageClassTableProcessedTableManager(super.$state);
}

class $$SoilDrainageClassTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilDrainageClassTable> {
  $$SoilDrainageClassTableFilterComposer(super.$state);
  d.ColumnFilters<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilDrainageClassTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilDrainageClassTable> {
  $$SoilDrainageClassTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilMoistureClassTableInsertCompanionBuilder
    = SoilMoistureClassCompanion Function({
  required int code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilMoistureClassTableUpdateCompanionBuilder
    = SoilMoistureClassCompanion Function({
  d.Value<int> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilMoistureClassTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilMoistureClassTable,
    SoilMositureClassData,
    $$SoilMoistureClassTableFilterComposer,
    $$SoilMoistureClassTableOrderingComposer,
    $$SoilMoistureClassTableProcessedTableManager,
    $$SoilMoistureClassTableInsertCompanionBuilder,
    $$SoilMoistureClassTableUpdateCompanionBuilder> {
  $$SoilMoistureClassTableTableManager(
      _$Database db, $SoilMoistureClassTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilMoistureClassTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilMoistureClassTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilMoistureClassTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilMoistureClassCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required int code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilMoistureClassCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilMoistureClassTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilMoistureClassTable,
        SoilMositureClassData,
        $$SoilMoistureClassTableFilterComposer,
        $$SoilMoistureClassTableOrderingComposer,
        $$SoilMoistureClassTableProcessedTableManager,
        $$SoilMoistureClassTableInsertCompanionBuilder,
        $$SoilMoistureClassTableUpdateCompanionBuilder> {
  $$SoilMoistureClassTableProcessedTableManager(super.$state);
}

class $$SoilMoistureClassTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilMoistureClassTable> {
  $$SoilMoistureClassTableFilterComposer(super.$state);
  d.ColumnFilters<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilMoistureClassTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilMoistureClassTable> {
  $$SoilMoistureClassTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilDepositionTableInsertCompanionBuilder = SoilDepositionCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilDepositionTableUpdateCompanionBuilder = SoilDepositionCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilDepositionTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilDepositionTable,
    SoilDepositionData,
    $$SoilDepositionTableFilterComposer,
    $$SoilDepositionTableOrderingComposer,
    $$SoilDepositionTableProcessedTableManager,
    $$SoilDepositionTableInsertCompanionBuilder,
    $$SoilDepositionTableUpdateCompanionBuilder> {
  $$SoilDepositionTableTableManager(_$Database db, $SoilDepositionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilDepositionTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilDepositionTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilDepositionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilDepositionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilDepositionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilDepositionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilDepositionTable,
        SoilDepositionData,
        $$SoilDepositionTableFilterComposer,
        $$SoilDepositionTableOrderingComposer,
        $$SoilDepositionTableProcessedTableManager,
        $$SoilDepositionTableInsertCompanionBuilder,
        $$SoilDepositionTableUpdateCompanionBuilder> {
  $$SoilDepositionTableProcessedTableManager(super.$state);
}

class $$SoilDepositionTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilDepositionTable> {
  $$SoilDepositionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilDepositionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilDepositionTable> {
  $$SoilDepositionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilHumusFormTableInsertCompanionBuilder = SoilHumusFormCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilHumusFormTableUpdateCompanionBuilder = SoilHumusFormCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilHumusFormTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilHumusFormTable,
    SoilHumusFormData,
    $$SoilHumusFormTableFilterComposer,
    $$SoilHumusFormTableOrderingComposer,
    $$SoilHumusFormTableProcessedTableManager,
    $$SoilHumusFormTableInsertCompanionBuilder,
    $$SoilHumusFormTableUpdateCompanionBuilder> {
  $$SoilHumusFormTableTableManager(_$Database db, $SoilHumusFormTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilHumusFormTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilHumusFormTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilHumusFormTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilHumusFormCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilHumusFormCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilHumusFormTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SoilHumusFormTable,
    SoilHumusFormData,
    $$SoilHumusFormTableFilterComposer,
    $$SoilHumusFormTableOrderingComposer,
    $$SoilHumusFormTableProcessedTableManager,
    $$SoilHumusFormTableInsertCompanionBuilder,
    $$SoilHumusFormTableUpdateCompanionBuilder> {
  $$SoilHumusFormTableProcessedTableManager(super.$state);
}

class $$SoilHumusFormTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilHumusFormTable> {
  $$SoilHumusFormTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilHumusFormTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilHumusFormTable> {
  $$SoilHumusFormTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilPitCodeTableInsertCompanionBuilder = SoilPitCodeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilPitCodeTableUpdateCompanionBuilder = SoilPitCodeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilPitCodeTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitCodeTable,
    SoilPitCodeData,
    $$SoilPitCodeTableFilterComposer,
    $$SoilPitCodeTableOrderingComposer,
    $$SoilPitCodeTableProcessedTableManager,
    $$SoilPitCodeTableInsertCompanionBuilder,
    $$SoilPitCodeTableUpdateCompanionBuilder> {
  $$SoilPitCodeTableTableManager(_$Database db, $SoilPitCodeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilPitCodeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilPitCodeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitCodeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitCodeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitCodeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilPitCodeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SoilPitCodeTable,
    SoilPitCodeData,
    $$SoilPitCodeTableFilterComposer,
    $$SoilPitCodeTableOrderingComposer,
    $$SoilPitCodeTableProcessedTableManager,
    $$SoilPitCodeTableInsertCompanionBuilder,
    $$SoilPitCodeTableUpdateCompanionBuilder> {
  $$SoilPitCodeTableProcessedTableManager(super.$state);
}

class $$SoilPitCodeTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitCodeTable> {
  $$SoilPitCodeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilPitCodeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitCodeTable> {
  $$SoilPitCodeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilPitFeatureClassTableInsertCompanionBuilder
    = SoilPitFeatureClassCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilPitFeatureClassTableUpdateCompanionBuilder
    = SoilPitFeatureClassCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilPitFeatureClassTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitFeatureClassTable,
    SoilFeatureClassData,
    $$SoilPitFeatureClassTableFilterComposer,
    $$SoilPitFeatureClassTableOrderingComposer,
    $$SoilPitFeatureClassTableProcessedTableManager,
    $$SoilPitFeatureClassTableInsertCompanionBuilder,
    $$SoilPitFeatureClassTableUpdateCompanionBuilder> {
  $$SoilPitFeatureClassTableTableManager(
      _$Database db, $SoilPitFeatureClassTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilPitFeatureClassTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilPitFeatureClassTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitFeatureClassTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitFeatureClassCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilPitFeatureClassCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilPitFeatureClassTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilPitFeatureClassTable,
        SoilFeatureClassData,
        $$SoilPitFeatureClassTableFilterComposer,
        $$SoilPitFeatureClassTableOrderingComposer,
        $$SoilPitFeatureClassTableProcessedTableManager,
        $$SoilPitFeatureClassTableInsertCompanionBuilder,
        $$SoilPitFeatureClassTableUpdateCompanionBuilder> {
  $$SoilPitFeatureClassTableProcessedTableManager(super.$state);
}

class $$SoilPitFeatureClassTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitFeatureClassTable> {
  $$SoilPitFeatureClassTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilPitFeatureClassTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitFeatureClassTable> {
  $$SoilPitFeatureClassTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilHorizonDesignationTableInsertCompanionBuilder
    = SoilHorizonDesignationCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilHorizonDesignationTableUpdateCompanionBuilder
    = SoilHorizonDesignationCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilHorizonDesignationTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilHorizonDesignationTable,
    SoilHorizonDesignationData,
    $$SoilHorizonDesignationTableFilterComposer,
    $$SoilHorizonDesignationTableOrderingComposer,
    $$SoilHorizonDesignationTableProcessedTableManager,
    $$SoilHorizonDesignationTableInsertCompanionBuilder,
    $$SoilHorizonDesignationTableUpdateCompanionBuilder> {
  $$SoilHorizonDesignationTableTableManager(
      _$Database db, $SoilHorizonDesignationTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilHorizonDesignationTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilHorizonDesignationTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilHorizonDesignationTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilHorizonDesignationCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilHorizonDesignationCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilHorizonDesignationTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilHorizonDesignationTable,
        SoilHorizonDesignationData,
        $$SoilHorizonDesignationTableFilterComposer,
        $$SoilHorizonDesignationTableOrderingComposer,
        $$SoilHorizonDesignationTableProcessedTableManager,
        $$SoilHorizonDesignationTableInsertCompanionBuilder,
        $$SoilHorizonDesignationTableUpdateCompanionBuilder> {
  $$SoilHorizonDesignationTableProcessedTableManager(super.$state);
}

class $$SoilHorizonDesignationTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilHorizonDesignationTable> {
  $$SoilHorizonDesignationTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilHorizonDesignationTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilHorizonDesignationTable> {
  $$SoilHorizonDesignationTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilColorTableInsertCompanionBuilder = SoilColorCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilColorTableUpdateCompanionBuilder = SoilColorCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilColorTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilColorTable,
    SoilColorData,
    $$SoilColorTableFilterComposer,
    $$SoilColorTableOrderingComposer,
    $$SoilColorTableProcessedTableManager,
    $$SoilColorTableInsertCompanionBuilder,
    $$SoilColorTableUpdateCompanionBuilder> {
  $$SoilColorTableTableManager(_$Database db, $SoilColorTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilColorTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilColorTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilColorTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilColorCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilColorCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilColorTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SoilColorTable,
    SoilColorData,
    $$SoilColorTableFilterComposer,
    $$SoilColorTableOrderingComposer,
    $$SoilColorTableProcessedTableManager,
    $$SoilColorTableInsertCompanionBuilder,
    $$SoilColorTableUpdateCompanionBuilder> {
  $$SoilColorTableProcessedTableManager(super.$state);
}

class $$SoilColorTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilColorTable> {
  $$SoilColorTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilColorTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilColorTable> {
  $$SoilColorTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SoilTextureTableInsertCompanionBuilder = SoilTextureCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$SoilTextureTableUpdateCompanionBuilder = SoilTextureCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$SoilTextureTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilTextureTable,
    SoilTextureData,
    $$SoilTextureTableFilterComposer,
    $$SoilTextureTableOrderingComposer,
    $$SoilTextureTableProcessedTableManager,
    $$SoilTextureTableInsertCompanionBuilder,
    $$SoilTextureTableUpdateCompanionBuilder> {
  $$SoilTextureTableTableManager(_$Database db, $SoilTextureTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilTextureTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilTextureTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilTextureTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilTextureCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              SoilTextureCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$SoilTextureTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SoilTextureTable,
    SoilTextureData,
    $$SoilTextureTableFilterComposer,
    $$SoilTextureTableOrderingComposer,
    $$SoilTextureTableProcessedTableManager,
    $$SoilTextureTableInsertCompanionBuilder,
    $$SoilTextureTableUpdateCompanionBuilder> {
  $$SoilTextureTableProcessedTableManager(super.$state);
}

class $$SoilTextureTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilTextureTable> {
  $$SoilTextureTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$SoilTextureTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilTextureTable> {
  $$SoilTextureTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StpTypeTableInsertCompanionBuilder = StpTypeCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StpTypeTableUpdateCompanionBuilder = StpTypeCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StpTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $StpTypeTable,
    StpTypeData,
    $$StpTypeTableFilterComposer,
    $$StpTypeTableOrderingComposer,
    $$StpTypeTableProcessedTableManager,
    $$StpTypeTableInsertCompanionBuilder,
    $$StpTypeTableUpdateCompanionBuilder> {
  $$StpTypeTableTableManager(_$Database db, $StpTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StpTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$StpTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StpTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StpTypeTable,
    StpTypeData,
    $$StpTypeTableFilterComposer,
    $$StpTypeTableOrderingComposer,
    $$StpTypeTableProcessedTableManager,
    $$StpTypeTableInsertCompanionBuilder,
    $$StpTypeTableUpdateCompanionBuilder> {
  $$StpTypeTableProcessedTableManager(super.$state);
}

class $$StpTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $StpTypeTable> {
  $$StpTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StpTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpTypeTable> {
  $$StpTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StpOrigPlotAreaTableInsertCompanionBuilder = StpOrigPlotAreaCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StpOrigPlotAreaTableUpdateCompanionBuilder = StpOrigPlotAreaCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StpOrigPlotAreaTableTableManager extends d.RootTableManager<
    _$Database,
    $StpOrigPlotAreaTable,
    StpOrigPlotAreaData,
    $$StpOrigPlotAreaTableFilterComposer,
    $$StpOrigPlotAreaTableOrderingComposer,
    $$StpOrigPlotAreaTableProcessedTableManager,
    $$StpOrigPlotAreaTableInsertCompanionBuilder,
    $$StpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$StpOrigPlotAreaTableTableManager(_$Database db, $StpOrigPlotAreaTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpOrigPlotAreaTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$StpOrigPlotAreaTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpOrigPlotAreaTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpOrigPlotAreaCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpOrigPlotAreaCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StpOrigPlotAreaTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $StpOrigPlotAreaTable,
        StpOrigPlotAreaData,
        $$StpOrigPlotAreaTableFilterComposer,
        $$StpOrigPlotAreaTableOrderingComposer,
        $$StpOrigPlotAreaTableProcessedTableManager,
        $$StpOrigPlotAreaTableInsertCompanionBuilder,
        $$StpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$StpOrigPlotAreaTableProcessedTableManager(super.$state);
}

class $$StpOrigPlotAreaTableFilterComposer
    extends d.FilterComposer<_$Database, $StpOrigPlotAreaTable> {
  $$StpOrigPlotAreaTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StpOrigPlotAreaTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpOrigPlotAreaTable> {
  $$StpOrigPlotAreaTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StpStatusFieldTableInsertCompanionBuilder = StpStatusFieldCompanion
    Function({
  required String code,
  required String name,
  required String description,
  d.Value<int> rowid,
});
typedef $$StpStatusFieldTableUpdateCompanionBuilder = StpStatusFieldCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String> description,
  d.Value<int> rowid,
});

class $$StpStatusFieldTableTableManager extends d.RootTableManager<
    _$Database,
    $StpStatusFieldTable,
    StpStatusFieldData,
    $$StpStatusFieldTableFilterComposer,
    $$StpStatusFieldTableOrderingComposer,
    $$StpStatusFieldTableProcessedTableManager,
    $$StpStatusFieldTableInsertCompanionBuilder,
    $$StpStatusFieldTableUpdateCompanionBuilder> {
  $$StpStatusFieldTableTableManager(_$Database db, $StpStatusFieldTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpStatusFieldTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StpStatusFieldTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpStatusFieldTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String> description = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpStatusFieldCompanion(
            code: code,
            name: name,
            description: description,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            required String description,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpStatusFieldCompanion.insert(
            code: code,
            name: name,
            description: description,
            rowid: rowid,
          ),
        ));
}

class $$StpStatusFieldTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $StpStatusFieldTable,
        StpStatusFieldData,
        $$StpStatusFieldTableFilterComposer,
        $$StpStatusFieldTableOrderingComposer,
        $$StpStatusFieldTableProcessedTableManager,
        $$StpStatusFieldTableInsertCompanionBuilder,
        $$StpStatusFieldTableUpdateCompanionBuilder> {
  $$StpStatusFieldTableProcessedTableManager(super.$state);
}

class $$StpStatusFieldTableFilterComposer
    extends d.FilterComposer<_$Database, $StpStatusFieldTable> {
  $$StpStatusFieldTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StpStatusFieldTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpStatusFieldTable> {
  $$StpStatusFieldTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StpHeightTableInsertCompanionBuilder = StpHeightCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StpHeightTableUpdateCompanionBuilder = StpHeightCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StpHeightTableTableManager extends d.RootTableManager<
    _$Database,
    $StpHeightTable,
    StpHeightData,
    $$StpHeightTableFilterComposer,
    $$StpHeightTableOrderingComposer,
    $$StpHeightTableProcessedTableManager,
    $$StpHeightTableInsertCompanionBuilder,
    $$StpHeightTableUpdateCompanionBuilder> {
  $$StpHeightTableTableManager(_$Database db, $StpHeightTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpHeightTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StpHeightTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpHeightTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpHeightCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpHeightCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StpHeightTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StpHeightTable,
    StpHeightData,
    $$StpHeightTableFilterComposer,
    $$StpHeightTableOrderingComposer,
    $$StpHeightTableProcessedTableManager,
    $$StpHeightTableInsertCompanionBuilder,
    $$StpHeightTableUpdateCompanionBuilder> {
  $$StpHeightTableProcessedTableManager(super.$state);
}

class $$StpHeightTableFilterComposer
    extends d.FilterComposer<_$Database, $StpHeightTable> {
  $$StpHeightTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StpHeightTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpHeightTable> {
  $$StpHeightTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StpStemConditionTableInsertCompanionBuilder
    = StpStemConditionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StpStemConditionTableUpdateCompanionBuilder
    = StpStemConditionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StpStemConditionTableTableManager extends d.RootTableManager<
    _$Database,
    $StpStemConditionTable,
    StpStemConditionData,
    $$StpStemConditionTableFilterComposer,
    $$StpStemConditionTableOrderingComposer,
    $$StpStemConditionTableProcessedTableManager,
    $$StpStemConditionTableInsertCompanionBuilder,
    $$StpStemConditionTableUpdateCompanionBuilder> {
  $$StpStemConditionTableTableManager(
      _$Database db, $StpStemConditionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpStemConditionTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$StpStemConditionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpStemConditionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpStemConditionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StpStemConditionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StpStemConditionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $StpStemConditionTable,
        StpStemConditionData,
        $$StpStemConditionTableFilterComposer,
        $$StpStemConditionTableOrderingComposer,
        $$StpStemConditionTableProcessedTableManager,
        $$StpStemConditionTableInsertCompanionBuilder,
        $$StpStemConditionTableUpdateCompanionBuilder> {
  $$StpStemConditionTableProcessedTableManager(super.$state);
}

class $$StpStemConditionTableFilterComposer
    extends d.FilterComposer<_$Database, $StpStemConditionTable> {
  $$StpStemConditionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StpStemConditionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpStemConditionTable> {
  $$StpStemConditionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ShrubPlotTypeTableInsertCompanionBuilder = ShrubPlotTypeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$ShrubPlotTypeTableUpdateCompanionBuilder = ShrubPlotTypeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$ShrubPlotTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $ShrubPlotTypeTable,
    ShrubPlotTypeData,
    $$ShrubPlotTypeTableFilterComposer,
    $$ShrubPlotTypeTableOrderingComposer,
    $$ShrubPlotTypeTableProcessedTableManager,
    $$ShrubPlotTypeTableInsertCompanionBuilder,
    $$ShrubPlotTypeTableUpdateCompanionBuilder> {
  $$ShrubPlotTypeTableTableManager(_$Database db, $ShrubPlotTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ShrubPlotTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$ShrubPlotTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ShrubPlotTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubPlotTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubPlotTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$ShrubPlotTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $ShrubPlotTypeTable,
    ShrubPlotTypeData,
    $$ShrubPlotTypeTableFilterComposer,
    $$ShrubPlotTypeTableOrderingComposer,
    $$ShrubPlotTypeTableProcessedTableManager,
    $$ShrubPlotTypeTableInsertCompanionBuilder,
    $$ShrubPlotTypeTableUpdateCompanionBuilder> {
  $$ShrubPlotTypeTableProcessedTableManager(super.$state);
}

class $$ShrubPlotTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $ShrubPlotTypeTable> {
  $$ShrubPlotTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ShrubPlotTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $ShrubPlotTypeTable> {
  $$ShrubPlotTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ShrubStatusFieldTableInsertCompanionBuilder
    = ShrubStatusFieldCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$ShrubStatusFieldTableUpdateCompanionBuilder
    = ShrubStatusFieldCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$ShrubStatusFieldTableTableManager extends d.RootTableManager<
    _$Database,
    $ShrubStatusFieldTable,
    ShrubStatusFieldData,
    $$ShrubStatusFieldTableFilterComposer,
    $$ShrubStatusFieldTableOrderingComposer,
    $$ShrubStatusFieldTableProcessedTableManager,
    $$ShrubStatusFieldTableInsertCompanionBuilder,
    $$ShrubStatusFieldTableUpdateCompanionBuilder> {
  $$ShrubStatusFieldTableTableManager(
      _$Database db, $ShrubStatusFieldTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ShrubStatusFieldTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$ShrubStatusFieldTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ShrubStatusFieldTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubStatusFieldCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubStatusFieldCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$ShrubStatusFieldTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $ShrubStatusFieldTable,
        ShrubStatusFieldData,
        $$ShrubStatusFieldTableFilterComposer,
        $$ShrubStatusFieldTableOrderingComposer,
        $$ShrubStatusFieldTableProcessedTableManager,
        $$ShrubStatusFieldTableInsertCompanionBuilder,
        $$ShrubStatusFieldTableUpdateCompanionBuilder> {
  $$ShrubStatusFieldTableProcessedTableManager(super.$state);
}

class $$ShrubStatusFieldTableFilterComposer
    extends d.FilterComposer<_$Database, $ShrubStatusFieldTable> {
  $$ShrubStatusFieldTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ShrubStatusFieldTableOrderingComposer
    extends d.OrderingComposer<_$Database, $ShrubStatusFieldTable> {
  $$ShrubStatusFieldTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$ShrubBasalDiameterTableInsertCompanionBuilder
    = ShrubBasalDiameterCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$ShrubBasalDiameterTableUpdateCompanionBuilder
    = ShrubBasalDiameterCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$ShrubBasalDiameterTableTableManager extends d.RootTableManager<
    _$Database,
    $ShrubBasalDiameterTable,
    ShrubBasalDiameterData,
    $$ShrubBasalDiameterTableFilterComposer,
    $$ShrubBasalDiameterTableOrderingComposer,
    $$ShrubBasalDiameterTableProcessedTableManager,
    $$ShrubBasalDiameterTableInsertCompanionBuilder,
    $$ShrubBasalDiameterTableUpdateCompanionBuilder> {
  $$ShrubBasalDiameterTableTableManager(
      _$Database db, $ShrubBasalDiameterTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$ShrubBasalDiameterTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$ShrubBasalDiameterTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ShrubBasalDiameterTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubBasalDiameterCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              ShrubBasalDiameterCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$ShrubBasalDiameterTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $ShrubBasalDiameterTable,
        ShrubBasalDiameterData,
        $$ShrubBasalDiameterTableFilterComposer,
        $$ShrubBasalDiameterTableOrderingComposer,
        $$ShrubBasalDiameterTableProcessedTableManager,
        $$ShrubBasalDiameterTableInsertCompanionBuilder,
        $$ShrubBasalDiameterTableUpdateCompanionBuilder> {
  $$ShrubBasalDiameterTableProcessedTableManager(super.$state);
}

class $$ShrubBasalDiameterTableFilterComposer
    extends d.FilterComposer<_$Database, $ShrubBasalDiameterTable> {
  $$ShrubBasalDiameterTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$ShrubBasalDiameterTableOrderingComposer
    extends d.OrderingComposer<_$Database, $ShrubBasalDiameterTable> {
  $$ShrubBasalDiameterTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StumpPlotTypeTableInsertCompanionBuilder = StumpPlotTypeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StumpPlotTypeTableUpdateCompanionBuilder = StumpPlotTypeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StumpPlotTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $StumpPlotTypeTable,
    StumpPlotTypeData,
    $$StumpPlotTypeTableFilterComposer,
    $$StumpPlotTypeTableOrderingComposer,
    $$StumpPlotTypeTableProcessedTableManager,
    $$StumpPlotTypeTableInsertCompanionBuilder,
    $$StumpPlotTypeTableUpdateCompanionBuilder> {
  $$StumpPlotTypeTableTableManager(_$Database db, $StumpPlotTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StumpPlotTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StumpPlotTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StumpPlotTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StumpPlotTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StumpPlotTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StumpPlotTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StumpPlotTypeTable,
    StumpPlotTypeData,
    $$StumpPlotTypeTableFilterComposer,
    $$StumpPlotTypeTableOrderingComposer,
    $$StumpPlotTypeTableProcessedTableManager,
    $$StumpPlotTypeTableInsertCompanionBuilder,
    $$StumpPlotTypeTableUpdateCompanionBuilder> {
  $$StumpPlotTypeTableProcessedTableManager(super.$state);
}

class $$StumpPlotTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $StumpPlotTypeTable> {
  $$StumpPlotTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StumpPlotTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StumpPlotTypeTable> {
  $$StumpPlotTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$StumpOrigPlotAreaTableInsertCompanionBuilder
    = StumpOrigPlotAreaCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$StumpOrigPlotAreaTableUpdateCompanionBuilder
    = StumpOrigPlotAreaCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$StumpOrigPlotAreaTableTableManager extends d.RootTableManager<
    _$Database,
    $StumpOrigPlotAreaTable,
    StumpOrigPlotAreaData,
    $$StumpOrigPlotAreaTableFilterComposer,
    $$StumpOrigPlotAreaTableOrderingComposer,
    $$StumpOrigPlotAreaTableProcessedTableManager,
    $$StumpOrigPlotAreaTableInsertCompanionBuilder,
    $$StumpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$StumpOrigPlotAreaTableTableManager(
      _$Database db, $StumpOrigPlotAreaTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$StumpOrigPlotAreaTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$StumpOrigPlotAreaTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StumpOrigPlotAreaTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StumpOrigPlotAreaCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              StumpOrigPlotAreaCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$StumpOrigPlotAreaTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $StumpOrigPlotAreaTable,
        StumpOrigPlotAreaData,
        $$StumpOrigPlotAreaTableFilterComposer,
        $$StumpOrigPlotAreaTableOrderingComposer,
        $$StumpOrigPlotAreaTableProcessedTableManager,
        $$StumpOrigPlotAreaTableInsertCompanionBuilder,
        $$StumpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$StumpOrigPlotAreaTableProcessedTableManager(super.$state);
}

class $$StumpOrigPlotAreaTableFilterComposer
    extends d.FilterComposer<_$Database, $StumpOrigPlotAreaTable> {
  $$StumpOrigPlotAreaTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$StumpOrigPlotAreaTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StumpOrigPlotAreaTable> {
  $$StumpOrigPlotAreaTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpPlotTypeTableInsertCompanionBuilder = LtpPlotTypeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpPlotTypeTableUpdateCompanionBuilder = LtpPlotTypeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpPlotTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpPlotTypeTable,
    LtpPlotTypeData,
    $$LtpPlotTypeTableFilterComposer,
    $$LtpPlotTypeTableOrderingComposer,
    $$LtpPlotTypeTableProcessedTableManager,
    $$LtpPlotTypeTableInsertCompanionBuilder,
    $$LtpPlotTypeTableUpdateCompanionBuilder> {
  $$LtpPlotTypeTableTableManager(_$Database db, $LtpPlotTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpPlotTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpPlotTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpPlotTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpPlotTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpPlotTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpPlotTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpPlotTypeTable,
    LtpPlotTypeData,
    $$LtpPlotTypeTableFilterComposer,
    $$LtpPlotTypeTableOrderingComposer,
    $$LtpPlotTypeTableProcessedTableManager,
    $$LtpPlotTypeTableInsertCompanionBuilder,
    $$LtpPlotTypeTableUpdateCompanionBuilder> {
  $$LtpPlotTypeTableProcessedTableManager(super.$state);
}

class $$LtpPlotTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpPlotTypeTable> {
  $$LtpPlotTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpPlotTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpPlotTypeTable> {
  $$LtpPlotTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpPlotSplitTableInsertCompanionBuilder = LtpPlotSplitCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpPlotSplitTableUpdateCompanionBuilder = LtpPlotSplitCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpPlotSplitTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpPlotSplitTable,
    LtpPlotSplitData,
    $$LtpPlotSplitTableFilterComposer,
    $$LtpPlotSplitTableOrderingComposer,
    $$LtpPlotSplitTableProcessedTableManager,
    $$LtpPlotSplitTableInsertCompanionBuilder,
    $$LtpPlotSplitTableUpdateCompanionBuilder> {
  $$LtpPlotSplitTableTableManager(_$Database db, $LtpPlotSplitTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpPlotSplitTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpPlotSplitTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpPlotSplitTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpPlotSplitCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpPlotSplitCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpPlotSplitTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpPlotSplitTable,
    LtpPlotSplitData,
    $$LtpPlotSplitTableFilterComposer,
    $$LtpPlotSplitTableOrderingComposer,
    $$LtpPlotSplitTableProcessedTableManager,
    $$LtpPlotSplitTableInsertCompanionBuilder,
    $$LtpPlotSplitTableUpdateCompanionBuilder> {
  $$LtpPlotSplitTableProcessedTableManager(super.$state);
}

class $$LtpPlotSplitTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpPlotSplitTable> {
  $$LtpPlotSplitTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpPlotSplitTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpPlotSplitTable> {
  $$LtpPlotSplitTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpOrigPlotAreaTableInsertCompanionBuilder = LtpOrigPlotAreaCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpOrigPlotAreaTableUpdateCompanionBuilder = LtpOrigPlotAreaCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpOrigPlotAreaTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpOrigPlotAreaTable,
    LtpOrigPlotAreaData,
    $$LtpOrigPlotAreaTableFilterComposer,
    $$LtpOrigPlotAreaTableOrderingComposer,
    $$LtpOrigPlotAreaTableProcessedTableManager,
    $$LtpOrigPlotAreaTableInsertCompanionBuilder,
    $$LtpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$LtpOrigPlotAreaTableTableManager(_$Database db, $LtpOrigPlotAreaTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpOrigPlotAreaTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$LtpOrigPlotAreaTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpOrigPlotAreaTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpOrigPlotAreaCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpOrigPlotAreaCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpOrigPlotAreaTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpOrigPlotAreaTable,
        LtpOrigPlotAreaData,
        $$LtpOrigPlotAreaTableFilterComposer,
        $$LtpOrigPlotAreaTableOrderingComposer,
        $$LtpOrigPlotAreaTableProcessedTableManager,
        $$LtpOrigPlotAreaTableInsertCompanionBuilder,
        $$LtpOrigPlotAreaTableUpdateCompanionBuilder> {
  $$LtpOrigPlotAreaTableProcessedTableManager(super.$state);
}

class $$LtpOrigPlotAreaTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpOrigPlotAreaTable> {
  $$LtpOrigPlotAreaTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpOrigPlotAreaTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpOrigPlotAreaTable> {
  $$LtpOrigPlotAreaTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpStatusFieldTableInsertCompanionBuilder = LtpStatusFieldCompanion
    Function({
  required String code,
  required String name,
  required String description,
  d.Value<int> rowid,
});
typedef $$LtpStatusFieldTableUpdateCompanionBuilder = LtpStatusFieldCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String> description,
  d.Value<int> rowid,
});

class $$LtpStatusFieldTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpStatusFieldTable,
    LtpStatusFieldData,
    $$LtpStatusFieldTableFilterComposer,
    $$LtpStatusFieldTableOrderingComposer,
    $$LtpStatusFieldTableProcessedTableManager,
    $$LtpStatusFieldTableInsertCompanionBuilder,
    $$LtpStatusFieldTableUpdateCompanionBuilder> {
  $$LtpStatusFieldTableTableManager(_$Database db, $LtpStatusFieldTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpStatusFieldTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpStatusFieldTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpStatusFieldTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String> description = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpStatusFieldCompanion(
            code: code,
            name: name,
            description: description,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            required String description,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpStatusFieldCompanion.insert(
            code: code,
            name: name,
            description: description,
            rowid: rowid,
          ),
        ));
}

class $$LtpStatusFieldTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpStatusFieldTable,
        LtpStatusFieldData,
        $$LtpStatusFieldTableFilterComposer,
        $$LtpStatusFieldTableOrderingComposer,
        $$LtpStatusFieldTableProcessedTableManager,
        $$LtpStatusFieldTableInsertCompanionBuilder,
        $$LtpStatusFieldTableUpdateCompanionBuilder> {
  $$LtpStatusFieldTableProcessedTableManager(super.$state);
}

class $$LtpStatusFieldTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpStatusFieldTable> {
  $$LtpStatusFieldTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpStatusFieldTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpStatusFieldTable> {
  $$LtpStatusFieldTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get description => $state.composableBuilder(
      column: $state.table.description,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpGenusTableInsertCompanionBuilder = LtpGenusCompanion Function({
  required String genusLatinName,
  required String speciesLatinName,
  required String varietyLatinName,
  required String genusCode,
  required String speciesCode,
  required String varietyCode,
  d.Value<int> rowid,
});
typedef $$LtpGenusTableUpdateCompanionBuilder = LtpGenusCompanion Function({
  d.Value<String> genusLatinName,
  d.Value<String> speciesLatinName,
  d.Value<String> varietyLatinName,
  d.Value<String> genusCode,
  d.Value<String> speciesCode,
  d.Value<String> varietyCode,
  d.Value<int> rowid,
});

class $$LtpGenusTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpGenusTable,
    LtpGenusData,
    $$LtpGenusTableFilterComposer,
    $$LtpGenusTableOrderingComposer,
    $$LtpGenusTableProcessedTableManager,
    $$LtpGenusTableInsertCompanionBuilder,
    $$LtpGenusTableUpdateCompanionBuilder> {
  $$LtpGenusTableTableManager(_$Database db, $LtpGenusTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpGenusTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpGenusTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpGenusTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> genusLatinName = const d.Value.absent(),
            d.Value<String> speciesLatinName = const d.Value.absent(),
            d.Value<String> varietyLatinName = const d.Value.absent(),
            d.Value<String> genusCode = const d.Value.absent(),
            d.Value<String> speciesCode = const d.Value.absent(),
            d.Value<String> varietyCode = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpGenusCompanion(
            genusLatinName: genusLatinName,
            speciesLatinName: speciesLatinName,
            varietyLatinName: varietyLatinName,
            genusCode: genusCode,
            speciesCode: speciesCode,
            varietyCode: varietyCode,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String genusLatinName,
            required String speciesLatinName,
            required String varietyLatinName,
            required String genusCode,
            required String speciesCode,
            required String varietyCode,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpGenusCompanion.insert(
            genusLatinName: genusLatinName,
            speciesLatinName: speciesLatinName,
            varietyLatinName: varietyLatinName,
            genusCode: genusCode,
            speciesCode: speciesCode,
            varietyCode: varietyCode,
            rowid: rowid,
          ),
        ));
}

class $$LtpGenusTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpGenusTable,
    LtpGenusData,
    $$LtpGenusTableFilterComposer,
    $$LtpGenusTableOrderingComposer,
    $$LtpGenusTableProcessedTableManager,
    $$LtpGenusTableInsertCompanionBuilder,
    $$LtpGenusTableUpdateCompanionBuilder> {
  $$LtpGenusTableProcessedTableManager(super.$state);
}

class $$LtpGenusTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpGenusTable> {
  $$LtpGenusTableFilterComposer(super.$state);
  d.ColumnFilters<String> get genusLatinName => $state.composableBuilder(
      column: $state.table.genusLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get speciesLatinName => $state.composableBuilder(
      column: $state.table.speciesLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get varietyLatinName => $state.composableBuilder(
      column: $state.table.varietyLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get genusCode => $state.composableBuilder(
      column: $state.table.genusCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get speciesCode => $state.composableBuilder(
      column: $state.table.speciesCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get varietyCode => $state.composableBuilder(
      column: $state.table.varietyCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpGenusTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpGenusTable> {
  $$LtpGenusTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get genusLatinName => $state.composableBuilder(
      column: $state.table.genusLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get speciesLatinName => $state.composableBuilder(
      column: $state.table.speciesLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get varietyLatinName => $state.composableBuilder(
      column: $state.table.varietyLatinName,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get genusCode => $state.composableBuilder(
      column: $state.table.genusCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get speciesCode => $state.composableBuilder(
      column: $state.table.speciesCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get varietyCode => $state.composableBuilder(
      column: $state.table.varietyCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpCrownClassFieldTableInsertCompanionBuilder
    = LtpCrownClassFieldCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpCrownClassFieldTableUpdateCompanionBuilder
    = LtpCrownClassFieldCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpCrownClassFieldTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpCrownClassFieldTable,
    LtpCrownClassFieldData,
    $$LtpCrownClassFieldTableFilterComposer,
    $$LtpCrownClassFieldTableOrderingComposer,
    $$LtpCrownClassFieldTableProcessedTableManager,
    $$LtpCrownClassFieldTableInsertCompanionBuilder,
    $$LtpCrownClassFieldTableUpdateCompanionBuilder> {
  $$LtpCrownClassFieldTableTableManager(
      _$Database db, $LtpCrownClassFieldTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$LtpCrownClassFieldTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$LtpCrownClassFieldTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpCrownClassFieldTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpCrownClassFieldCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpCrownClassFieldCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpCrownClassFieldTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpCrownClassFieldTable,
        LtpCrownClassFieldData,
        $$LtpCrownClassFieldTableFilterComposer,
        $$LtpCrownClassFieldTableOrderingComposer,
        $$LtpCrownClassFieldTableProcessedTableManager,
        $$LtpCrownClassFieldTableInsertCompanionBuilder,
        $$LtpCrownClassFieldTableUpdateCompanionBuilder> {
  $$LtpCrownClassFieldTableProcessedTableManager(super.$state);
}

class $$LtpCrownClassFieldTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpCrownClassFieldTable> {
  $$LtpCrownClassFieldTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpCrownClassFieldTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpCrownClassFieldTable> {
  $$LtpCrownClassFieldTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpBarkConditionTableInsertCompanionBuilder
    = LtpBarkConditionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpBarkConditionTableUpdateCompanionBuilder
    = LtpBarkConditionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpBarkConditionTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpBarkConditionTable,
    LtpBarkConditionData,
    $$LtpBarkConditionTableFilterComposer,
    $$LtpBarkConditionTableOrderingComposer,
    $$LtpBarkConditionTableProcessedTableManager,
    $$LtpBarkConditionTableInsertCompanionBuilder,
    $$LtpBarkConditionTableUpdateCompanionBuilder> {
  $$LtpBarkConditionTableTableManager(
      _$Database db, $LtpBarkConditionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpBarkConditionTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$LtpBarkConditionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpBarkConditionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpBarkConditionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpBarkConditionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpBarkConditionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpBarkConditionTable,
        LtpBarkConditionData,
        $$LtpBarkConditionTableFilterComposer,
        $$LtpBarkConditionTableOrderingComposer,
        $$LtpBarkConditionTableProcessedTableManager,
        $$LtpBarkConditionTableInsertCompanionBuilder,
        $$LtpBarkConditionTableUpdateCompanionBuilder> {
  $$LtpBarkConditionTableProcessedTableManager(super.$state);
}

class $$LtpBarkConditionTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpBarkConditionTable> {
  $$LtpBarkConditionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpBarkConditionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpBarkConditionTable> {
  $$LtpBarkConditionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpCrownConditionTableInsertCompanionBuilder
    = LtpCrownConditionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpCrownConditionTableUpdateCompanionBuilder
    = LtpCrownConditionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpCrownConditionTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpCrownConditionTable,
    LtpCrownConditionData,
    $$LtpCrownConditionTableFilterComposer,
    $$LtpCrownConditionTableOrderingComposer,
    $$LtpCrownConditionTableProcessedTableManager,
    $$LtpCrownConditionTableInsertCompanionBuilder,
    $$LtpCrownConditionTableUpdateCompanionBuilder> {
  $$LtpCrownConditionTableTableManager(
      _$Database db, $LtpCrownConditionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$LtpCrownConditionTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$LtpCrownConditionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpCrownConditionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpCrownConditionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpCrownConditionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpCrownConditionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpCrownConditionTable,
        LtpCrownConditionData,
        $$LtpCrownConditionTableFilterComposer,
        $$LtpCrownConditionTableOrderingComposer,
        $$LtpCrownConditionTableProcessedTableManager,
        $$LtpCrownConditionTableInsertCompanionBuilder,
        $$LtpCrownConditionTableUpdateCompanionBuilder> {
  $$LtpCrownConditionTableProcessedTableManager(super.$state);
}

class $$LtpCrownConditionTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpCrownConditionTable> {
  $$LtpCrownConditionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpCrownConditionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpCrownConditionTable> {
  $$LtpCrownConditionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpStemConditionTableInsertCompanionBuilder
    = LtpStemConditionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpStemConditionTableUpdateCompanionBuilder
    = LtpStemConditionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpStemConditionTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpStemConditionTable,
    LtpStemConditionData,
    $$LtpStemConditionTableFilterComposer,
    $$LtpStemConditionTableOrderingComposer,
    $$LtpStemConditionTableProcessedTableManager,
    $$LtpStemConditionTableInsertCompanionBuilder,
    $$LtpStemConditionTableUpdateCompanionBuilder> {
  $$LtpStemConditionTableTableManager(
      _$Database db, $LtpStemConditionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpStemConditionTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$LtpStemConditionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpStemConditionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpStemConditionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpStemConditionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpStemConditionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpStemConditionTable,
        LtpStemConditionData,
        $$LtpStemConditionTableFilterComposer,
        $$LtpStemConditionTableOrderingComposer,
        $$LtpStemConditionTableProcessedTableManager,
        $$LtpStemConditionTableInsertCompanionBuilder,
        $$LtpStemConditionTableUpdateCompanionBuilder> {
  $$LtpStemConditionTableProcessedTableManager(super.$state);
}

class $$LtpStemConditionTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpStemConditionTable> {
  $$LtpStemConditionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpStemConditionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpStemConditionTable> {
  $$LtpStemConditionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpWoodConditionTableInsertCompanionBuilder
    = LtpWoodConditionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpWoodConditionTableUpdateCompanionBuilder
    = LtpWoodConditionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpWoodConditionTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpWoodConditionTable,
    LtpWoodConditionData,
    $$LtpWoodConditionTableFilterComposer,
    $$LtpWoodConditionTableOrderingComposer,
    $$LtpWoodConditionTableProcessedTableManager,
    $$LtpWoodConditionTableInsertCompanionBuilder,
    $$LtpWoodConditionTableUpdateCompanionBuilder> {
  $$LtpWoodConditionTableTableManager(
      _$Database db, $LtpWoodConditionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpWoodConditionTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$LtpWoodConditionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpWoodConditionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpWoodConditionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpWoodConditionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpWoodConditionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpWoodConditionTable,
        LtpWoodConditionData,
        $$LtpWoodConditionTableFilterComposer,
        $$LtpWoodConditionTableOrderingComposer,
        $$LtpWoodConditionTableProcessedTableManager,
        $$LtpWoodConditionTableInsertCompanionBuilder,
        $$LtpWoodConditionTableUpdateCompanionBuilder> {
  $$LtpWoodConditionTableProcessedTableManager(super.$state);
}

class $$LtpWoodConditionTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpWoodConditionTable> {
  $$LtpWoodConditionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpWoodConditionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpWoodConditionTable> {
  $$LtpWoodConditionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpQuadrantTableInsertCompanionBuilder = LtpQuadrantCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpQuadrantTableUpdateCompanionBuilder = LtpQuadrantCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpQuadrantTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpQuadrantTable,
    LtpQuadrantData,
    $$LtpQuadrantTableFilterComposer,
    $$LtpQuadrantTableOrderingComposer,
    $$LtpQuadrantTableProcessedTableManager,
    $$LtpQuadrantTableInsertCompanionBuilder,
    $$LtpQuadrantTableUpdateCompanionBuilder> {
  $$LtpQuadrantTableTableManager(_$Database db, $LtpQuadrantTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpQuadrantTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpQuadrantTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpQuadrantTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpQuadrantCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpQuadrantCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpQuadrantTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpQuadrantTable,
    LtpQuadrantData,
    $$LtpQuadrantTableFilterComposer,
    $$LtpQuadrantTableOrderingComposer,
    $$LtpQuadrantTableProcessedTableManager,
    $$LtpQuadrantTableInsertCompanionBuilder,
    $$LtpQuadrantTableUpdateCompanionBuilder> {
  $$LtpQuadrantTableProcessedTableManager(super.$state);
}

class $$LtpQuadrantTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpQuadrantTable> {
  $$LtpQuadrantTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpQuadrantTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpQuadrantTable> {
  $$LtpQuadrantTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpTreeTypeTableInsertCompanionBuilder = LtpTreeTypeCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpTreeTypeTableUpdateCompanionBuilder = LtpTreeTypeCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpTreeTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeTypeTable,
    LtpTreeTypeData,
    $$LtpTreeTypeTableFilterComposer,
    $$LtpTreeTypeTableOrderingComposer,
    $$LtpTreeTypeTableProcessedTableManager,
    $$LtpTreeTypeTableInsertCompanionBuilder,
    $$LtpTreeTypeTableUpdateCompanionBuilder> {
  $$LtpTreeTypeTableTableManager(_$Database db, $LtpTreeTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeTypeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeTypeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpTreeTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpTreeTypeCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpTreeTypeCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpTreeTypeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpTreeTypeTable,
    LtpTreeTypeData,
    $$LtpTreeTypeTableFilterComposer,
    $$LtpTreeTypeTableOrderingComposer,
    $$LtpTreeTypeTableProcessedTableManager,
    $$LtpTreeTypeTableInsertCompanionBuilder,
    $$LtpTreeTypeTableUpdateCompanionBuilder> {
  $$LtpTreeTypeTableProcessedTableManager(super.$state);
}

class $$LtpTreeTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeTypeTable> {
  $$LtpTreeTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpTreeTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeTypeTable> {
  $$LtpTreeTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpSiteHeightSuitabilityTableInsertCompanionBuilder
    = LtpSiteHeightSuitabilityCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpSiteHeightSuitabilityTableUpdateCompanionBuilder
    = LtpSiteHeightSuitabilityCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpSiteHeightSuitabilityTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpSiteHeightSuitabilityTable,
    LtpSiteHeightSuitabilityData,
    $$LtpSiteHeightSuitabilityTableFilterComposer,
    $$LtpSiteHeightSuitabilityTableOrderingComposer,
    $$LtpSiteHeightSuitabilityTableProcessedTableManager,
    $$LtpSiteHeightSuitabilityTableInsertCompanionBuilder,
    $$LtpSiteHeightSuitabilityTableUpdateCompanionBuilder> {
  $$LtpSiteHeightSuitabilityTableTableManager(
      _$Database db, $LtpSiteHeightSuitabilityTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$LtpSiteHeightSuitabilityTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$LtpSiteHeightSuitabilityTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpSiteHeightSuitabilityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpSiteHeightSuitabilityCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpSiteHeightSuitabilityCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpSiteHeightSuitabilityTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpSiteHeightSuitabilityTable,
        LtpSiteHeightSuitabilityData,
        $$LtpSiteHeightSuitabilityTableFilterComposer,
        $$LtpSiteHeightSuitabilityTableOrderingComposer,
        $$LtpSiteHeightSuitabilityTableProcessedTableManager,
        $$LtpSiteHeightSuitabilityTableInsertCompanionBuilder,
        $$LtpSiteHeightSuitabilityTableUpdateCompanionBuilder> {
  $$LtpSiteHeightSuitabilityTableProcessedTableManager(super.$state);
}

class $$LtpSiteHeightSuitabilityTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpSiteHeightSuitabilityTable> {
  $$LtpSiteHeightSuitabilityTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpSiteHeightSuitabilityTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpSiteHeightSuitabilityTable> {
  $$LtpSiteHeightSuitabilityTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpSiteAgeSuitabilityTableInsertCompanionBuilder
    = LtpSiteAgeSuitabilityCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpSiteAgeSuitabilityTableUpdateCompanionBuilder
    = LtpSiteAgeSuitabilityCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpSiteAgeSuitabilityTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpSiteAgeSuitabilityTable,
    LtpSiteAgeSuitabilityData,
    $$LtpSiteAgeSuitabilityTableFilterComposer,
    $$LtpSiteAgeSuitabilityTableOrderingComposer,
    $$LtpSiteAgeSuitabilityTableProcessedTableManager,
    $$LtpSiteAgeSuitabilityTableInsertCompanionBuilder,
    $$LtpSiteAgeSuitabilityTableUpdateCompanionBuilder> {
  $$LtpSiteAgeSuitabilityTableTableManager(
      _$Database db, $LtpSiteAgeSuitabilityTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$LtpSiteAgeSuitabilityTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$LtpSiteAgeSuitabilityTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpSiteAgeSuitabilityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpSiteAgeSuitabilityCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpSiteAgeSuitabilityCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpSiteAgeSuitabilityTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpSiteAgeSuitabilityTable,
        LtpSiteAgeSuitabilityData,
        $$LtpSiteAgeSuitabilityTableFilterComposer,
        $$LtpSiteAgeSuitabilityTableOrderingComposer,
        $$LtpSiteAgeSuitabilityTableProcessedTableManager,
        $$LtpSiteAgeSuitabilityTableInsertCompanionBuilder,
        $$LtpSiteAgeSuitabilityTableUpdateCompanionBuilder> {
  $$LtpSiteAgeSuitabilityTableProcessedTableManager(super.$state);
}

class $$LtpSiteAgeSuitabilityTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpSiteAgeSuitabilityTable> {
  $$LtpSiteAgeSuitabilityTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpSiteAgeSuitabilityTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpSiteAgeSuitabilityTable> {
  $$LtpSiteAgeSuitabilityTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$LtpProrateTableInsertCompanionBuilder = LtpProrateCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$LtpProrateTableUpdateCompanionBuilder = LtpProrateCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$LtpProrateTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpProrateTable,
    LtpProrateData,
    $$LtpProrateTableFilterComposer,
    $$LtpProrateTableOrderingComposer,
    $$LtpProrateTableProcessedTableManager,
    $$LtpProrateTableInsertCompanionBuilder,
    $$LtpProrateTableUpdateCompanionBuilder> {
  $$LtpProrateTableTableManager(_$Database db, $LtpProrateTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpProrateTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpProrateTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpProrateTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpProrateCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              LtpProrateCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$LtpProrateTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpProrateTable,
    LtpProrateData,
    $$LtpProrateTableFilterComposer,
    $$LtpProrateTableOrderingComposer,
    $$LtpProrateTableProcessedTableManager,
    $$LtpProrateTableInsertCompanionBuilder,
    $$LtpProrateTableUpdateCompanionBuilder> {
  $$LtpProrateTableProcessedTableManager(super.$state);
}

class $$LtpProrateTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpProrateTable> {
  $$LtpProrateTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$LtpProrateTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpProrateTable> {
  $$LtpProrateTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoStandStructureTableInsertCompanionBuilder
    = GpSiteInfoStandStructureCompanion Function({
  required String code,
  required String name,
  d.Value<String?> cover,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoStandStructureTableUpdateCompanionBuilder
    = GpSiteInfoStandStructureCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String?> cover,
  d.Value<int> rowid,
});

class $$GpSiteInfoStandStructureTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoStandStructureTable,
    GpSiteInfoStandStructureData,
    $$GpSiteInfoStandStructureTableFilterComposer,
    $$GpSiteInfoStandStructureTableOrderingComposer,
    $$GpSiteInfoStandStructureTableProcessedTableManager,
    $$GpSiteInfoStandStructureTableInsertCompanionBuilder,
    $$GpSiteInfoStandStructureTableUpdateCompanionBuilder> {
  $$GpSiteInfoStandStructureTableTableManager(
      _$Database db, $GpSiteInfoStandStructureTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoStandStructureTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoStandStructureTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoStandStructureTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String?> cover = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoStandStructureCompanion(
            code: code,
            name: name,
            cover: cover,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<String?> cover = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoStandStructureCompanion.insert(
            code: code,
            name: name,
            cover: cover,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoStandStructureTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoStandStructureTable,
        GpSiteInfoStandStructureData,
        $$GpSiteInfoStandStructureTableFilterComposer,
        $$GpSiteInfoStandStructureTableOrderingComposer,
        $$GpSiteInfoStandStructureTableProcessedTableManager,
        $$GpSiteInfoStandStructureTableInsertCompanionBuilder,
        $$GpSiteInfoStandStructureTableUpdateCompanionBuilder> {
  $$GpSiteInfoStandStructureTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoStandStructureTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoStandStructureTable> {
  $$GpSiteInfoStandStructureTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get cover => $state.composableBuilder(
      column: $state.table.cover,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoStandStructureTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoStandStructureTable> {
  $$GpSiteInfoStandStructureTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get cover => $state.composableBuilder(
      column: $state.table.cover,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoSuccessionStageTableInsertCompanionBuilder
    = GpSiteInfoSuccessionStageCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoSuccessionStageTableUpdateCompanionBuilder
    = GpSiteInfoSuccessionStageCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoSuccessionStageTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoSuccessionStageTable,
    GpSiteInfoSuccessionStageData,
    $$GpSiteInfoSuccessionStageTableFilterComposer,
    $$GpSiteInfoSuccessionStageTableOrderingComposer,
    $$GpSiteInfoSuccessionStageTableProcessedTableManager,
    $$GpSiteInfoSuccessionStageTableInsertCompanionBuilder,
    $$GpSiteInfoSuccessionStageTableUpdateCompanionBuilder> {
  $$GpSiteInfoSuccessionStageTableTableManager(
      _$Database db, $GpSiteInfoSuccessionStageTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoSuccessionStageTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoSuccessionStageTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoSuccessionStageTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoSuccessionStageCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoSuccessionStageCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoSuccessionStageTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoSuccessionStageTable,
        GpSiteInfoSuccessionStageData,
        $$GpSiteInfoSuccessionStageTableFilterComposer,
        $$GpSiteInfoSuccessionStageTableOrderingComposer,
        $$GpSiteInfoSuccessionStageTableProcessedTableManager,
        $$GpSiteInfoSuccessionStageTableInsertCompanionBuilder,
        $$GpSiteInfoSuccessionStageTableUpdateCompanionBuilder> {
  $$GpSiteInfoSuccessionStageTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoSuccessionStageTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoSuccessionStageTable> {
  $$GpSiteInfoSuccessionStageTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoSuccessionStageTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoSuccessionStageTable> {
  $$GpSiteInfoSuccessionStageTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoUtmZoneTableInsertCompanionBuilder
    = GpSiteInfoUtmZoneCompanion Function({
  required int code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoUtmZoneTableUpdateCompanionBuilder
    = GpSiteInfoUtmZoneCompanion Function({
  d.Value<int> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoUtmZoneTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoUtmZoneTable,
    GpSiteInfoUtmZoneData,
    $$GpSiteInfoUtmZoneTableFilterComposer,
    $$GpSiteInfoUtmZoneTableOrderingComposer,
    $$GpSiteInfoUtmZoneTableProcessedTableManager,
    $$GpSiteInfoUtmZoneTableInsertCompanionBuilder,
    $$GpSiteInfoUtmZoneTableUpdateCompanionBuilder> {
  $$GpSiteInfoUtmZoneTableTableManager(
      _$Database db, $GpSiteInfoUtmZoneTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoUtmZoneTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoUtmZoneTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoUtmZoneTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoUtmZoneCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required int code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoUtmZoneCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoUtmZoneTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoUtmZoneTable,
        GpSiteInfoUtmZoneData,
        $$GpSiteInfoUtmZoneTableFilterComposer,
        $$GpSiteInfoUtmZoneTableOrderingComposer,
        $$GpSiteInfoUtmZoneTableProcessedTableManager,
        $$GpSiteInfoUtmZoneTableInsertCompanionBuilder,
        $$GpSiteInfoUtmZoneTableUpdateCompanionBuilder> {
  $$GpSiteInfoUtmZoneTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoUtmZoneTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoUtmZoneTable> {
  $$GpSiteInfoUtmZoneTableFilterComposer(super.$state);
  d.ColumnFilters<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoUtmZoneTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoUtmZoneTable> {
  $$GpSiteInfoUtmZoneTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoVegTypeTableInsertCompanionBuilder
    = GpSiteInfoVegTypeCompanion Function({
  required String code,
  required String name,
  required String cover,
  d.Value<String?> base,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoVegTypeTableUpdateCompanionBuilder
    = GpSiteInfoVegTypeCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String> cover,
  d.Value<String?> base,
  d.Value<int> rowid,
});

class $$GpSiteInfoVegTypeTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoVegTypeTable,
    GpSiteInfoVegTypeData,
    $$GpSiteInfoVegTypeTableFilterComposer,
    $$GpSiteInfoVegTypeTableOrderingComposer,
    $$GpSiteInfoVegTypeTableProcessedTableManager,
    $$GpSiteInfoVegTypeTableInsertCompanionBuilder,
    $$GpSiteInfoVegTypeTableUpdateCompanionBuilder> {
  $$GpSiteInfoVegTypeTableTableManager(
      _$Database db, $GpSiteInfoVegTypeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoVegTypeTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoVegTypeTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoVegTypeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String> cover = const d.Value.absent(),
            d.Value<String?> base = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoVegTypeCompanion(
            code: code,
            name: name,
            cover: cover,
            base: base,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            required String cover,
            d.Value<String?> base = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoVegTypeCompanion.insert(
            code: code,
            name: name,
            cover: cover,
            base: base,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoVegTypeTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoVegTypeTable,
        GpSiteInfoVegTypeData,
        $$GpSiteInfoVegTypeTableFilterComposer,
        $$GpSiteInfoVegTypeTableOrderingComposer,
        $$GpSiteInfoVegTypeTableProcessedTableManager,
        $$GpSiteInfoVegTypeTableInsertCompanionBuilder,
        $$GpSiteInfoVegTypeTableUpdateCompanionBuilder> {
  $$GpSiteInfoVegTypeTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoVegTypeTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoVegTypeTable> {
  $$GpSiteInfoVegTypeTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get cover => $state.composableBuilder(
      column: $state.table.cover,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoVegTypeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoVegTypeTable> {
  $$GpSiteInfoVegTypeTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get cover => $state.composableBuilder(
      column: $state.table.cover,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoWetlandTableInsertCompanionBuilder
    = GpSiteInfoWetlandCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoWetlandTableUpdateCompanionBuilder
    = GpSiteInfoWetlandCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoWetlandTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoWetlandTable,
    GpSiteInfoWetlandData,
    $$GpSiteInfoWetlandTableFilterComposer,
    $$GpSiteInfoWetlandTableOrderingComposer,
    $$GpSiteInfoWetlandTableProcessedTableManager,
    $$GpSiteInfoWetlandTableInsertCompanionBuilder,
    $$GpSiteInfoWetlandTableUpdateCompanionBuilder> {
  $$GpSiteInfoWetlandTableTableManager(
      _$Database db, $GpSiteInfoWetlandTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoWetlandTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoWetlandTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoWetlandTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoWetlandCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoWetlandCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoWetlandTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoWetlandTable,
        GpSiteInfoWetlandData,
        $$GpSiteInfoWetlandTableFilterComposer,
        $$GpSiteInfoWetlandTableOrderingComposer,
        $$GpSiteInfoWetlandTableProcessedTableManager,
        $$GpSiteInfoWetlandTableInsertCompanionBuilder,
        $$GpSiteInfoWetlandTableUpdateCompanionBuilder> {
  $$GpSiteInfoWetlandTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoWetlandTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoWetlandTable> {
  $$GpSiteInfoWetlandTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoWetlandTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoWetlandTable> {
  $$GpSiteInfoWetlandTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoEcozoneTableInsertCompanionBuilder
    = GpSiteInfoEcozoneCompanion Function({
  required int code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoEcozoneTableUpdateCompanionBuilder
    = GpSiteInfoEcozoneCompanion Function({
  d.Value<int> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoEcozoneTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoEcozoneTable,
    GpSiteInfoEcozoneData,
    $$GpSiteInfoEcozoneTableFilterComposer,
    $$GpSiteInfoEcozoneTableOrderingComposer,
    $$GpSiteInfoEcozoneTableProcessedTableManager,
    $$GpSiteInfoEcozoneTableInsertCompanionBuilder,
    $$GpSiteInfoEcozoneTableUpdateCompanionBuilder> {
  $$GpSiteInfoEcozoneTableTableManager(
      _$Database db, $GpSiteInfoEcozoneTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoEcozoneTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoEcozoneTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoEcozoneTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoEcozoneCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required int code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoEcozoneCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoEcozoneTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoEcozoneTable,
        GpSiteInfoEcozoneData,
        $$GpSiteInfoEcozoneTableFilterComposer,
        $$GpSiteInfoEcozoneTableOrderingComposer,
        $$GpSiteInfoEcozoneTableProcessedTableManager,
        $$GpSiteInfoEcozoneTableInsertCompanionBuilder,
        $$GpSiteInfoEcozoneTableUpdateCompanionBuilder> {
  $$GpSiteInfoEcozoneTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoEcozoneTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoEcozoneTable> {
  $$GpSiteInfoEcozoneTableFilterComposer(super.$state);
  d.ColumnFilters<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoEcozoneTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoEcozoneTable> {
  $$GpSiteInfoEcozoneTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoPlotCompletionTableInsertCompanionBuilder
    = GpSiteInfoPlotCompletionCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoPlotCompletionTableUpdateCompanionBuilder
    = GpSiteInfoPlotCompletionCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoPlotCompletionTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoPlotCompletionTable,
    GpSiteInfoPlotCompletionData,
    $$GpSiteInfoPlotCompletionTableFilterComposer,
    $$GpSiteInfoPlotCompletionTableOrderingComposer,
    $$GpSiteInfoPlotCompletionTableProcessedTableManager,
    $$GpSiteInfoPlotCompletionTableInsertCompanionBuilder,
    $$GpSiteInfoPlotCompletionTableUpdateCompanionBuilder> {
  $$GpSiteInfoPlotCompletionTableTableManager(
      _$Database db, $GpSiteInfoPlotCompletionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoPlotCompletionTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoPlotCompletionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoPlotCompletionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPlotCompletionCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPlotCompletionCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoPlotCompletionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoPlotCompletionTable,
        GpSiteInfoPlotCompletionData,
        $$GpSiteInfoPlotCompletionTableFilterComposer,
        $$GpSiteInfoPlotCompletionTableOrderingComposer,
        $$GpSiteInfoPlotCompletionTableProcessedTableManager,
        $$GpSiteInfoPlotCompletionTableInsertCompanionBuilder,
        $$GpSiteInfoPlotCompletionTableUpdateCompanionBuilder> {
  $$GpSiteInfoPlotCompletionTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoPlotCompletionTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoPlotCompletionTable> {
  $$GpSiteInfoPlotCompletionTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoPlotCompletionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoPlotCompletionTable> {
  $$GpSiteInfoPlotCompletionTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoDensityTableInsertCompanionBuilder
    = GpSiteInfoDensityCompanion Function({
  required String code,
  required String name,
  d.Value<String?> base,
  d.Value<String?> veg,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoDensityTableUpdateCompanionBuilder
    = GpSiteInfoDensityCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String?> base,
  d.Value<String?> veg,
  d.Value<int> rowid,
});

class $$GpSiteInfoDensityTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoDensityTable,
    GpSiteInfoDensityData,
    $$GpSiteInfoDensityTableFilterComposer,
    $$GpSiteInfoDensityTableOrderingComposer,
    $$GpSiteInfoDensityTableProcessedTableManager,
    $$GpSiteInfoDensityTableInsertCompanionBuilder,
    $$GpSiteInfoDensityTableUpdateCompanionBuilder> {
  $$GpSiteInfoDensityTableTableManager(
      _$Database db, $GpSiteInfoDensityTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoDensityTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoDensityTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoDensityTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String?> base = const d.Value.absent(),
            d.Value<String?> veg = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoDensityCompanion(
            code: code,
            name: name,
            base: base,
            veg: veg,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<String?> base = const d.Value.absent(),
            d.Value<String?> veg = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoDensityCompanion.insert(
            code: code,
            name: name,
            base: base,
            veg: veg,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoDensityTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoDensityTable,
        GpSiteInfoDensityData,
        $$GpSiteInfoDensityTableFilterComposer,
        $$GpSiteInfoDensityTableOrderingComposer,
        $$GpSiteInfoDensityTableProcessedTableManager,
        $$GpSiteInfoDensityTableInsertCompanionBuilder,
        $$GpSiteInfoDensityTableUpdateCompanionBuilder> {
  $$GpSiteInfoDensityTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoDensityTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoDensityTable> {
  $$GpSiteInfoDensityTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get veg => $state.composableBuilder(
      column: $state.table.veg,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoDensityTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoDensityTable> {
  $$GpSiteInfoDensityTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get veg => $state.composableBuilder(
      column: $state.table.veg,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoLandBaseTableInsertCompanionBuilder
    = GpSiteInfoLandBaseCompanion Function({
  required String code,
  required String name,
  d.Value<String?> completion,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoLandBaseTableUpdateCompanionBuilder
    = GpSiteInfoLandBaseCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String?> completion,
  d.Value<int> rowid,
});

class $$GpSiteInfoLandBaseTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoLandBaseTable,
    GpSiteInfoLandBaseData,
    $$GpSiteInfoLandBaseTableFilterComposer,
    $$GpSiteInfoLandBaseTableOrderingComposer,
    $$GpSiteInfoLandBaseTableProcessedTableManager,
    $$GpSiteInfoLandBaseTableInsertCompanionBuilder,
    $$GpSiteInfoLandBaseTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandBaseTableTableManager(
      _$Database db, $GpSiteInfoLandBaseTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoLandBaseTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoLandBaseTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoLandBaseTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String?> completion = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandBaseCompanion(
            code: code,
            name: name,
            completion: completion,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<String?> completion = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandBaseCompanion.insert(
            code: code,
            name: name,
            completion: completion,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoLandBaseTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoLandBaseTable,
        GpSiteInfoLandBaseData,
        $$GpSiteInfoLandBaseTableFilterComposer,
        $$GpSiteInfoLandBaseTableOrderingComposer,
        $$GpSiteInfoLandBaseTableProcessedTableManager,
        $$GpSiteInfoLandBaseTableInsertCompanionBuilder,
        $$GpSiteInfoLandBaseTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandBaseTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoLandBaseTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoLandBaseTable> {
  $$GpSiteInfoLandBaseTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get completion => $state.composableBuilder(
      column: $state.table.completion,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoLandBaseTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoLandBaseTable> {
  $$GpSiteInfoLandBaseTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get completion => $state.composableBuilder(
      column: $state.table.completion,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoLandCoverTableInsertCompanionBuilder
    = GpSiteInfoLandCoverCompanion Function({
  required String code,
  required String name,
  d.Value<String?> base,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoLandCoverTableUpdateCompanionBuilder
    = GpSiteInfoLandCoverCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<String?> base,
  d.Value<int> rowid,
});

class $$GpSiteInfoLandCoverTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoLandCoverTable,
    GpSiteInfoLandCoverData,
    $$GpSiteInfoLandCoverTableFilterComposer,
    $$GpSiteInfoLandCoverTableOrderingComposer,
    $$GpSiteInfoLandCoverTableProcessedTableManager,
    $$GpSiteInfoLandCoverTableInsertCompanionBuilder,
    $$GpSiteInfoLandCoverTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandCoverTableTableManager(
      _$Database db, $GpSiteInfoLandCoverTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoLandCoverTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoLandCoverTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoLandCoverTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<String?> base = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandCoverCompanion(
            code: code,
            name: name,
            base: base,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<String?> base = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandCoverCompanion.insert(
            code: code,
            name: name,
            base: base,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoLandCoverTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoLandCoverTable,
        GpSiteInfoLandCoverData,
        $$GpSiteInfoLandCoverTableFilterComposer,
        $$GpSiteInfoLandCoverTableOrderingComposer,
        $$GpSiteInfoLandCoverTableProcessedTableManager,
        $$GpSiteInfoLandCoverTableInsertCompanionBuilder,
        $$GpSiteInfoLandCoverTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandCoverTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoLandCoverTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoLandCoverTable> {
  $$GpSiteInfoLandCoverTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoLandCoverTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoLandCoverTable> {
  $$GpSiteInfoLandCoverTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get base => $state.composableBuilder(
      column: $state.table.base,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoLandPosTableInsertCompanionBuilder
    = GpSiteInfoLandPosCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoLandPosTableUpdateCompanionBuilder
    = GpSiteInfoLandPosCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoLandPosTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoLandPosTable,
    GpSiteInfoLandPo,
    $$GpSiteInfoLandPosTableFilterComposer,
    $$GpSiteInfoLandPosTableOrderingComposer,
    $$GpSiteInfoLandPosTableProcessedTableManager,
    $$GpSiteInfoLandPosTableInsertCompanionBuilder,
    $$GpSiteInfoLandPosTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandPosTableTableManager(
      _$Database db, $GpSiteInfoLandPosTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoLandPosTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoLandPosTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoLandPosTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandPosCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoLandPosCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoLandPosTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoLandPosTable,
        GpSiteInfoLandPo,
        $$GpSiteInfoLandPosTableFilterComposer,
        $$GpSiteInfoLandPosTableOrderingComposer,
        $$GpSiteInfoLandPosTableProcessedTableManager,
        $$GpSiteInfoLandPosTableInsertCompanionBuilder,
        $$GpSiteInfoLandPosTableUpdateCompanionBuilder> {
  $$GpSiteInfoLandPosTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoLandPosTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoLandPosTable> {
  $$GpSiteInfoLandPosTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoLandPosTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoLandPosTable> {
  $$GpSiteInfoLandPosTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoPostProcessingTableInsertCompanionBuilder
    = GpSiteInfoPostProcessingCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoPostProcessingTableUpdateCompanionBuilder
    = GpSiteInfoPostProcessingCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoPostProcessingTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoPostProcessingTable,
    GpSiteInfoPostProcessingData,
    $$GpSiteInfoPostProcessingTableFilterComposer,
    $$GpSiteInfoPostProcessingTableOrderingComposer,
    $$GpSiteInfoPostProcessingTableProcessedTableManager,
    $$GpSiteInfoPostProcessingTableInsertCompanionBuilder,
    $$GpSiteInfoPostProcessingTableUpdateCompanionBuilder> {
  $$GpSiteInfoPostProcessingTableTableManager(
      _$Database db, $GpSiteInfoPostProcessingTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$GpSiteInfoPostProcessingTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$GpSiteInfoPostProcessingTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoPostProcessingTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPostProcessingCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPostProcessingCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoPostProcessingTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoPostProcessingTable,
        GpSiteInfoPostProcessingData,
        $$GpSiteInfoPostProcessingTableFilterComposer,
        $$GpSiteInfoPostProcessingTableOrderingComposer,
        $$GpSiteInfoPostProcessingTableProcessedTableManager,
        $$GpSiteInfoPostProcessingTableInsertCompanionBuilder,
        $$GpSiteInfoPostProcessingTableUpdateCompanionBuilder> {
  $$GpSiteInfoPostProcessingTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoPostProcessingTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoPostProcessingTable> {
  $$GpSiteInfoPostProcessingTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoPostProcessingTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoPostProcessingTable> {
  $$GpSiteInfoPostProcessingTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpSiteInfoPlotIncompleteReasonTableInsertCompanionBuilder
    = GpSiteInfoPlotIncompleteReasonCompanion Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpSiteInfoPlotIncompleteReasonTableUpdateCompanionBuilder
    = GpSiteInfoPlotIncompleteReasonCompanion Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpSiteInfoPlotIncompleteReasonTableTableManager
    extends d.RootTableManager<
        _$Database,
        $GpSiteInfoPlotIncompleteReasonTable,
        GpSiteInfoPlotIncompleteReasonData,
        $$GpSiteInfoPlotIncompleteReasonTableFilterComposer,
        $$GpSiteInfoPlotIncompleteReasonTableOrderingComposer,
        $$GpSiteInfoPlotIncompleteReasonTableProcessedTableManager,
        $$GpSiteInfoPlotIncompleteReasonTableInsertCompanionBuilder,
        $$GpSiteInfoPlotIncompleteReasonTableUpdateCompanionBuilder> {
  $$GpSiteInfoPlotIncompleteReasonTableTableManager(
      _$Database db, $GpSiteInfoPlotIncompleteReasonTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpSiteInfoPlotIncompleteReasonTableFilterComposer(
                  d.ComposerState(db, table)),
          orderingComposer:
              $$GpSiteInfoPlotIncompleteReasonTableOrderingComposer(
                  d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoPlotIncompleteReasonTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPlotIncompleteReasonCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpSiteInfoPlotIncompleteReasonCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpSiteInfoPlotIncompleteReasonTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $GpSiteInfoPlotIncompleteReasonTable,
        GpSiteInfoPlotIncompleteReasonData,
        $$GpSiteInfoPlotIncompleteReasonTableFilterComposer,
        $$GpSiteInfoPlotIncompleteReasonTableOrderingComposer,
        $$GpSiteInfoPlotIncompleteReasonTableProcessedTableManager,
        $$GpSiteInfoPlotIncompleteReasonTableInsertCompanionBuilder,
        $$GpSiteInfoPlotIncompleteReasonTableUpdateCompanionBuilder> {
  $$GpSiteInfoPlotIncompleteReasonTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoPlotIncompleteReasonTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoPlotIncompleteReasonTable> {
  $$GpSiteInfoPlotIncompleteReasonTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpSiteInfoPlotIncompleteReasonTableOrderingComposer extends d
    .OrderingComposer<_$Database, $GpSiteInfoPlotIncompleteReasonTable> {
  $$GpSiteInfoPlotIncompleteReasonTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$GpDistAgentTableInsertCompanionBuilder = GpDistAgentCompanion
    Function({
  required String code,
  required String name,
  d.Value<int> rowid,
});
typedef $$GpDistAgentTableUpdateCompanionBuilder = GpDistAgentCompanion
    Function({
  d.Value<String> code,
  d.Value<String> name,
  d.Value<int> rowid,
});

class $$GpDistAgentTableTableManager extends d.RootTableManager<
    _$Database,
    $GpDistAgentTable,
    GpDistAgentData,
    $$GpDistAgentTableFilterComposer,
    $$GpDistAgentTableOrderingComposer,
    $$GpDistAgentTableProcessedTableManager,
    $$GpDistAgentTableInsertCompanionBuilder,
    $$GpDistAgentTableUpdateCompanionBuilder> {
  $$GpDistAgentTableTableManager(_$Database db, $GpDistAgentTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpDistAgentTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpDistAgentTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpDistAgentTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<String> code = const d.Value.absent(),
            d.Value<String> name = const d.Value.absent(),
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpDistAgentCompanion(
            code: code,
            name: name,
            rowid: rowid,
          ),
          getInsertCompanionBuilder: ({
            required String code,
            required String name,
            d.Value<int> rowid = const d.Value.absent(),
          }) =>
              GpDistAgentCompanion.insert(
            code: code,
            name: name,
            rowid: rowid,
          ),
        ));
}

class $$GpDistAgentTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpDistAgentTable,
    GpDistAgentData,
    $$GpDistAgentTableFilterComposer,
    $$GpDistAgentTableOrderingComposer,
    $$GpDistAgentTableProcessedTableManager,
    $$GpDistAgentTableInsertCompanionBuilder,
    $$GpDistAgentTableUpdateCompanionBuilder> {
  $$GpDistAgentTableProcessedTableManager(super.$state);
}

class $$GpDistAgentTableFilterComposer
    extends d.FilterComposer<_$Database, $GpDistAgentTable> {
  $$GpDistAgentTableFilterComposer(super.$state);
  d.ColumnFilters<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));
}

class $$GpDistAgentTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpDistAgentTable> {
  $$GpDistAgentTableOrderingComposer(super.$state);
  d.ColumnOrderings<String> get code => $state.composableBuilder(
      column: $state.table.code,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get name => $state.composableBuilder(
      column: $state.table.name,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));
}

typedef $$SurveyHeadersTableInsertCompanionBuilder = SurveyHeadersCompanion
    Function({
  d.Value<int> id,
  required int nfiPlot,
  required DateTime measDate,
  required int measNum,
  required String province,
  d.Value<bool> complete,
});
typedef $$SurveyHeadersTableUpdateCompanionBuilder = SurveyHeadersCompanion
    Function({
  d.Value<int> id,
  d.Value<int> nfiPlot,
  d.Value<DateTime> measDate,
  d.Value<int> measNum,
  d.Value<String> province,
  d.Value<bool> complete,
});

class $$SurveyHeadersTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveyHeadersTable,
    SurveyHeader,
    $$SurveyHeadersTableFilterComposer,
    $$SurveyHeadersTableOrderingComposer,
    $$SurveyHeadersTableProcessedTableManager,
    $$SurveyHeadersTableInsertCompanionBuilder,
    $$SurveyHeadersTableUpdateCompanionBuilder> {
  $$SurveyHeadersTableTableManager(_$Database db, $SurveyHeadersTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SurveyHeadersTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SurveyHeadersTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveyHeadersTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> nfiPlot = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<int> measNum = const d.Value.absent(),
            d.Value<String> province = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurveyHeadersCompanion(
            id: id,
            nfiPlot: nfiPlot,
            measDate: measDate,
            measNum: measNum,
            province: province,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int nfiPlot,
            required DateTime measDate,
            required int measNum,
            required String province,
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurveyHeadersCompanion.insert(
            id: id,
            nfiPlot: nfiPlot,
            measDate: measDate,
            measNum: measNum,
            province: province,
            complete: complete,
          ),
        ));
}

class $$SurveyHeadersTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SurveyHeadersTable,
    SurveyHeader,
    $$SurveyHeadersTableFilterComposer,
    $$SurveyHeadersTableOrderingComposer,
    $$SurveyHeadersTableProcessedTableManager,
    $$SurveyHeadersTableInsertCompanionBuilder,
    $$SurveyHeadersTableUpdateCompanionBuilder> {
  $$SurveyHeadersTableProcessedTableManager(super.$state);
}

class $$SurveyHeadersTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveyHeadersTable> {
  $$SurveyHeadersTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get measNum => $state.composableBuilder(
      column: $state.table.measNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$PlotsTableFilterComposer get nfiPlot {
    final $$PlotsTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.nfiPlot,
        referencedTable: $state.db.plots,
        getReferencedColumn: (t) => t.nfiPlot,
        builder: (joinBuilder, parentComposers) => $$PlotsTableFilterComposer(
            d.ComposerState(
                $state.db, $state.db.plots, joinBuilder, parentComposers)));
    return composer;
  }

  $$JurisdictionsTableFilterComposer get province {
    final $$JurisdictionsTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.province,
        referencedTable: $state.db.jurisdictions,
        getReferencedColumn: (t) => t.code,
        builder: (joinBuilder, parentComposers) =>
            $$JurisdictionsTableFilterComposer(d.ComposerState($state.db,
                $state.db.jurisdictions, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter metaCommentRefs(
      d.ComposableFilter Function($$MetaCommentTableFilterComposer f) f) {
    final $$MetaCommentTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.metaComment,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$MetaCommentTableFilterComposer(d.ComposerState($state.db,
                $state.db.metaComment, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveySummaryRefs(
      d.ComposableFilter Function($$SurveySummaryTableFilterComposer f) f) {
    final $$SurveySummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.surveySummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$SurveySummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveySummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveyHeaderGroundPhotoRefs(
      d.ComposableFilter Function(
              $$SurveyHeaderGroundPhotoTableFilterComposer f)
          f) {
    final $$SurveyHeaderGroundPhotoTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surveyHeaderGroundPhoto,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeaderGroundPhotoTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surveyHeaderGroundPhoto,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveyHeaderTreeRefs(
      d.ComposableFilter Function($$SurveyHeaderTreeTableFilterComposer f) f) {
    final $$SurveyHeaderTreeTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surveyHeaderTree,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeaderTreeTableFilterComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaderTree, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveyHeaderEcologicalRefs(
      d.ComposableFilter Function($$SurveyHeaderEcologicalTableFilterComposer f)
          f) {
    final $$SurveyHeaderEcologicalTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surveyHeaderEcological,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeaderEcologicalTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surveyHeaderEcological,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surveyHeaderSoilRefs(
      d.ComposableFilter Function($$SurveyHeaderSoilTableFilterComposer f) f) {
    final $$SurveyHeaderSoilTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surveyHeaderSoil,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeaderSoilTableFilterComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaderSoil, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter woodyDebrisSummaryRefs(
      d.ComposableFilter Function($$WoodyDebrisSummaryTableFilterComposer f)
          f) {
    final $$WoodyDebrisSummaryTableFilterComposer composer = $state
        .composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.woodyDebrisSummary,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisSummaryTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisSummary,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }

  d.ComposableFilter surfaceSubstrateSummaryRefs(
      d.ComposableFilter Function(
              $$SurfaceSubstrateSummaryTableFilterComposer f)
          f) {
    final $$SurfaceSubstrateSummaryTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surfaceSubstrateSummary,
            getReferencedColumn: (t) => t.surveyId,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateSummaryTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateSummary,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ecpSummaryRefs(
      d.ComposableFilter Function($$EcpSummaryTableFilterComposer f) f) {
    final $$EcpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ecpSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$EcpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ecpSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter soilPitSummaryRefs(
      d.ComposableFilter Function($$SoilPitSummaryTableFilterComposer f) f) {
    final $$SoilPitSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.soilPitSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$SoilPitSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ltpSummaryRefs(
      d.ComposableFilter Function($$LtpSummaryTableFilterComposer f) f) {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter stpSummaryRefs(
      d.ComposableFilter Function($$StpSummaryTableFilterComposer f) f) {
    final $$StpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.stpSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$StpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.stpSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter shrubSummaryRefs(
      d.ComposableFilter Function($$ShrubSummaryTableFilterComposer f) f) {
    final $$ShrubSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.shrubSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$ShrubSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.shrubSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter stumpSummaryRefs(
      d.ComposableFilter Function($$StumpSummaryTableFilterComposer f) f) {
    final $$StumpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.stumpSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$StumpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.stumpSummary, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter gpSummaryRefs(
      d.ComposableFilter Function($$GpSummaryTableFilterComposer f) f) {
    final $$GpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.surveyId,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$SurveyHeadersTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveyHeadersTable> {
  $$SurveyHeadersTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get measNum => $state.composableBuilder(
      column: $state.table.measNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$PlotsTableOrderingComposer get nfiPlot {
    final $$PlotsTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.nfiPlot,
        referencedTable: $state.db.plots,
        getReferencedColumn: (t) => t.nfiPlot,
        builder: (joinBuilder, parentComposers) => $$PlotsTableOrderingComposer(
            d.ComposerState(
                $state.db, $state.db.plots, joinBuilder, parentComposers)));
    return composer;
  }

  $$JurisdictionsTableOrderingComposer get province {
    final $$JurisdictionsTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.province,
            referencedTable: $state.db.jurisdictions,
            getReferencedColumn: (t) => t.code,
            builder: (joinBuilder, parentComposers) =>
                $$JurisdictionsTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.jurisdictions, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$MetaCommentTableInsertCompanionBuilder = MetaCommentCompanion
    Function({
  d.Value<int> id,
  required int surveyId,
  required int surveyCategory,
  required String commentText,
});
typedef $$MetaCommentTableUpdateCompanionBuilder = MetaCommentCompanion
    Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<int> surveyCategory,
  d.Value<String> commentText,
});

class $$MetaCommentTableTableManager extends d.RootTableManager<
    _$Database,
    $MetaCommentTable,
    MetaCommentData,
    $$MetaCommentTableFilterComposer,
    $$MetaCommentTableOrderingComposer,
    $$MetaCommentTableProcessedTableManager,
    $$MetaCommentTableInsertCompanionBuilder,
    $$MetaCommentTableUpdateCompanionBuilder> {
  $$MetaCommentTableTableManager(_$Database db, $MetaCommentTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$MetaCommentTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$MetaCommentTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$MetaCommentTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<int> surveyCategory = const d.Value.absent(),
            d.Value<String> commentText = const d.Value.absent(),
          }) =>
              MetaCommentCompanion(
            id: id,
            surveyId: surveyId,
            surveyCategory: surveyCategory,
            commentText: commentText,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required int surveyCategory,
            required String commentText,
          }) =>
              MetaCommentCompanion.insert(
            id: id,
            surveyId: surveyId,
            surveyCategory: surveyCategory,
            commentText: commentText,
          ),
        ));
}

class $$MetaCommentTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $MetaCommentTable,
    MetaCommentData,
    $$MetaCommentTableFilterComposer,
    $$MetaCommentTableOrderingComposer,
    $$MetaCommentTableProcessedTableManager,
    $$MetaCommentTableInsertCompanionBuilder,
    $$MetaCommentTableUpdateCompanionBuilder> {
  $$MetaCommentTableProcessedTableManager(super.$state);
}

class $$MetaCommentTableFilterComposer
    extends d.FilterComposer<_$Database, $MetaCommentTable> {
  $$MetaCommentTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get surveyCategory => $state.composableBuilder(
      column: $state.table.surveyCategory,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get commentText => $state.composableBuilder(
      column: $state.table.commentText,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter ecpSpeciesRefs(
      d.ComposableFilter Function($$EcpSpeciesTableFilterComposer f) f) {
    final $$EcpSpeciesTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ecpSpecies,
        getReferencedColumn: (t) => t.commentId,
        builder: (joinBuilder, parentComposers) =>
            $$EcpSpeciesTableFilterComposer(d.ComposerState($state.db,
                $state.db.ecpSpecies, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$MetaCommentTableOrderingComposer
    extends d.OrderingComposer<_$Database, $MetaCommentTable> {
  $$MetaCommentTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get surveyCategory => $state.composableBuilder(
      column: $state.table.surveyCategory,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get commentText => $state.composableBuilder(
      column: $state.table.commentText,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurveySummaryTableInsertCompanionBuilder = SurveySummaryCompanion
    Function({
  d.Value<int> id,
  required int surveyId,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
  d.Value<int?> referenceTree,
  d.Value<String?> crewOne,
  d.Value<String?> crewTwo,
  d.Value<String?> crewThree,
  d.Value<int?> numberPhotos,
});
typedef $$SurveySummaryTableUpdateCompanionBuilder = SurveySummaryCompanion
    Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
  d.Value<int?> referenceTree,
  d.Value<String?> crewOne,
  d.Value<String?> crewTwo,
  d.Value<String?> crewThree,
  d.Value<int?> numberPhotos,
});

class $$SurveySummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveySummaryTable,
    SurveySummaryData,
    $$SurveySummaryTableFilterComposer,
    $$SurveySummaryTableOrderingComposer,
    $$SurveySummaryTableProcessedTableManager,
    $$SurveySummaryTableInsertCompanionBuilder,
    $$SurveySummaryTableUpdateCompanionBuilder> {
  $$SurveySummaryTableTableManager(_$Database db, $SurveySummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SurveySummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SurveySummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveySummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
            d.Value<int?> referenceTree = const d.Value.absent(),
            d.Value<String?> crewOne = const d.Value.absent(),
            d.Value<String?> crewTwo = const d.Value.absent(),
            d.Value<String?> crewThree = const d.Value.absent(),
            d.Value<int?> numberPhotos = const d.Value.absent(),
          }) =>
              SurveySummaryCompanion(
            id: id,
            surveyId: surveyId,
            notAssessed: notAssessed,
            complete: complete,
            referenceTree: referenceTree,
            crewOne: crewOne,
            crewTwo: crewTwo,
            crewThree: crewThree,
            numberPhotos: numberPhotos,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
            d.Value<int?> referenceTree = const d.Value.absent(),
            d.Value<String?> crewOne = const d.Value.absent(),
            d.Value<String?> crewTwo = const d.Value.absent(),
            d.Value<String?> crewThree = const d.Value.absent(),
            d.Value<int?> numberPhotos = const d.Value.absent(),
          }) =>
              SurveySummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            notAssessed: notAssessed,
            complete: complete,
            referenceTree: referenceTree,
            crewOne: crewOne,
            crewTwo: crewTwo,
            crewThree: crewThree,
            numberPhotos: numberPhotos,
          ),
        ));
}

class $$SurveySummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SurveySummaryTable,
    SurveySummaryData,
    $$SurveySummaryTableFilterComposer,
    $$SurveySummaryTableOrderingComposer,
    $$SurveySummaryTableProcessedTableManager,
    $$SurveySummaryTableInsertCompanionBuilder,
    $$SurveySummaryTableUpdateCompanionBuilder> {
  $$SurveySummaryTableProcessedTableManager(super.$state);
}

class $$SurveySummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveySummaryTable> {
  $$SurveySummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get referenceTree => $state.composableBuilder(
      column: $state.table.referenceTree,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get crewOne => $state.composableBuilder(
      column: $state.table.crewOne,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get crewTwo => $state.composableBuilder(
      column: $state.table.crewTwo,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get crewThree => $state.composableBuilder(
      column: $state.table.crewThree,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get numberPhotos => $state.composableBuilder(
      column: $state.table.numberPhotos,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SurveySummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveySummaryTable> {
  $$SurveySummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get referenceTree => $state.composableBuilder(
      column: $state.table.referenceTree,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get crewOne => $state.composableBuilder(
      column: $state.table.crewOne,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get crewTwo => $state.composableBuilder(
      column: $state.table.crewTwo,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get crewThree => $state.composableBuilder(
      column: $state.table.crewThree,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get numberPhotos => $state.composableBuilder(
      column: $state.table.numberPhotos,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurveyHeaderGroundPhotoTableInsertCompanionBuilder
    = SurveyHeaderGroundPhotoCompanion Function({
  d.Value<int> id,
  required int surveyId,
  d.Value<bool?> plotPin,
  d.Value<bool?> transectOneFifteenUnder,
  d.Value<bool?> transectOneFifteenOver,
  d.Value<bool?> transectTwoFifteenUnder,
  d.Value<bool?> transectTwoFifteenOver,
  d.Value<bool?> horizontal,
  d.Value<bool?> canopy,
  d.Value<bool?> soilProfile,
  d.Value<bool?> otherOne,
  d.Value<bool?> otherTwo,
  d.Value<bool?> otherThree,
  d.Value<bool?> otherFour,
});
typedef $$SurveyHeaderGroundPhotoTableUpdateCompanionBuilder
    = SurveyHeaderGroundPhotoCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<bool?> plotPin,
  d.Value<bool?> transectOneFifteenUnder,
  d.Value<bool?> transectOneFifteenOver,
  d.Value<bool?> transectTwoFifteenUnder,
  d.Value<bool?> transectTwoFifteenOver,
  d.Value<bool?> horizontal,
  d.Value<bool?> canopy,
  d.Value<bool?> soilProfile,
  d.Value<bool?> otherOne,
  d.Value<bool?> otherTwo,
  d.Value<bool?> otherThree,
  d.Value<bool?> otherFour,
});

class $$SurveyHeaderGroundPhotoTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveyHeaderGroundPhotoTable,
    SurveyHeaderGroundPhotoData,
    $$SurveyHeaderGroundPhotoTableFilterComposer,
    $$SurveyHeaderGroundPhotoTableOrderingComposer,
    $$SurveyHeaderGroundPhotoTableProcessedTableManager,
    $$SurveyHeaderGroundPhotoTableInsertCompanionBuilder,
    $$SurveyHeaderGroundPhotoTableUpdateCompanionBuilder> {
  $$SurveyHeaderGroundPhotoTableTableManager(
      _$Database db, $SurveyHeaderGroundPhotoTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SurveyHeaderGroundPhotoTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SurveyHeaderGroundPhotoTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveyHeaderGroundPhotoTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<bool?> plotPin = const d.Value.absent(),
            d.Value<bool?> transectOneFifteenUnder = const d.Value.absent(),
            d.Value<bool?> transectOneFifteenOver = const d.Value.absent(),
            d.Value<bool?> transectTwoFifteenUnder = const d.Value.absent(),
            d.Value<bool?> transectTwoFifteenOver = const d.Value.absent(),
            d.Value<bool?> horizontal = const d.Value.absent(),
            d.Value<bool?> canopy = const d.Value.absent(),
            d.Value<bool?> soilProfile = const d.Value.absent(),
            d.Value<bool?> otherOne = const d.Value.absent(),
            d.Value<bool?> otherTwo = const d.Value.absent(),
            d.Value<bool?> otherThree = const d.Value.absent(),
            d.Value<bool?> otherFour = const d.Value.absent(),
          }) =>
              SurveyHeaderGroundPhotoCompanion(
            id: id,
            surveyId: surveyId,
            plotPin: plotPin,
            transectOneFifteenUnder: transectOneFifteenUnder,
            transectOneFifteenOver: transectOneFifteenOver,
            transectTwoFifteenUnder: transectTwoFifteenUnder,
            transectTwoFifteenOver: transectTwoFifteenOver,
            horizontal: horizontal,
            canopy: canopy,
            soilProfile: soilProfile,
            otherOne: otherOne,
            otherTwo: otherTwo,
            otherThree: otherThree,
            otherFour: otherFour,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            d.Value<bool?> plotPin = const d.Value.absent(),
            d.Value<bool?> transectOneFifteenUnder = const d.Value.absent(),
            d.Value<bool?> transectOneFifteenOver = const d.Value.absent(),
            d.Value<bool?> transectTwoFifteenUnder = const d.Value.absent(),
            d.Value<bool?> transectTwoFifteenOver = const d.Value.absent(),
            d.Value<bool?> horizontal = const d.Value.absent(),
            d.Value<bool?> canopy = const d.Value.absent(),
            d.Value<bool?> soilProfile = const d.Value.absent(),
            d.Value<bool?> otherOne = const d.Value.absent(),
            d.Value<bool?> otherTwo = const d.Value.absent(),
            d.Value<bool?> otherThree = const d.Value.absent(),
            d.Value<bool?> otherFour = const d.Value.absent(),
          }) =>
              SurveyHeaderGroundPhotoCompanion.insert(
            id: id,
            surveyId: surveyId,
            plotPin: plotPin,
            transectOneFifteenUnder: transectOneFifteenUnder,
            transectOneFifteenOver: transectOneFifteenOver,
            transectTwoFifteenUnder: transectTwoFifteenUnder,
            transectTwoFifteenOver: transectTwoFifteenOver,
            horizontal: horizontal,
            canopy: canopy,
            soilProfile: soilProfile,
            otherOne: otherOne,
            otherTwo: otherTwo,
            otherThree: otherThree,
            otherFour: otherFour,
          ),
        ));
}

class $$SurveyHeaderGroundPhotoTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurveyHeaderGroundPhotoTable,
        SurveyHeaderGroundPhotoData,
        $$SurveyHeaderGroundPhotoTableFilterComposer,
        $$SurveyHeaderGroundPhotoTableOrderingComposer,
        $$SurveyHeaderGroundPhotoTableProcessedTableManager,
        $$SurveyHeaderGroundPhotoTableInsertCompanionBuilder,
        $$SurveyHeaderGroundPhotoTableUpdateCompanionBuilder> {
  $$SurveyHeaderGroundPhotoTableProcessedTableManager(super.$state);
}

class $$SurveyHeaderGroundPhotoTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveyHeaderGroundPhotoTable> {
  $$SurveyHeaderGroundPhotoTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get plotPin => $state.composableBuilder(
      column: $state.table.plotPin,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get transectOneFifteenUnder => $state.composableBuilder(
      column: $state.table.transectOneFifteenUnder,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get transectOneFifteenOver => $state.composableBuilder(
      column: $state.table.transectOneFifteenOver,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get transectTwoFifteenUnder => $state.composableBuilder(
      column: $state.table.transectTwoFifteenUnder,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get transectTwoFifteenOver => $state.composableBuilder(
      column: $state.table.transectTwoFifteenOver,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get horizontal => $state.composableBuilder(
      column: $state.table.horizontal,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get canopy => $state.composableBuilder(
      column: $state.table.canopy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get soilProfile => $state.composableBuilder(
      column: $state.table.soilProfile,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get otherOne => $state.composableBuilder(
      column: $state.table.otherOne,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get otherTwo => $state.composableBuilder(
      column: $state.table.otherTwo,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get otherThree => $state.composableBuilder(
      column: $state.table.otherThree,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get otherFour => $state.composableBuilder(
      column: $state.table.otherFour,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SurveyHeaderGroundPhotoTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveyHeaderGroundPhotoTable> {
  $$SurveyHeaderGroundPhotoTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get plotPin => $state.composableBuilder(
      column: $state.table.plotPin,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get transectOneFifteenUnder =>
      $state.composableBuilder(
          column: $state.table.transectOneFifteenUnder,
          builder: (column, joinBuilders) =>
              d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get transectOneFifteenOver =>
      $state.composableBuilder(
          column: $state.table.transectOneFifteenOver,
          builder: (column, joinBuilders) =>
              d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get transectTwoFifteenUnder =>
      $state.composableBuilder(
          column: $state.table.transectTwoFifteenUnder,
          builder: (column, joinBuilders) =>
              d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get transectTwoFifteenOver =>
      $state.composableBuilder(
          column: $state.table.transectTwoFifteenOver,
          builder: (column, joinBuilders) =>
              d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get horizontal => $state.composableBuilder(
      column: $state.table.horizontal,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get canopy => $state.composableBuilder(
      column: $state.table.canopy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get soilProfile => $state.composableBuilder(
      column: $state.table.soilProfile,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get otherOne => $state.composableBuilder(
      column: $state.table.otherOne,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get otherTwo => $state.composableBuilder(
      column: $state.table.otherTwo,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get otherThree => $state.composableBuilder(
      column: $state.table.otherThree,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get otherFour => $state.composableBuilder(
      column: $state.table.otherFour,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurveyHeaderTreeTableInsertCompanionBuilder
    = SurveyHeaderTreeCompanion Function({
  d.Value<int> id,
  required int surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});
typedef $$SurveyHeaderTreeTableUpdateCompanionBuilder
    = SurveyHeaderTreeCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});

class $$SurveyHeaderTreeTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveyHeaderTreeTable,
    SurveyHeaderTreeData,
    $$SurveyHeaderTreeTableFilterComposer,
    $$SurveyHeaderTreeTableOrderingComposer,
    $$SurveyHeaderTreeTableProcessedTableManager,
    $$SurveyHeaderTreeTableInsertCompanionBuilder,
    $$SurveyHeaderTreeTableUpdateCompanionBuilder> {
  $$SurveyHeaderTreeTableTableManager(
      _$Database db, $SurveyHeaderTreeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SurveyHeaderTreeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$SurveyHeaderTreeTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveyHeaderTreeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderTreeCompanion(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderTreeCompanion.insert(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
        ));
}

class $$SurveyHeaderTreeTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurveyHeaderTreeTable,
        SurveyHeaderTreeData,
        $$SurveyHeaderTreeTableFilterComposer,
        $$SurveyHeaderTreeTableOrderingComposer,
        $$SurveyHeaderTreeTableProcessedTableManager,
        $$SurveyHeaderTreeTableInsertCompanionBuilder,
        $$SurveyHeaderTreeTableUpdateCompanionBuilder> {
  $$SurveyHeaderTreeTableProcessedTableManager(super.$state);
}

class $$SurveyHeaderTreeTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveyHeaderTreeTable> {
  $$SurveyHeaderTreeTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SurveyHeaderTreeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveyHeaderTreeTable> {
  $$SurveyHeaderTreeTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurveyHeaderEcologicalTableInsertCompanionBuilder
    = SurveyHeaderEcologicalCompanion Function({
  d.Value<int> id,
  required int surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});
typedef $$SurveyHeaderEcologicalTableUpdateCompanionBuilder
    = SurveyHeaderEcologicalCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});

class $$SurveyHeaderEcologicalTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveyHeaderEcologicalTable,
    SurveyHeaderEcologicalData,
    $$SurveyHeaderEcologicalTableFilterComposer,
    $$SurveyHeaderEcologicalTableOrderingComposer,
    $$SurveyHeaderEcologicalTableProcessedTableManager,
    $$SurveyHeaderEcologicalTableInsertCompanionBuilder,
    $$SurveyHeaderEcologicalTableUpdateCompanionBuilder> {
  $$SurveyHeaderEcologicalTableTableManager(
      _$Database db, $SurveyHeaderEcologicalTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SurveyHeaderEcologicalTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SurveyHeaderEcologicalTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveyHeaderEcologicalTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderEcologicalCompanion(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderEcologicalCompanion.insert(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
        ));
}

class $$SurveyHeaderEcologicalTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurveyHeaderEcologicalTable,
        SurveyHeaderEcologicalData,
        $$SurveyHeaderEcologicalTableFilterComposer,
        $$SurveyHeaderEcologicalTableOrderingComposer,
        $$SurveyHeaderEcologicalTableProcessedTableManager,
        $$SurveyHeaderEcologicalTableInsertCompanionBuilder,
        $$SurveyHeaderEcologicalTableUpdateCompanionBuilder> {
  $$SurveyHeaderEcologicalTableProcessedTableManager(super.$state);
}

class $$SurveyHeaderEcologicalTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveyHeaderEcologicalTable> {
  $$SurveyHeaderEcologicalTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SurveyHeaderEcologicalTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveyHeaderEcologicalTable> {
  $$SurveyHeaderEcologicalTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurveyHeaderSoilTableInsertCompanionBuilder
    = SurveyHeaderSoilCompanion Function({
  d.Value<int> id,
  required int surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});
typedef $$SurveyHeaderSoilTableUpdateCompanionBuilder
    = SurveyHeaderSoilCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<String?> fieldResponsibility,
  d.Value<String?> fieldCheckBy,
  d.Value<DateTime?> fieldDate,
  d.Value<String?> officeCheckBy,
  d.Value<DateTime?> officeDate,
});

class $$SurveyHeaderSoilTableTableManager extends d.RootTableManager<
    _$Database,
    $SurveyHeaderSoilTable,
    SurveyHeaderSoilData,
    $$SurveyHeaderSoilTableFilterComposer,
    $$SurveyHeaderSoilTableOrderingComposer,
    $$SurveyHeaderSoilTableProcessedTableManager,
    $$SurveyHeaderSoilTableInsertCompanionBuilder,
    $$SurveyHeaderSoilTableUpdateCompanionBuilder> {
  $$SurveyHeaderSoilTableTableManager(
      _$Database db, $SurveyHeaderSoilTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SurveyHeaderSoilTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$SurveyHeaderSoilTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurveyHeaderSoilTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderSoilCompanion(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            d.Value<String?> fieldResponsibility = const d.Value.absent(),
            d.Value<String?> fieldCheckBy = const d.Value.absent(),
            d.Value<DateTime?> fieldDate = const d.Value.absent(),
            d.Value<String?> officeCheckBy = const d.Value.absent(),
            d.Value<DateTime?> officeDate = const d.Value.absent(),
          }) =>
              SurveyHeaderSoilCompanion.insert(
            id: id,
            surveyId: surveyId,
            fieldResponsibility: fieldResponsibility,
            fieldCheckBy: fieldCheckBy,
            fieldDate: fieldDate,
            officeCheckBy: officeCheckBy,
            officeDate: officeDate,
          ),
        ));
}

class $$SurveyHeaderSoilTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurveyHeaderSoilTable,
        SurveyHeaderSoilData,
        $$SurveyHeaderSoilTableFilterComposer,
        $$SurveyHeaderSoilTableOrderingComposer,
        $$SurveyHeaderSoilTableProcessedTableManager,
        $$SurveyHeaderSoilTableInsertCompanionBuilder,
        $$SurveyHeaderSoilTableUpdateCompanionBuilder> {
  $$SurveyHeaderSoilTableProcessedTableManager(super.$state);
}

class $$SurveyHeaderSoilTableFilterComposer
    extends d.FilterComposer<_$Database, $SurveyHeaderSoilTable> {
  $$SurveyHeaderSoilTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SurveyHeaderSoilTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurveyHeaderSoilTable> {
  $$SurveyHeaderSoilTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldResponsibility => $state.composableBuilder(
      column: $state.table.fieldResponsibility,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get fieldCheckBy => $state.composableBuilder(
      column: $state.table.fieldCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get fieldDate => $state.composableBuilder(
      column: $state.table.fieldDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get officeCheckBy => $state.composableBuilder(
      column: $state.table.officeCheckBy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get officeDate => $state.composableBuilder(
      column: $state.table.officeDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$WoodyDebrisSummaryTableInsertCompanionBuilder
    = WoodyDebrisSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<int?> numTransects,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$WoodyDebrisSummaryTableUpdateCompanionBuilder
    = WoodyDebrisSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<int?> numTransects,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$WoodyDebrisSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $WoodyDebrisSummaryTable,
    WoodyDebrisSummaryData,
    $$WoodyDebrisSummaryTableFilterComposer,
    $$WoodyDebrisSummaryTableOrderingComposer,
    $$WoodyDebrisSummaryTableProcessedTableManager,
    $$WoodyDebrisSummaryTableInsertCompanionBuilder,
    $$WoodyDebrisSummaryTableUpdateCompanionBuilder> {
  $$WoodyDebrisSummaryTableTableManager(
      _$Database db, $WoodyDebrisSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$WoodyDebrisSummaryTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$WoodyDebrisSummaryTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$WoodyDebrisSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<int?> numTransects = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              WoodyDebrisSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numTransects: numTransects,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<int?> numTransects = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              WoodyDebrisSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numTransects: numTransects,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$WoodyDebrisSummaryTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $WoodyDebrisSummaryTable,
        WoodyDebrisSummaryData,
        $$WoodyDebrisSummaryTableFilterComposer,
        $$WoodyDebrisSummaryTableOrderingComposer,
        $$WoodyDebrisSummaryTableProcessedTableManager,
        $$WoodyDebrisSummaryTableInsertCompanionBuilder,
        $$WoodyDebrisSummaryTableUpdateCompanionBuilder> {
  $$WoodyDebrisSummaryTableProcessedTableManager(super.$state);
}

class $$WoodyDebrisSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $WoodyDebrisSummaryTable> {
  $$WoodyDebrisSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get numTransects => $state.composableBuilder(
      column: $state.table.numTransects,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter woodyDebrisHeaderRefs(
      d.ComposableFilter Function($$WoodyDebrisHeaderTableFilterComposer f) f) {
    final $$WoodyDebrisHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.wdId,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }
}

class $$WoodyDebrisSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $WoodyDebrisSummaryTable> {
  $$WoodyDebrisSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get numTransects => $state.composableBuilder(
      column: $state.table.numTransects,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$WoodyDebrisHeaderTableInsertCompanionBuilder
    = WoodyDebrisHeaderCompanion Function({
  d.Value<int> id,
  required int wdId,
  d.Value<int?> transNum,
  d.Value<double?> nomTransLen,
  d.Value<int?> transAzimuth,
  d.Value<double?> swdMeasLen,
  d.Value<double?> mcwdMeasLen,
  d.Value<double?> lcwdMeasLen,
  d.Value<int?> swdDecayClass,
  d.Value<bool> complete,
});
typedef $$WoodyDebrisHeaderTableUpdateCompanionBuilder
    = WoodyDebrisHeaderCompanion Function({
  d.Value<int> id,
  d.Value<int> wdId,
  d.Value<int?> transNum,
  d.Value<double?> nomTransLen,
  d.Value<int?> transAzimuth,
  d.Value<double?> swdMeasLen,
  d.Value<double?> mcwdMeasLen,
  d.Value<double?> lcwdMeasLen,
  d.Value<int?> swdDecayClass,
  d.Value<bool> complete,
});

class $$WoodyDebrisHeaderTableTableManager extends d.RootTableManager<
    _$Database,
    $WoodyDebrisHeaderTable,
    WoodyDebrisHeaderData,
    $$WoodyDebrisHeaderTableFilterComposer,
    $$WoodyDebrisHeaderTableOrderingComposer,
    $$WoodyDebrisHeaderTableProcessedTableManager,
    $$WoodyDebrisHeaderTableInsertCompanionBuilder,
    $$WoodyDebrisHeaderTableUpdateCompanionBuilder> {
  $$WoodyDebrisHeaderTableTableManager(
      _$Database db, $WoodyDebrisHeaderTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$WoodyDebrisHeaderTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$WoodyDebrisHeaderTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$WoodyDebrisHeaderTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> wdId = const d.Value.absent(),
            d.Value<int?> transNum = const d.Value.absent(),
            d.Value<double?> nomTransLen = const d.Value.absent(),
            d.Value<int?> transAzimuth = const d.Value.absent(),
            d.Value<double?> swdMeasLen = const d.Value.absent(),
            d.Value<double?> mcwdMeasLen = const d.Value.absent(),
            d.Value<double?> lcwdMeasLen = const d.Value.absent(),
            d.Value<int?> swdDecayClass = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              WoodyDebrisHeaderCompanion(
            id: id,
            wdId: wdId,
            transNum: transNum,
            nomTransLen: nomTransLen,
            transAzimuth: transAzimuth,
            swdMeasLen: swdMeasLen,
            mcwdMeasLen: mcwdMeasLen,
            lcwdMeasLen: lcwdMeasLen,
            swdDecayClass: swdDecayClass,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int wdId,
            d.Value<int?> transNum = const d.Value.absent(),
            d.Value<double?> nomTransLen = const d.Value.absent(),
            d.Value<int?> transAzimuth = const d.Value.absent(),
            d.Value<double?> swdMeasLen = const d.Value.absent(),
            d.Value<double?> mcwdMeasLen = const d.Value.absent(),
            d.Value<double?> lcwdMeasLen = const d.Value.absent(),
            d.Value<int?> swdDecayClass = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              WoodyDebrisHeaderCompanion.insert(
            id: id,
            wdId: wdId,
            transNum: transNum,
            nomTransLen: nomTransLen,
            transAzimuth: transAzimuth,
            swdMeasLen: swdMeasLen,
            mcwdMeasLen: mcwdMeasLen,
            lcwdMeasLen: lcwdMeasLen,
            swdDecayClass: swdDecayClass,
            complete: complete,
          ),
        ));
}

class $$WoodyDebrisHeaderTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $WoodyDebrisHeaderTable,
        WoodyDebrisHeaderData,
        $$WoodyDebrisHeaderTableFilterComposer,
        $$WoodyDebrisHeaderTableOrderingComposer,
        $$WoodyDebrisHeaderTableProcessedTableManager,
        $$WoodyDebrisHeaderTableInsertCompanionBuilder,
        $$WoodyDebrisHeaderTableUpdateCompanionBuilder> {
  $$WoodyDebrisHeaderTableProcessedTableManager(super.$state);
}

class $$WoodyDebrisHeaderTableFilterComposer
    extends d.FilterComposer<_$Database, $WoodyDebrisHeaderTable> {
  $$WoodyDebrisHeaderTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get transNum => $state.composableBuilder(
      column: $state.table.transNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomTransLen => $state.composableBuilder(
      column: $state.table.nomTransLen,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get transAzimuth => $state.composableBuilder(
      column: $state.table.transAzimuth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get swdMeasLen => $state.composableBuilder(
      column: $state.table.swdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get mcwdMeasLen => $state.composableBuilder(
      column: $state.table.mcwdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get lcwdMeasLen => $state.composableBuilder(
      column: $state.table.lcwdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get swdDecayClass => $state.composableBuilder(
      column: $state.table.swdDecayClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$WoodyDebrisSummaryTableFilterComposer get wdId {
    final $$WoodyDebrisSummaryTableFilterComposer composer = $state
        .composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdId,
            referencedTable: $state.db.woodyDebrisSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisSummaryTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisSummary,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  d.ComposableFilter woodyDebrisSmallRefs(
      d.ComposableFilter Function($$WoodyDebrisSmallTableFilterComposer f) f) {
    final $$WoodyDebrisSmallTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.woodyDebrisSmall,
            getReferencedColumn: (t) => t.wdHeaderId,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisSmallTableFilterComposer(d.ComposerState($state.db,
                    $state.db.woodyDebrisSmall, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter woodyDebrisOddRefs(
      d.ComposableFilter Function($$WoodyDebrisOddTableFilterComposer f) f) {
    final $$WoodyDebrisOddTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.woodyDebrisOdd,
        getReferencedColumn: (t) => t.wdHeaderId,
        builder: (joinBuilder, parentComposers) =>
            $$WoodyDebrisOddTableFilterComposer(d.ComposerState($state.db,
                $state.db.woodyDebrisOdd, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter woodyDebrisRoundRefs(
      d.ComposableFilter Function($$WoodyDebrisRoundTableFilterComposer f) f) {
    final $$WoodyDebrisRoundTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.woodyDebrisRound,
            getReferencedColumn: (t) => t.wdHeaderId,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisRoundTableFilterComposer(d.ComposerState($state.db,
                    $state.db.woodyDebrisRound, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$WoodyDebrisHeaderTableOrderingComposer
    extends d.OrderingComposer<_$Database, $WoodyDebrisHeaderTable> {
  $$WoodyDebrisHeaderTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get transNum => $state.composableBuilder(
      column: $state.table.transNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomTransLen => $state.composableBuilder(
      column: $state.table.nomTransLen,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get transAzimuth => $state.composableBuilder(
      column: $state.table.transAzimuth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get swdMeasLen => $state.composableBuilder(
      column: $state.table.swdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get mcwdMeasLen => $state.composableBuilder(
      column: $state.table.mcwdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get lcwdMeasLen => $state.composableBuilder(
      column: $state.table.lcwdMeasLen,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get swdDecayClass => $state.composableBuilder(
      column: $state.table.swdDecayClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$WoodyDebrisSummaryTableOrderingComposer get wdId {
    final $$WoodyDebrisSummaryTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdId,
            referencedTable: $state.db.woodyDebrisSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisSummaryTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisSummary,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

typedef $$WoodyDebrisSmallTableInsertCompanionBuilder
    = WoodyDebrisSmallCompanion Function({
  d.Value<int> id,
  required int wdHeaderId,
  d.Value<int> swdTallyS,
  d.Value<int> swdTallyM,
  d.Value<int> swdTallyL,
});
typedef $$WoodyDebrisSmallTableUpdateCompanionBuilder
    = WoodyDebrisSmallCompanion Function({
  d.Value<int> id,
  d.Value<int> wdHeaderId,
  d.Value<int> swdTallyS,
  d.Value<int> swdTallyM,
  d.Value<int> swdTallyL,
});

class $$WoodyDebrisSmallTableTableManager extends d.RootTableManager<
    _$Database,
    $WoodyDebrisSmallTable,
    WoodyDebrisSmallData,
    $$WoodyDebrisSmallTableFilterComposer,
    $$WoodyDebrisSmallTableOrderingComposer,
    $$WoodyDebrisSmallTableProcessedTableManager,
    $$WoodyDebrisSmallTableInsertCompanionBuilder,
    $$WoodyDebrisSmallTableUpdateCompanionBuilder> {
  $$WoodyDebrisSmallTableTableManager(
      _$Database db, $WoodyDebrisSmallTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$WoodyDebrisSmallTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$WoodyDebrisSmallTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$WoodyDebrisSmallTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> wdHeaderId = const d.Value.absent(),
            d.Value<int> swdTallyS = const d.Value.absent(),
            d.Value<int> swdTallyM = const d.Value.absent(),
            d.Value<int> swdTallyL = const d.Value.absent(),
          }) =>
              WoodyDebrisSmallCompanion(
            id: id,
            wdHeaderId: wdHeaderId,
            swdTallyS: swdTallyS,
            swdTallyM: swdTallyM,
            swdTallyL: swdTallyL,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int wdHeaderId,
            d.Value<int> swdTallyS = const d.Value.absent(),
            d.Value<int> swdTallyM = const d.Value.absent(),
            d.Value<int> swdTallyL = const d.Value.absent(),
          }) =>
              WoodyDebrisSmallCompanion.insert(
            id: id,
            wdHeaderId: wdHeaderId,
            swdTallyS: swdTallyS,
            swdTallyM: swdTallyM,
            swdTallyL: swdTallyL,
          ),
        ));
}

class $$WoodyDebrisSmallTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $WoodyDebrisSmallTable,
        WoodyDebrisSmallData,
        $$WoodyDebrisSmallTableFilterComposer,
        $$WoodyDebrisSmallTableOrderingComposer,
        $$WoodyDebrisSmallTableProcessedTableManager,
        $$WoodyDebrisSmallTableInsertCompanionBuilder,
        $$WoodyDebrisSmallTableUpdateCompanionBuilder> {
  $$WoodyDebrisSmallTableProcessedTableManager(super.$state);
}

class $$WoodyDebrisSmallTableFilterComposer
    extends d.FilterComposer<_$Database, $WoodyDebrisSmallTable> {
  $$WoodyDebrisSmallTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get swdTallyS => $state.composableBuilder(
      column: $state.table.swdTallyS,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get swdTallyM => $state.composableBuilder(
      column: $state.table.swdTallyM,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get swdTallyL => $state.composableBuilder(
      column: $state.table.swdTallyL,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableFilterComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

class $$WoodyDebrisSmallTableOrderingComposer
    extends d.OrderingComposer<_$Database, $WoodyDebrisSmallTable> {
  $$WoodyDebrisSmallTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get swdTallyS => $state.composableBuilder(
      column: $state.table.swdTallyS,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get swdTallyM => $state.composableBuilder(
      column: $state.table.swdTallyM,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get swdTallyL => $state.composableBuilder(
      column: $state.table.swdTallyL,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableOrderingComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

typedef $$WoodyDebrisOddTableInsertCompanionBuilder = WoodyDebrisOddCompanion
    Function({
  d.Value<int> id,
  required int wdHeaderId,
  required int pieceNum,
  required String accumOdd,
  required String genus,
  required String species,
  required double horLength,
  required double verDepth,
  d.Value<int?> decayClass,
});
typedef $$WoodyDebrisOddTableUpdateCompanionBuilder = WoodyDebrisOddCompanion
    Function({
  d.Value<int> id,
  d.Value<int> wdHeaderId,
  d.Value<int> pieceNum,
  d.Value<String> accumOdd,
  d.Value<String> genus,
  d.Value<String> species,
  d.Value<double> horLength,
  d.Value<double> verDepth,
  d.Value<int?> decayClass,
});

class $$WoodyDebrisOddTableTableManager extends d.RootTableManager<
    _$Database,
    $WoodyDebrisOddTable,
    WoodyDebrisOddData,
    $$WoodyDebrisOddTableFilterComposer,
    $$WoodyDebrisOddTableOrderingComposer,
    $$WoodyDebrisOddTableProcessedTableManager,
    $$WoodyDebrisOddTableInsertCompanionBuilder,
    $$WoodyDebrisOddTableUpdateCompanionBuilder> {
  $$WoodyDebrisOddTableTableManager(_$Database db, $WoodyDebrisOddTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$WoodyDebrisOddTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$WoodyDebrisOddTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$WoodyDebrisOddTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> wdHeaderId = const d.Value.absent(),
            d.Value<int> pieceNum = const d.Value.absent(),
            d.Value<String> accumOdd = const d.Value.absent(),
            d.Value<String> genus = const d.Value.absent(),
            d.Value<String> species = const d.Value.absent(),
            d.Value<double> horLength = const d.Value.absent(),
            d.Value<double> verDepth = const d.Value.absent(),
            d.Value<int?> decayClass = const d.Value.absent(),
          }) =>
              WoodyDebrisOddCompanion(
            id: id,
            wdHeaderId: wdHeaderId,
            pieceNum: pieceNum,
            accumOdd: accumOdd,
            genus: genus,
            species: species,
            horLength: horLength,
            verDepth: verDepth,
            decayClass: decayClass,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int wdHeaderId,
            required int pieceNum,
            required String accumOdd,
            required String genus,
            required String species,
            required double horLength,
            required double verDepth,
            d.Value<int?> decayClass = const d.Value.absent(),
          }) =>
              WoodyDebrisOddCompanion.insert(
            id: id,
            wdHeaderId: wdHeaderId,
            pieceNum: pieceNum,
            accumOdd: accumOdd,
            genus: genus,
            species: species,
            horLength: horLength,
            verDepth: verDepth,
            decayClass: decayClass,
          ),
        ));
}

class $$WoodyDebrisOddTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $WoodyDebrisOddTable,
        WoodyDebrisOddData,
        $$WoodyDebrisOddTableFilterComposer,
        $$WoodyDebrisOddTableOrderingComposer,
        $$WoodyDebrisOddTableProcessedTableManager,
        $$WoodyDebrisOddTableInsertCompanionBuilder,
        $$WoodyDebrisOddTableUpdateCompanionBuilder> {
  $$WoodyDebrisOddTableProcessedTableManager(super.$state);
}

class $$WoodyDebrisOddTableFilterComposer
    extends d.FilterComposer<_$Database, $WoodyDebrisOddTable> {
  $$WoodyDebrisOddTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get pieceNum => $state.composableBuilder(
      column: $state.table.pieceNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get accumOdd => $state.composableBuilder(
      column: $state.table.accumOdd,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get horLength => $state.composableBuilder(
      column: $state.table.horLength,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get verDepth => $state.composableBuilder(
      column: $state.table.verDepth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get decayClass => $state.composableBuilder(
      column: $state.table.decayClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableFilterComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  $$TreeGenusTableFilterComposer get genus {
    final $$TreeGenusTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.genus,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.genusCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableFilterComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }

  $$TreeGenusTableFilterComposer get species {
    final $$TreeGenusTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.species,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.speciesCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableFilterComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$WoodyDebrisOddTableOrderingComposer
    extends d.OrderingComposer<_$Database, $WoodyDebrisOddTable> {
  $$WoodyDebrisOddTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get pieceNum => $state.composableBuilder(
      column: $state.table.pieceNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get accumOdd => $state.composableBuilder(
      column: $state.table.accumOdd,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get horLength => $state.composableBuilder(
      column: $state.table.horLength,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get verDepth => $state.composableBuilder(
      column: $state.table.verDepth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get decayClass => $state.composableBuilder(
      column: $state.table.decayClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableOrderingComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  $$TreeGenusTableOrderingComposer get genus {
    final $$TreeGenusTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.genus,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.genusCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }

  $$TreeGenusTableOrderingComposer get species {
    final $$TreeGenusTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.species,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.speciesCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$WoodyDebrisRoundTableInsertCompanionBuilder
    = WoodyDebrisRoundCompanion Function({
  d.Value<int> id,
  required int wdHeaderId,
  required int pieceNum,
  required String genus,
  required String species,
  required double diameter,
  d.Value<int?> tiltAngle,
  d.Value<int?> decayClass,
});
typedef $$WoodyDebrisRoundTableUpdateCompanionBuilder
    = WoodyDebrisRoundCompanion Function({
  d.Value<int> id,
  d.Value<int> wdHeaderId,
  d.Value<int> pieceNum,
  d.Value<String> genus,
  d.Value<String> species,
  d.Value<double> diameter,
  d.Value<int?> tiltAngle,
  d.Value<int?> decayClass,
});

class $$WoodyDebrisRoundTableTableManager extends d.RootTableManager<
    _$Database,
    $WoodyDebrisRoundTable,
    WoodyDebrisRoundData,
    $$WoodyDebrisRoundTableFilterComposer,
    $$WoodyDebrisRoundTableOrderingComposer,
    $$WoodyDebrisRoundTableProcessedTableManager,
    $$WoodyDebrisRoundTableInsertCompanionBuilder,
    $$WoodyDebrisRoundTableUpdateCompanionBuilder> {
  $$WoodyDebrisRoundTableTableManager(
      _$Database db, $WoodyDebrisRoundTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$WoodyDebrisRoundTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer: $$WoodyDebrisRoundTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$WoodyDebrisRoundTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> wdHeaderId = const d.Value.absent(),
            d.Value<int> pieceNum = const d.Value.absent(),
            d.Value<String> genus = const d.Value.absent(),
            d.Value<String> species = const d.Value.absent(),
            d.Value<double> diameter = const d.Value.absent(),
            d.Value<int?> tiltAngle = const d.Value.absent(),
            d.Value<int?> decayClass = const d.Value.absent(),
          }) =>
              WoodyDebrisRoundCompanion(
            id: id,
            wdHeaderId: wdHeaderId,
            pieceNum: pieceNum,
            genus: genus,
            species: species,
            diameter: diameter,
            tiltAngle: tiltAngle,
            decayClass: decayClass,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int wdHeaderId,
            required int pieceNum,
            required String genus,
            required String species,
            required double diameter,
            d.Value<int?> tiltAngle = const d.Value.absent(),
            d.Value<int?> decayClass = const d.Value.absent(),
          }) =>
              WoodyDebrisRoundCompanion.insert(
            id: id,
            wdHeaderId: wdHeaderId,
            pieceNum: pieceNum,
            genus: genus,
            species: species,
            diameter: diameter,
            tiltAngle: tiltAngle,
            decayClass: decayClass,
          ),
        ));
}

class $$WoodyDebrisRoundTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $WoodyDebrisRoundTable,
        WoodyDebrisRoundData,
        $$WoodyDebrisRoundTableFilterComposer,
        $$WoodyDebrisRoundTableOrderingComposer,
        $$WoodyDebrisRoundTableProcessedTableManager,
        $$WoodyDebrisRoundTableInsertCompanionBuilder,
        $$WoodyDebrisRoundTableUpdateCompanionBuilder> {
  $$WoodyDebrisRoundTableProcessedTableManager(super.$state);
}

class $$WoodyDebrisRoundTableFilterComposer
    extends d.FilterComposer<_$Database, $WoodyDebrisRoundTable> {
  $$WoodyDebrisRoundTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get pieceNum => $state.composableBuilder(
      column: $state.table.pieceNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get diameter => $state.composableBuilder(
      column: $state.table.diameter,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get tiltAngle => $state.composableBuilder(
      column: $state.table.tiltAngle,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get decayClass => $state.composableBuilder(
      column: $state.table.decayClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableFilterComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  $$TreeGenusTableFilterComposer get genus {
    final $$TreeGenusTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.genus,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.genusCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableFilterComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }

  $$TreeGenusTableFilterComposer get species {
    final $$TreeGenusTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.species,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.speciesCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableFilterComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$WoodyDebrisRoundTableOrderingComposer
    extends d.OrderingComposer<_$Database, $WoodyDebrisRoundTable> {
  $$WoodyDebrisRoundTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get pieceNum => $state.composableBuilder(
      column: $state.table.pieceNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get diameter => $state.composableBuilder(
      column: $state.table.diameter,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get tiltAngle => $state.composableBuilder(
      column: $state.table.tiltAngle,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get decayClass => $state.composableBuilder(
      column: $state.table.decayClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$WoodyDebrisHeaderTableOrderingComposer get wdHeaderId {
    final $$WoodyDebrisHeaderTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.wdHeaderId,
            referencedTable: $state.db.woodyDebrisHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$WoodyDebrisHeaderTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.woodyDebrisHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  $$TreeGenusTableOrderingComposer get genus {
    final $$TreeGenusTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.genus,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.genusCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }

  $$TreeGenusTableOrderingComposer get species {
    final $$TreeGenusTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.species,
        referencedTable: $state.db.treeGenus,
        getReferencedColumn: (t) => t.speciesCode,
        builder: (joinBuilder, parentComposers) =>
            $$TreeGenusTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.treeGenus, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurfaceSubstrateSummaryTableInsertCompanionBuilder
    = SurfaceSubstrateSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<int?> numTransects,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$SurfaceSubstrateSummaryTableUpdateCompanionBuilder
    = SurfaceSubstrateSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<int?> numTransects,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$SurfaceSubstrateSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $SurfaceSubstrateSummaryTable,
    SurfaceSubstrateSummaryData,
    $$SurfaceSubstrateSummaryTableFilterComposer,
    $$SurfaceSubstrateSummaryTableOrderingComposer,
    $$SurfaceSubstrateSummaryTableProcessedTableManager,
    $$SurfaceSubstrateSummaryTableInsertCompanionBuilder,
    $$SurfaceSubstrateSummaryTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateSummaryTableTableManager(
      _$Database db, $SurfaceSubstrateSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SurfaceSubstrateSummaryTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SurfaceSubstrateSummaryTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurfaceSubstrateSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<int?> numTransects = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurfaceSubstrateSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numTransects: numTransects,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<int?> numTransects = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurfaceSubstrateSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numTransects: numTransects,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$SurfaceSubstrateSummaryTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurfaceSubstrateSummaryTable,
        SurfaceSubstrateSummaryData,
        $$SurfaceSubstrateSummaryTableFilterComposer,
        $$SurfaceSubstrateSummaryTableOrderingComposer,
        $$SurfaceSubstrateSummaryTableProcessedTableManager,
        $$SurfaceSubstrateSummaryTableInsertCompanionBuilder,
        $$SurfaceSubstrateSummaryTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateSummaryTableProcessedTableManager(super.$state);
}

class $$SurfaceSubstrateSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $SurfaceSubstrateSummaryTable> {
  $$SurfaceSubstrateSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get numTransects => $state.composableBuilder(
      column: $state.table.numTransects,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter surfaceSubstrateHeaderRefs(
      d.ComposableFilter Function($$SurfaceSubstrateHeaderTableFilterComposer f)
          f) {
    final $$SurfaceSubstrateHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surfaceSubstrateHeader,
            getReferencedColumn: (t) => t.ssId,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateHeader,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }
}

class $$SurfaceSubstrateSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurfaceSubstrateSummaryTable> {
  $$SurfaceSubstrateSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get numTransects => $state.composableBuilder(
      column: $state.table.numTransects,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SurfaceSubstrateHeaderTableInsertCompanionBuilder
    = SurfaceSubstrateHeaderCompanion Function({
  d.Value<int> id,
  required int ssId,
  required int transNum,
  d.Value<double?> nomTransLen,
  d.Value<int?> transAzimuth,
  d.Value<bool> complete,
});
typedef $$SurfaceSubstrateHeaderTableUpdateCompanionBuilder
    = SurfaceSubstrateHeaderCompanion Function({
  d.Value<int> id,
  d.Value<int> ssId,
  d.Value<int> transNum,
  d.Value<double?> nomTransLen,
  d.Value<int?> transAzimuth,
  d.Value<bool> complete,
});

class $$SurfaceSubstrateHeaderTableTableManager extends d.RootTableManager<
    _$Database,
    $SurfaceSubstrateHeaderTable,
    SurfaceSubstrateHeaderData,
    $$SurfaceSubstrateHeaderTableFilterComposer,
    $$SurfaceSubstrateHeaderTableOrderingComposer,
    $$SurfaceSubstrateHeaderTableProcessedTableManager,
    $$SurfaceSubstrateHeaderTableInsertCompanionBuilder,
    $$SurfaceSubstrateHeaderTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateHeaderTableTableManager(
      _$Database db, $SurfaceSubstrateHeaderTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SurfaceSubstrateHeaderTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SurfaceSubstrateHeaderTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurfaceSubstrateHeaderTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> ssId = const d.Value.absent(),
            d.Value<int> transNum = const d.Value.absent(),
            d.Value<double?> nomTransLen = const d.Value.absent(),
            d.Value<int?> transAzimuth = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurfaceSubstrateHeaderCompanion(
            id: id,
            ssId: ssId,
            transNum: transNum,
            nomTransLen: nomTransLen,
            transAzimuth: transAzimuth,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int ssId,
            required int transNum,
            d.Value<double?> nomTransLen = const d.Value.absent(),
            d.Value<int?> transAzimuth = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SurfaceSubstrateHeaderCompanion.insert(
            id: id,
            ssId: ssId,
            transNum: transNum,
            nomTransLen: nomTransLen,
            transAzimuth: transAzimuth,
            complete: complete,
          ),
        ));
}

class $$SurfaceSubstrateHeaderTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurfaceSubstrateHeaderTable,
        SurfaceSubstrateHeaderData,
        $$SurfaceSubstrateHeaderTableFilterComposer,
        $$SurfaceSubstrateHeaderTableOrderingComposer,
        $$SurfaceSubstrateHeaderTableProcessedTableManager,
        $$SurfaceSubstrateHeaderTableInsertCompanionBuilder,
        $$SurfaceSubstrateHeaderTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateHeaderTableProcessedTableManager(super.$state);
}

class $$SurfaceSubstrateHeaderTableFilterComposer
    extends d.FilterComposer<_$Database, $SurfaceSubstrateHeaderTable> {
  $$SurfaceSubstrateHeaderTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get transNum => $state.composableBuilder(
      column: $state.table.transNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomTransLen => $state.composableBuilder(
      column: $state.table.nomTransLen,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get transAzimuth => $state.composableBuilder(
      column: $state.table.transAzimuth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurfaceSubstrateSummaryTableFilterComposer get ssId {
    final $$SurfaceSubstrateSummaryTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.ssId,
            referencedTable: $state.db.surfaceSubstrateSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateSummaryTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateSummary,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }

  d.ComposableFilter surfaceSubstrateTallyRefs(
      d.ComposableFilter Function($$SurfaceSubstrateTallyTableFilterComposer f)
          f) {
    final $$SurfaceSubstrateTallyTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.surfaceSubstrateTally,
            getReferencedColumn: (t) => t.ssHeaderId,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateTallyTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateTally,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }
}

class $$SurfaceSubstrateHeaderTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurfaceSubstrateHeaderTable> {
  $$SurfaceSubstrateHeaderTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get transNum => $state.composableBuilder(
      column: $state.table.transNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomTransLen => $state.composableBuilder(
      column: $state.table.nomTransLen,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get transAzimuth => $state.composableBuilder(
      column: $state.table.transAzimuth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurfaceSubstrateSummaryTableOrderingComposer get ssId {
    final $$SurfaceSubstrateSummaryTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.ssId,
            referencedTable: $state.db.surfaceSubstrateSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateSummaryTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateSummary,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

typedef $$SurfaceSubstrateTallyTableInsertCompanionBuilder
    = SurfaceSubstrateTallyCompanion Function({
  d.Value<int> id,
  required int ssHeaderId,
  required int stationNum,
  required String substrateType,
  required int depth,
  required int depthLimit,
});
typedef $$SurfaceSubstrateTallyTableUpdateCompanionBuilder
    = SurfaceSubstrateTallyCompanion Function({
  d.Value<int> id,
  d.Value<int> ssHeaderId,
  d.Value<int> stationNum,
  d.Value<String> substrateType,
  d.Value<int> depth,
  d.Value<int> depthLimit,
});

class $$SurfaceSubstrateTallyTableTableManager extends d.RootTableManager<
    _$Database,
    $SurfaceSubstrateTallyTable,
    SurfaceSubstrateTallyData,
    $$SurfaceSubstrateTallyTableFilterComposer,
    $$SurfaceSubstrateTallyTableOrderingComposer,
    $$SurfaceSubstrateTallyTableProcessedTableManager,
    $$SurfaceSubstrateTallyTableInsertCompanionBuilder,
    $$SurfaceSubstrateTallyTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateTallyTableTableManager(
      _$Database db, $SurfaceSubstrateTallyTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SurfaceSubstrateTallyTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SurfaceSubstrateTallyTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SurfaceSubstrateTallyTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> ssHeaderId = const d.Value.absent(),
            d.Value<int> stationNum = const d.Value.absent(),
            d.Value<String> substrateType = const d.Value.absent(),
            d.Value<int> depth = const d.Value.absent(),
            d.Value<int> depthLimit = const d.Value.absent(),
          }) =>
              SurfaceSubstrateTallyCompanion(
            id: id,
            ssHeaderId: ssHeaderId,
            stationNum: stationNum,
            substrateType: substrateType,
            depth: depth,
            depthLimit: depthLimit,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int ssHeaderId,
            required int stationNum,
            required String substrateType,
            required int depth,
            required int depthLimit,
          }) =>
              SurfaceSubstrateTallyCompanion.insert(
            id: id,
            ssHeaderId: ssHeaderId,
            stationNum: stationNum,
            substrateType: substrateType,
            depth: depth,
            depthLimit: depthLimit,
          ),
        ));
}

class $$SurfaceSubstrateTallyTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SurfaceSubstrateTallyTable,
        SurfaceSubstrateTallyData,
        $$SurfaceSubstrateTallyTableFilterComposer,
        $$SurfaceSubstrateTallyTableOrderingComposer,
        $$SurfaceSubstrateTallyTableProcessedTableManager,
        $$SurfaceSubstrateTallyTableInsertCompanionBuilder,
        $$SurfaceSubstrateTallyTableUpdateCompanionBuilder> {
  $$SurfaceSubstrateTallyTableProcessedTableManager(super.$state);
}

class $$SurfaceSubstrateTallyTableFilterComposer
    extends d.FilterComposer<_$Database, $SurfaceSubstrateTallyTable> {
  $$SurfaceSubstrateTallyTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get stationNum => $state.composableBuilder(
      column: $state.table.stationNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get substrateType => $state.composableBuilder(
      column: $state.table.substrateType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get depth => $state.composableBuilder(
      column: $state.table.depth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get depthLimit => $state.composableBuilder(
      column: $state.table.depthLimit,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurfaceSubstrateHeaderTableFilterComposer get ssHeaderId {
    final $$SurfaceSubstrateHeaderTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.ssHeaderId,
            referencedTable: $state.db.surfaceSubstrateHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateHeaderTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

class $$SurfaceSubstrateTallyTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SurfaceSubstrateTallyTable> {
  $$SurfaceSubstrateTallyTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get stationNum => $state.composableBuilder(
      column: $state.table.stationNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get substrateType => $state.composableBuilder(
      column: $state.table.substrateType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get depth => $state.composableBuilder(
      column: $state.table.depth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get depthLimit => $state.composableBuilder(
      column: $state.table.depthLimit,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurfaceSubstrateHeaderTableOrderingComposer get ssHeaderId {
    final $$SurfaceSubstrateHeaderTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.ssHeaderId,
            referencedTable: $state.db.surfaceSubstrateHeader,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurfaceSubstrateHeaderTableOrderingComposer(d.ComposerState(
                    $state.db,
                    $state.db.surfaceSubstrateHeader,
                    joinBuilder,
                    parentComposers)));
    return composer;
  }
}

typedef $$EcpSummaryTableInsertCompanionBuilder = EcpSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<int?> numEcps,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$EcpSummaryTableUpdateCompanionBuilder = EcpSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<int?> numEcps,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$EcpSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpSummaryTable,
    EcpSummaryData,
    $$EcpSummaryTableFilterComposer,
    $$EcpSummaryTableOrderingComposer,
    $$EcpSummaryTableProcessedTableManager,
    $$EcpSummaryTableInsertCompanionBuilder,
    $$EcpSummaryTableUpdateCompanionBuilder> {
  $$EcpSummaryTableTableManager(_$Database db, $EcpSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<int?> numEcps = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              EcpSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numEcps: numEcps,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<int?> numEcps = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              EcpSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            numEcps: numEcps,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$EcpSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpSummaryTable,
    EcpSummaryData,
    $$EcpSummaryTableFilterComposer,
    $$EcpSummaryTableOrderingComposer,
    $$EcpSummaryTableProcessedTableManager,
    $$EcpSummaryTableInsertCompanionBuilder,
    $$EcpSummaryTableUpdateCompanionBuilder> {
  $$EcpSummaryTableProcessedTableManager(super.$state);
}

class $$EcpSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpSummaryTable> {
  $$EcpSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get numEcps => $state.composableBuilder(
      column: $state.table.numEcps,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter ecpHeaderRefs(
      d.ComposableFilter Function($$EcpHeaderTableFilterComposer f) f) {
    final $$EcpHeaderTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ecpHeader,
        getReferencedColumn: (t) => t.ecpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$EcpHeaderTableFilterComposer(d.ComposerState(
                $state.db, $state.db.ecpHeader, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$EcpSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpSummaryTable> {
  $$EcpSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get numEcps => $state.composableBuilder(
      column: $state.table.numEcps,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$EcpHeaderTableInsertCompanionBuilder = EcpHeaderCompanion Function({
  d.Value<int> id,
  required int ecpSummaryId,
  d.Value<int?> ecpNum,
  d.Value<bool> complete,
  d.Value<String?> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
});
typedef $$EcpHeaderTableUpdateCompanionBuilder = EcpHeaderCompanion Function({
  d.Value<int> id,
  d.Value<int> ecpSummaryId,
  d.Value<int?> ecpNum,
  d.Value<bool> complete,
  d.Value<String?> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
});

class $$EcpHeaderTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpHeaderTable,
    EcpHeaderData,
    $$EcpHeaderTableFilterComposer,
    $$EcpHeaderTableOrderingComposer,
    $$EcpHeaderTableProcessedTableManager,
    $$EcpHeaderTableInsertCompanionBuilder,
    $$EcpHeaderTableUpdateCompanionBuilder> {
  $$EcpHeaderTableTableManager(_$Database db, $EcpHeaderTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpHeaderTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpHeaderTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpHeaderTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> ecpSummaryId = const d.Value.absent(),
            d.Value<int?> ecpNum = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
            d.Value<String?> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
          }) =>
              EcpHeaderCompanion(
            id: id,
            ecpSummaryId: ecpSummaryId,
            ecpNum: ecpNum,
            complete: complete,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int ecpSummaryId,
            d.Value<int?> ecpNum = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
            d.Value<String?> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
          }) =>
              EcpHeaderCompanion.insert(
            id: id,
            ecpSummaryId: ecpSummaryId,
            ecpNum: ecpNum,
            complete: complete,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
          ),
        ));
}

class $$EcpHeaderTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpHeaderTable,
    EcpHeaderData,
    $$EcpHeaderTableFilterComposer,
    $$EcpHeaderTableOrderingComposer,
    $$EcpHeaderTableProcessedTableManager,
    $$EcpHeaderTableInsertCompanionBuilder,
    $$EcpHeaderTableUpdateCompanionBuilder> {
  $$EcpHeaderTableProcessedTableManager(super.$state);
}

class $$EcpHeaderTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpHeaderTable> {
  $$EcpHeaderTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get ecpNum => $state.composableBuilder(
      column: $state.table.ecpNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$EcpSummaryTableFilterComposer get ecpSummaryId {
    final $$EcpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ecpSummaryId,
        referencedTable: $state.db.ecpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$EcpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ecpSummary, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter ecpSpeciesRefs(
      d.ComposableFilter Function($$EcpSpeciesTableFilterComposer f) f) {
    final $$EcpSpeciesTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ecpSpecies,
        getReferencedColumn: (t) => t.ecpHeaderId,
        builder: (joinBuilder, parentComposers) =>
            $$EcpSpeciesTableFilterComposer(d.ComposerState($state.db,
                $state.db.ecpSpecies, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$EcpHeaderTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpHeaderTable> {
  $$EcpHeaderTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get ecpNum => $state.composableBuilder(
      column: $state.table.ecpNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$EcpSummaryTableOrderingComposer get ecpSummaryId {
    final $$EcpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ecpSummaryId,
        referencedTable: $state.db.ecpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$EcpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ecpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$EcpSpeciesTableInsertCompanionBuilder = EcpSpeciesCompanion Function({
  d.Value<int> id,
  required int ecpHeaderId,
  required int speciesNum,
  required String layerId,
  required String genus,
  required String species,
  d.Value<String?> variety,
  required double speciesPct,
  d.Value<int?> commentId,
});
typedef $$EcpSpeciesTableUpdateCompanionBuilder = EcpSpeciesCompanion Function({
  d.Value<int> id,
  d.Value<int> ecpHeaderId,
  d.Value<int> speciesNum,
  d.Value<String> layerId,
  d.Value<String> genus,
  d.Value<String> species,
  d.Value<String?> variety,
  d.Value<double> speciesPct,
  d.Value<int?> commentId,
});

class $$EcpSpeciesTableTableManager extends d.RootTableManager<
    _$Database,
    $EcpSpeciesTable,
    EcpSpeciesData,
    $$EcpSpeciesTableFilterComposer,
    $$EcpSpeciesTableOrderingComposer,
    $$EcpSpeciesTableProcessedTableManager,
    $$EcpSpeciesTableInsertCompanionBuilder,
    $$EcpSpeciesTableUpdateCompanionBuilder> {
  $$EcpSpeciesTableTableManager(_$Database db, $EcpSpeciesTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$EcpSpeciesTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$EcpSpeciesTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$EcpSpeciesTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> ecpHeaderId = const d.Value.absent(),
            d.Value<int> speciesNum = const d.Value.absent(),
            d.Value<String> layerId = const d.Value.absent(),
            d.Value<String> genus = const d.Value.absent(),
            d.Value<String> species = const d.Value.absent(),
            d.Value<String?> variety = const d.Value.absent(),
            d.Value<double> speciesPct = const d.Value.absent(),
            d.Value<int?> commentId = const d.Value.absent(),
          }) =>
              EcpSpeciesCompanion(
            id: id,
            ecpHeaderId: ecpHeaderId,
            speciesNum: speciesNum,
            layerId: layerId,
            genus: genus,
            species: species,
            variety: variety,
            speciesPct: speciesPct,
            commentId: commentId,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int ecpHeaderId,
            required int speciesNum,
            required String layerId,
            required String genus,
            required String species,
            d.Value<String?> variety = const d.Value.absent(),
            required double speciesPct,
            d.Value<int?> commentId = const d.Value.absent(),
          }) =>
              EcpSpeciesCompanion.insert(
            id: id,
            ecpHeaderId: ecpHeaderId,
            speciesNum: speciesNum,
            layerId: layerId,
            genus: genus,
            species: species,
            variety: variety,
            speciesPct: speciesPct,
            commentId: commentId,
          ),
        ));
}

class $$EcpSpeciesTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $EcpSpeciesTable,
    EcpSpeciesData,
    $$EcpSpeciesTableFilterComposer,
    $$EcpSpeciesTableOrderingComposer,
    $$EcpSpeciesTableProcessedTableManager,
    $$EcpSpeciesTableInsertCompanionBuilder,
    $$EcpSpeciesTableUpdateCompanionBuilder> {
  $$EcpSpeciesTableProcessedTableManager(super.$state);
}

class $$EcpSpeciesTableFilterComposer
    extends d.FilterComposer<_$Database, $EcpSpeciesTable> {
  $$EcpSpeciesTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get speciesNum => $state.composableBuilder(
      column: $state.table.speciesNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get layerId => $state.composableBuilder(
      column: $state.table.layerId,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get speciesPct => $state.composableBuilder(
      column: $state.table.speciesPct,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$EcpHeaderTableFilterComposer get ecpHeaderId {
    final $$EcpHeaderTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ecpHeaderId,
        referencedTable: $state.db.ecpHeader,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$EcpHeaderTableFilterComposer(d.ComposerState(
                $state.db, $state.db.ecpHeader, joinBuilder, parentComposers)));
    return composer;
  }

  $$MetaCommentTableFilterComposer get commentId {
    final $$MetaCommentTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.commentId,
        referencedTable: $state.db.metaComment,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$MetaCommentTableFilterComposer(d.ComposerState($state.db,
                $state.db.metaComment, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$EcpSpeciesTableOrderingComposer
    extends d.OrderingComposer<_$Database, $EcpSpeciesTable> {
  $$EcpSpeciesTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get speciesNum => $state.composableBuilder(
      column: $state.table.speciesNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get layerId => $state.composableBuilder(
      column: $state.table.layerId,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get speciesPct => $state.composableBuilder(
      column: $state.table.speciesPct,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$EcpHeaderTableOrderingComposer get ecpHeaderId {
    final $$EcpHeaderTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ecpHeaderId,
        referencedTable: $state.db.ecpHeader,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$EcpHeaderTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.ecpHeader, joinBuilder, parentComposers)));
    return composer;
  }

  $$MetaCommentTableOrderingComposer get commentId {
    final $$MetaCommentTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.commentId,
        referencedTable: $state.db.metaComment,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$MetaCommentTableOrderingComposer(d.ComposerState($state.db,
                $state.db.metaComment, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SoilPitSummaryTableInsertCompanionBuilder = SoilPitSummaryCompanion
    Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$SoilPitSummaryTableUpdateCompanionBuilder = SoilPitSummaryCompanion
    Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$SoilPitSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitSummaryTable,
    SoilPitSummaryData,
    $$SoilPitSummaryTableFilterComposer,
    $$SoilPitSummaryTableOrderingComposer,
    $$SoilPitSummaryTableProcessedTableManager,
    $$SoilPitSummaryTableInsertCompanionBuilder,
    $$SoilPitSummaryTableUpdateCompanionBuilder> {
  $$SoilPitSummaryTableTableManager(_$Database db, $SoilPitSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilPitSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilPitSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SoilPitSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              SoilPitSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$SoilPitSummaryTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilPitSummaryTable,
        SoilPitSummaryData,
        $$SoilPitSummaryTableFilterComposer,
        $$SoilPitSummaryTableOrderingComposer,
        $$SoilPitSummaryTableProcessedTableManager,
        $$SoilPitSummaryTableInsertCompanionBuilder,
        $$SoilPitSummaryTableUpdateCompanionBuilder> {
  $$SoilPitSummaryTableProcessedTableManager(super.$state);
}

class $$SoilPitSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitSummaryTable> {
  $$SoilPitSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter soilSiteInfoRefs(
      d.ComposableFilter Function($$SoilSiteInfoTableFilterComposer f) f) {
    final $$SoilSiteInfoTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.soilSiteInfo,
        getReferencedColumn: (t) => t.soilPitSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$SoilSiteInfoTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilSiteInfo, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter soilPitFeatureRefs(
      d.ComposableFilter Function($$SoilPitFeatureTableFilterComposer f) f) {
    final $$SoilPitFeatureTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.soilPitFeature,
        getReferencedColumn: (t) => t.soilPitSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$SoilPitFeatureTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilPitFeature, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter soilPitHorizonDescriptionRefs(
      d.ComposableFilter Function(
              $$SoilPitHorizonDescriptionTableFilterComposer f)
          f) {
    final $$SoilPitHorizonDescriptionTableFilterComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $state.db.soilPitHorizonDescription,
            getReferencedColumn: (t) => t.soilPitSummaryId,
            builder: (joinBuilder, parentComposers) =>
                $$SoilPitHorizonDescriptionTableFilterComposer(d.ComposerState(
                    $state.db,
                    $state.db.soilPitHorizonDescription,
                    joinBuilder,
                    parentComposers)));
    return f(composer);
  }
}

class $$SoilPitSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitSummaryTable> {
  $$SoilPitSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SoilSiteInfoTableInsertCompanionBuilder = SoilSiteInfoCompanion
    Function({
  d.Value<int> id,
  required int soilPitSummaryId,
  required String soilClassOrder,
  required String soilClassGreatGroup,
  required String soilClassSubGroup,
  required String soilClass,
  required double profileDepth,
  required int drainage,
  required int moisture,
  required String deposition,
  required String humusForm,
});
typedef $$SoilSiteInfoTableUpdateCompanionBuilder = SoilSiteInfoCompanion
    Function({
  d.Value<int> id,
  d.Value<int> soilPitSummaryId,
  d.Value<String> soilClassOrder,
  d.Value<String> soilClassGreatGroup,
  d.Value<String> soilClassSubGroup,
  d.Value<String> soilClass,
  d.Value<double> profileDepth,
  d.Value<int> drainage,
  d.Value<int> moisture,
  d.Value<String> deposition,
  d.Value<String> humusForm,
});

class $$SoilSiteInfoTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilSiteInfoTable,
    SoilSiteInfoData,
    $$SoilSiteInfoTableFilterComposer,
    $$SoilSiteInfoTableOrderingComposer,
    $$SoilSiteInfoTableProcessedTableManager,
    $$SoilSiteInfoTableInsertCompanionBuilder,
    $$SoilSiteInfoTableUpdateCompanionBuilder> {
  $$SoilSiteInfoTableTableManager(_$Database db, $SoilSiteInfoTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilSiteInfoTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilSiteInfoTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilSiteInfoTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> soilPitSummaryId = const d.Value.absent(),
            d.Value<String> soilClassOrder = const d.Value.absent(),
            d.Value<String> soilClassGreatGroup = const d.Value.absent(),
            d.Value<String> soilClassSubGroup = const d.Value.absent(),
            d.Value<String> soilClass = const d.Value.absent(),
            d.Value<double> profileDepth = const d.Value.absent(),
            d.Value<int> drainage = const d.Value.absent(),
            d.Value<int> moisture = const d.Value.absent(),
            d.Value<String> deposition = const d.Value.absent(),
            d.Value<String> humusForm = const d.Value.absent(),
          }) =>
              SoilSiteInfoCompanion(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilClassOrder: soilClassOrder,
            soilClassGreatGroup: soilClassGreatGroup,
            soilClassSubGroup: soilClassSubGroup,
            soilClass: soilClass,
            profileDepth: profileDepth,
            drainage: drainage,
            moisture: moisture,
            deposition: deposition,
            humusForm: humusForm,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int soilPitSummaryId,
            required String soilClassOrder,
            required String soilClassGreatGroup,
            required String soilClassSubGroup,
            required String soilClass,
            required double profileDepth,
            required int drainage,
            required int moisture,
            required String deposition,
            required String humusForm,
          }) =>
              SoilSiteInfoCompanion.insert(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilClassOrder: soilClassOrder,
            soilClassGreatGroup: soilClassGreatGroup,
            soilClassSubGroup: soilClassSubGroup,
            soilClass: soilClass,
            profileDepth: profileDepth,
            drainage: drainage,
            moisture: moisture,
            deposition: deposition,
            humusForm: humusForm,
          ),
        ));
}

class $$SoilSiteInfoTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $SoilSiteInfoTable,
    SoilSiteInfoData,
    $$SoilSiteInfoTableFilterComposer,
    $$SoilSiteInfoTableOrderingComposer,
    $$SoilSiteInfoTableProcessedTableManager,
    $$SoilSiteInfoTableInsertCompanionBuilder,
    $$SoilSiteInfoTableUpdateCompanionBuilder> {
  $$SoilSiteInfoTableProcessedTableManager(super.$state);
}

class $$SoilSiteInfoTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilSiteInfoTable> {
  $$SoilSiteInfoTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilClassOrder => $state.composableBuilder(
      column: $state.table.soilClassOrder,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilClassGreatGroup => $state.composableBuilder(
      column: $state.table.soilClassGreatGroup,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilClassSubGroup => $state.composableBuilder(
      column: $state.table.soilClassSubGroup,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilClass => $state.composableBuilder(
      column: $state.table.soilClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get profileDepth => $state.composableBuilder(
      column: $state.table.profileDepth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get drainage => $state.composableBuilder(
      column: $state.table.drainage,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get moisture => $state.composableBuilder(
      column: $state.table.moisture,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get deposition => $state.composableBuilder(
      column: $state.table.deposition,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get humusForm => $state.composableBuilder(
      column: $state.table.humusForm,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableFilterComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.soilPitSummaryId,
        referencedTable: $state.db.soilPitSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SoilPitSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SoilSiteInfoTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilSiteInfoTable> {
  $$SoilSiteInfoTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilClassOrder => $state.composableBuilder(
      column: $state.table.soilClassOrder,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilClassGreatGroup => $state.composableBuilder(
      column: $state.table.soilClassGreatGroup,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilClassSubGroup => $state.composableBuilder(
      column: $state.table.soilClassSubGroup,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilClass => $state.composableBuilder(
      column: $state.table.soilClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get profileDepth => $state.composableBuilder(
      column: $state.table.profileDepth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get drainage => $state.composableBuilder(
      column: $state.table.drainage,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get moisture => $state.composableBuilder(
      column: $state.table.moisture,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get deposition => $state.composableBuilder(
      column: $state.table.deposition,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get humusForm => $state.composableBuilder(
      column: $state.table.humusForm,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableOrderingComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.soilPitSummaryId,
            referencedTable: $state.db.soilPitSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SoilPitSummaryTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SoilPitFeatureTableInsertCompanionBuilder = SoilPitFeatureCompanion
    Function({
  d.Value<int> id,
  required int soilPitSummaryId,
  required String soilPitCode,
  required String soilFeature,
  required int depthFeature,
});
typedef $$SoilPitFeatureTableUpdateCompanionBuilder = SoilPitFeatureCompanion
    Function({
  d.Value<int> id,
  d.Value<int> soilPitSummaryId,
  d.Value<String> soilPitCode,
  d.Value<String> soilFeature,
  d.Value<int> depthFeature,
});

class $$SoilPitFeatureTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitFeatureTable,
    SoilPitFeatureData,
    $$SoilPitFeatureTableFilterComposer,
    $$SoilPitFeatureTableOrderingComposer,
    $$SoilPitFeatureTableProcessedTableManager,
    $$SoilPitFeatureTableInsertCompanionBuilder,
    $$SoilPitFeatureTableUpdateCompanionBuilder> {
  $$SoilPitFeatureTableTableManager(_$Database db, $SoilPitFeatureTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$SoilPitFeatureTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$SoilPitFeatureTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitFeatureTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> soilPitSummaryId = const d.Value.absent(),
            d.Value<String> soilPitCode = const d.Value.absent(),
            d.Value<String> soilFeature = const d.Value.absent(),
            d.Value<int> depthFeature = const d.Value.absent(),
          }) =>
              SoilPitFeatureCompanion(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilPitCode: soilPitCode,
            soilFeature: soilFeature,
            depthFeature: depthFeature,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int soilPitSummaryId,
            required String soilPitCode,
            required String soilFeature,
            required int depthFeature,
          }) =>
              SoilPitFeatureCompanion.insert(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilPitCode: soilPitCode,
            soilFeature: soilFeature,
            depthFeature: depthFeature,
          ),
        ));
}

class $$SoilPitFeatureTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilPitFeatureTable,
        SoilPitFeatureData,
        $$SoilPitFeatureTableFilterComposer,
        $$SoilPitFeatureTableOrderingComposer,
        $$SoilPitFeatureTableProcessedTableManager,
        $$SoilPitFeatureTableInsertCompanionBuilder,
        $$SoilPitFeatureTableUpdateCompanionBuilder> {
  $$SoilPitFeatureTableProcessedTableManager(super.$state);
}

class $$SoilPitFeatureTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitFeatureTable> {
  $$SoilPitFeatureTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilPitCode => $state.composableBuilder(
      column: $state.table.soilPitCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilFeature => $state.composableBuilder(
      column: $state.table.soilFeature,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get depthFeature => $state.composableBuilder(
      column: $state.table.depthFeature,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableFilterComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.soilPitSummaryId,
        referencedTable: $state.db.soilPitSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SoilPitSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SoilPitFeatureTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitFeatureTable> {
  $$SoilPitFeatureTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilPitCode => $state.composableBuilder(
      column: $state.table.soilPitCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilFeature => $state.composableBuilder(
      column: $state.table.soilFeature,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get depthFeature => $state.composableBuilder(
      column: $state.table.depthFeature,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableOrderingComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.soilPitSummaryId,
            referencedTable: $state.db.soilPitSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SoilPitSummaryTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$SoilPitHorizonDescriptionTableInsertCompanionBuilder
    = SoilPitHorizonDescriptionCompanion Function({
  d.Value<int> id,
  required int soilPitSummaryId,
  required String soilPitCodeField,
  required int horizonNum,
  required String horizon,
  required double horizonUpper,
  required double thickness,
  required String color,
  required String mineralType,
  required String texture,
  required int cfGrav,
  required int cfCobb,
  required int cfStone,
});
typedef $$SoilPitHorizonDescriptionTableUpdateCompanionBuilder
    = SoilPitHorizonDescriptionCompanion Function({
  d.Value<int> id,
  d.Value<int> soilPitSummaryId,
  d.Value<String> soilPitCodeField,
  d.Value<int> horizonNum,
  d.Value<String> horizon,
  d.Value<double> horizonUpper,
  d.Value<double> thickness,
  d.Value<String> color,
  d.Value<String> mineralType,
  d.Value<String> texture,
  d.Value<int> cfGrav,
  d.Value<int> cfCobb,
  d.Value<int> cfStone,
});

class $$SoilPitHorizonDescriptionTableTableManager extends d.RootTableManager<
    _$Database,
    $SoilPitHorizonDescriptionTable,
    SoilPitHorizonDescriptionData,
    $$SoilPitHorizonDescriptionTableFilterComposer,
    $$SoilPitHorizonDescriptionTableOrderingComposer,
    $$SoilPitHorizonDescriptionTableProcessedTableManager,
    $$SoilPitHorizonDescriptionTableInsertCompanionBuilder,
    $$SoilPitHorizonDescriptionTableUpdateCompanionBuilder> {
  $$SoilPitHorizonDescriptionTableTableManager(
      _$Database db, $SoilPitHorizonDescriptionTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer: $$SoilPitHorizonDescriptionTableFilterComposer(
              d.ComposerState(db, table)),
          orderingComposer: $$SoilPitHorizonDescriptionTableOrderingComposer(
              d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$SoilPitHorizonDescriptionTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> soilPitSummaryId = const d.Value.absent(),
            d.Value<String> soilPitCodeField = const d.Value.absent(),
            d.Value<int> horizonNum = const d.Value.absent(),
            d.Value<String> horizon = const d.Value.absent(),
            d.Value<double> horizonUpper = const d.Value.absent(),
            d.Value<double> thickness = const d.Value.absent(),
            d.Value<String> color = const d.Value.absent(),
            d.Value<String> mineralType = const d.Value.absent(),
            d.Value<String> texture = const d.Value.absent(),
            d.Value<int> cfGrav = const d.Value.absent(),
            d.Value<int> cfCobb = const d.Value.absent(),
            d.Value<int> cfStone = const d.Value.absent(),
          }) =>
              SoilPitHorizonDescriptionCompanion(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilPitCodeField: soilPitCodeField,
            horizonNum: horizonNum,
            horizon: horizon,
            horizonUpper: horizonUpper,
            thickness: thickness,
            color: color,
            mineralType: mineralType,
            texture: texture,
            cfGrav: cfGrav,
            cfCobb: cfCobb,
            cfStone: cfStone,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int soilPitSummaryId,
            required String soilPitCodeField,
            required int horizonNum,
            required String horizon,
            required double horizonUpper,
            required double thickness,
            required String color,
            required String mineralType,
            required String texture,
            required int cfGrav,
            required int cfCobb,
            required int cfStone,
          }) =>
              SoilPitHorizonDescriptionCompanion.insert(
            id: id,
            soilPitSummaryId: soilPitSummaryId,
            soilPitCodeField: soilPitCodeField,
            horizonNum: horizonNum,
            horizon: horizon,
            horizonUpper: horizonUpper,
            thickness: thickness,
            color: color,
            mineralType: mineralType,
            texture: texture,
            cfGrav: cfGrav,
            cfCobb: cfCobb,
            cfStone: cfStone,
          ),
        ));
}

class $$SoilPitHorizonDescriptionTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $SoilPitHorizonDescriptionTable,
        SoilPitHorizonDescriptionData,
        $$SoilPitHorizonDescriptionTableFilterComposer,
        $$SoilPitHorizonDescriptionTableOrderingComposer,
        $$SoilPitHorizonDescriptionTableProcessedTableManager,
        $$SoilPitHorizonDescriptionTableInsertCompanionBuilder,
        $$SoilPitHorizonDescriptionTableUpdateCompanionBuilder> {
  $$SoilPitHorizonDescriptionTableProcessedTableManager(super.$state);
}

class $$SoilPitHorizonDescriptionTableFilterComposer
    extends d.FilterComposer<_$Database, $SoilPitHorizonDescriptionTable> {
  $$SoilPitHorizonDescriptionTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get soilPitCodeField => $state.composableBuilder(
      column: $state.table.soilPitCodeField,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get horizonNum => $state.composableBuilder(
      column: $state.table.horizonNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get horizon => $state.composableBuilder(
      column: $state.table.horizon,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get horizonUpper => $state.composableBuilder(
      column: $state.table.horizonUpper,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get thickness => $state.composableBuilder(
      column: $state.table.thickness,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get color => $state.composableBuilder(
      column: $state.table.color,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get mineralType => $state.composableBuilder(
      column: $state.table.mineralType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get texture => $state.composableBuilder(
      column: $state.table.texture,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get cfGrav => $state.composableBuilder(
      column: $state.table.cfGrav,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get cfCobb => $state.composableBuilder(
      column: $state.table.cfCobb,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get cfStone => $state.composableBuilder(
      column: $state.table.cfStone,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableFilterComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.soilPitSummaryId,
        referencedTable: $state.db.soilPitSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SoilPitSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$SoilPitHorizonDescriptionTableOrderingComposer
    extends d.OrderingComposer<_$Database, $SoilPitHorizonDescriptionTable> {
  $$SoilPitHorizonDescriptionTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get soilPitCodeField => $state.composableBuilder(
      column: $state.table.soilPitCodeField,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get horizonNum => $state.composableBuilder(
      column: $state.table.horizonNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get horizon => $state.composableBuilder(
      column: $state.table.horizon,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get horizonUpper => $state.composableBuilder(
      column: $state.table.horizonUpper,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get thickness => $state.composableBuilder(
      column: $state.table.thickness,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get color => $state.composableBuilder(
      column: $state.table.color,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get mineralType => $state.composableBuilder(
      column: $state.table.mineralType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get texture => $state.composableBuilder(
      column: $state.table.texture,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get cfGrav => $state.composableBuilder(
      column: $state.table.cfGrav,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get cfCobb => $state.composableBuilder(
      column: $state.table.cfCobb,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get cfStone => $state.composableBuilder(
      column: $state.table.cfStone,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SoilPitSummaryTableOrderingComposer get soilPitSummaryId {
    final $$SoilPitSummaryTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.soilPitSummaryId,
            referencedTable: $state.db.soilPitSummary,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SoilPitSummaryTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.soilPitSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpSummaryTableInsertCompanionBuilder = LtpSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<String?> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$LtpSummaryTableUpdateCompanionBuilder = LtpSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<String?> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$LtpSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpSummaryTable,
    LtpSummaryData,
    $$LtpSummaryTableFilterComposer,
    $$LtpSummaryTableOrderingComposer,
    $$LtpSummaryTableProcessedTableManager,
    $$LtpSummaryTableInsertCompanionBuilder,
    $$LtpSummaryTableUpdateCompanionBuilder> {
  $$LtpSummaryTableTableManager(_$Database db, $LtpSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<String?> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              LtpSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<String?> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              LtpSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$LtpSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpSummaryTable,
    LtpSummaryData,
    $$LtpSummaryTableFilterComposer,
    $$LtpSummaryTableOrderingComposer,
    $$LtpSummaryTableProcessedTableManager,
    $$LtpSummaryTableInsertCompanionBuilder,
    $$LtpSummaryTableUpdateCompanionBuilder> {
  $$LtpSummaryTableProcessedTableManager(super.$state);
}

class $$LtpSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpSummaryTable> {
  $$LtpSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter ltpTreeRefs(
      d.ComposableFilter Function($$LtpTreeTableFilterComposer f) f) {
    final $$LtpTreeTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpTree,
        getReferencedColumn: (t) => t.lptSummaryId,
        builder: (joinBuilder, parentComposers) => $$LtpTreeTableFilterComposer(
            d.ComposerState(
                $state.db, $state.db.ltpTree, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ltpTreeDamageRefs(
      d.ComposableFilter Function($$LtpTreeDamageTableFilterComposer f) f) {
    final $$LtpTreeDamageTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpTreeDamage,
        getReferencedColumn: (t) => t.lptSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$LtpTreeDamageTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpTreeDamage, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ltpTreeRemovedRefs(
      d.ComposableFilter Function($$LtpTreeRemovedTableFilterComposer f) f) {
    final $$LtpTreeRemovedTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpTreeRemoved,
        getReferencedColumn: (t) => t.lptSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$LtpTreeRemovedTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpTreeRemoved, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ltpTreeAgeRefs(
      d.ComposableFilter Function($$LtpTreeAgeTableFilterComposer f) f) {
    final $$LtpTreeAgeTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpTreeAge,
        getReferencedColumn: (t) => t.lptSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$LtpTreeAgeTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpTreeAge, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter ltpTreeRenamedRefs(
      d.ComposableFilter Function($$LtpTreeRenamedTableFilterComposer f) f) {
    final $$LtpTreeRenamedTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.ltpTreeRenamed,
        getReferencedColumn: (t) => t.lptSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$LtpTreeRenamedTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpTreeRenamed, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$LtpSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpSummaryTable> {
  $$LtpSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpTreeTableInsertCompanionBuilder = LtpTreeCompanion Function({
  d.Value<int> id,
  required int lptSummaryId,
  required int sector,
  required int treeNum,
  required String origPlotArea,
  required String lgTreeGenus,
  required String lgTreeSpecies,
  required String lgTreeVariety,
  required String lgTreeStatus,
  required double dbh,
  required String measEstDbh,
  required double height,
  required String measEstHeight,
  required String crownClass,
  required double crownBase,
  required double crownTop,
  required String stemCond,
  required int crownCond,
  required int barkRet,
  required int woodCond,
  required int azimuth,
  required double distance,
  required int renumbered,
});
typedef $$LtpTreeTableUpdateCompanionBuilder = LtpTreeCompanion Function({
  d.Value<int> id,
  d.Value<int> lptSummaryId,
  d.Value<int> sector,
  d.Value<int> treeNum,
  d.Value<String> origPlotArea,
  d.Value<String> lgTreeGenus,
  d.Value<String> lgTreeSpecies,
  d.Value<String> lgTreeVariety,
  d.Value<String> lgTreeStatus,
  d.Value<double> dbh,
  d.Value<String> measEstDbh,
  d.Value<double> height,
  d.Value<String> measEstHeight,
  d.Value<String> crownClass,
  d.Value<double> crownBase,
  d.Value<double> crownTop,
  d.Value<String> stemCond,
  d.Value<int> crownCond,
  d.Value<int> barkRet,
  d.Value<int> woodCond,
  d.Value<int> azimuth,
  d.Value<double> distance,
  d.Value<int> renumbered,
});

class $$LtpTreeTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeTable,
    LtpTreeData,
    $$LtpTreeTableFilterComposer,
    $$LtpTreeTableOrderingComposer,
    $$LtpTreeTableProcessedTableManager,
    $$LtpTreeTableInsertCompanionBuilder,
    $$LtpTreeTableUpdateCompanionBuilder> {
  $$LtpTreeTableTableManager(_$Database db, $LtpTreeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) => $$LtpTreeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> lptSummaryId = const d.Value.absent(),
            d.Value<int> sector = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<String> origPlotArea = const d.Value.absent(),
            d.Value<String> lgTreeGenus = const d.Value.absent(),
            d.Value<String> lgTreeSpecies = const d.Value.absent(),
            d.Value<String> lgTreeVariety = const d.Value.absent(),
            d.Value<String> lgTreeStatus = const d.Value.absent(),
            d.Value<double> dbh = const d.Value.absent(),
            d.Value<String> measEstDbh = const d.Value.absent(),
            d.Value<double> height = const d.Value.absent(),
            d.Value<String> measEstHeight = const d.Value.absent(),
            d.Value<String> crownClass = const d.Value.absent(),
            d.Value<double> crownBase = const d.Value.absent(),
            d.Value<double> crownTop = const d.Value.absent(),
            d.Value<String> stemCond = const d.Value.absent(),
            d.Value<int> crownCond = const d.Value.absent(),
            d.Value<int> barkRet = const d.Value.absent(),
            d.Value<int> woodCond = const d.Value.absent(),
            d.Value<int> azimuth = const d.Value.absent(),
            d.Value<double> distance = const d.Value.absent(),
            d.Value<int> renumbered = const d.Value.absent(),
          }) =>
              LtpTreeCompanion(
            id: id,
            lptSummaryId: lptSummaryId,
            sector: sector,
            treeNum: treeNum,
            origPlotArea: origPlotArea,
            lgTreeGenus: lgTreeGenus,
            lgTreeSpecies: lgTreeSpecies,
            lgTreeVariety: lgTreeVariety,
            lgTreeStatus: lgTreeStatus,
            dbh: dbh,
            measEstDbh: measEstDbh,
            height: height,
            measEstHeight: measEstHeight,
            crownClass: crownClass,
            crownBase: crownBase,
            crownTop: crownTop,
            stemCond: stemCond,
            crownCond: crownCond,
            barkRet: barkRet,
            woodCond: woodCond,
            azimuth: azimuth,
            distance: distance,
            renumbered: renumbered,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int lptSummaryId,
            required int sector,
            required int treeNum,
            required String origPlotArea,
            required String lgTreeGenus,
            required String lgTreeSpecies,
            required String lgTreeVariety,
            required String lgTreeStatus,
            required double dbh,
            required String measEstDbh,
            required double height,
            required String measEstHeight,
            required String crownClass,
            required double crownBase,
            required double crownTop,
            required String stemCond,
            required int crownCond,
            required int barkRet,
            required int woodCond,
            required int azimuth,
            required double distance,
            required int renumbered,
          }) =>
              LtpTreeCompanion.insert(
            id: id,
            lptSummaryId: lptSummaryId,
            sector: sector,
            treeNum: treeNum,
            origPlotArea: origPlotArea,
            lgTreeGenus: lgTreeGenus,
            lgTreeSpecies: lgTreeSpecies,
            lgTreeVariety: lgTreeVariety,
            lgTreeStatus: lgTreeStatus,
            dbh: dbh,
            measEstDbh: measEstDbh,
            height: height,
            measEstHeight: measEstHeight,
            crownClass: crownClass,
            crownBase: crownBase,
            crownTop: crownTop,
            stemCond: stemCond,
            crownCond: crownCond,
            barkRet: barkRet,
            woodCond: woodCond,
            azimuth: azimuth,
            distance: distance,
            renumbered: renumbered,
          ),
        ));
}

class $$LtpTreeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpTreeTable,
    LtpTreeData,
    $$LtpTreeTableFilterComposer,
    $$LtpTreeTableOrderingComposer,
    $$LtpTreeTableProcessedTableManager,
    $$LtpTreeTableInsertCompanionBuilder,
    $$LtpTreeTableUpdateCompanionBuilder> {
  $$LtpTreeTableProcessedTableManager(super.$state);
}

class $$LtpTreeTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeTable> {
  $$LtpTreeTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get sector => $state.composableBuilder(
      column: $state.table.sector,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get lgTreeGenus => $state.composableBuilder(
      column: $state.table.lgTreeGenus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get lgTreeSpecies => $state.composableBuilder(
      column: $state.table.lgTreeSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get lgTreeVariety => $state.composableBuilder(
      column: $state.table.lgTreeVariety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get lgTreeStatus => $state.composableBuilder(
      column: $state.table.lgTreeStatus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get dbh => $state.composableBuilder(
      column: $state.table.dbh,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get measEstDbh => $state.composableBuilder(
      column: $state.table.measEstDbh,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get height => $state.composableBuilder(
      column: $state.table.height,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get measEstHeight => $state.composableBuilder(
      column: $state.table.measEstHeight,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get crownClass => $state.composableBuilder(
      column: $state.table.crownClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get crownBase => $state.composableBuilder(
      column: $state.table.crownBase,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get crownTop => $state.composableBuilder(
      column: $state.table.crownTop,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get stemCond => $state.composableBuilder(
      column: $state.table.stemCond,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get crownCond => $state.composableBuilder(
      column: $state.table.crownCond,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get barkRet => $state.composableBuilder(
      column: $state.table.barkRet,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get woodCond => $state.composableBuilder(
      column: $state.table.woodCond,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get azimuth => $state.composableBuilder(
      column: $state.table.azimuth,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get distance => $state.composableBuilder(
      column: $state.table.distance,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get renumbered => $state.composableBuilder(
      column: $state.table.renumbered,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableFilterComposer get lptSummaryId {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$LtpTreeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeTable> {
  $$LtpTreeTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get sector => $state.composableBuilder(
      column: $state.table.sector,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get lgTreeGenus => $state.composableBuilder(
      column: $state.table.lgTreeGenus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get lgTreeSpecies => $state.composableBuilder(
      column: $state.table.lgTreeSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get lgTreeVariety => $state.composableBuilder(
      column: $state.table.lgTreeVariety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get lgTreeStatus => $state.composableBuilder(
      column: $state.table.lgTreeStatus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get dbh => $state.composableBuilder(
      column: $state.table.dbh,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get measEstDbh => $state.composableBuilder(
      column: $state.table.measEstDbh,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get height => $state.composableBuilder(
      column: $state.table.height,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get measEstHeight => $state.composableBuilder(
      column: $state.table.measEstHeight,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get crownClass => $state.composableBuilder(
      column: $state.table.crownClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get crownBase => $state.composableBuilder(
      column: $state.table.crownBase,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get crownTop => $state.composableBuilder(
      column: $state.table.crownTop,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get stemCond => $state.composableBuilder(
      column: $state.table.stemCond,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get crownCond => $state.composableBuilder(
      column: $state.table.crownCond,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get barkRet => $state.composableBuilder(
      column: $state.table.barkRet,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get woodCond => $state.composableBuilder(
      column: $state.table.woodCond,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get azimuth => $state.composableBuilder(
      column: $state.table.azimuth,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get distance => $state.composableBuilder(
      column: $state.table.distance,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get renumbered => $state.composableBuilder(
      column: $state.table.renumbered,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableOrderingComposer get lptSummaryId {
    final $$LtpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpTreeDamageTableInsertCompanionBuilder = LtpTreeDamageCompanion
    Function({
  d.Value<int> id,
  required int lptSummaryId,
  required int treeNum,
  required String damageAgent,
  required String damageLocation,
  d.Value<int> severityPct,
  required String severity,
});
typedef $$LtpTreeDamageTableUpdateCompanionBuilder = LtpTreeDamageCompanion
    Function({
  d.Value<int> id,
  d.Value<int> lptSummaryId,
  d.Value<int> treeNum,
  d.Value<String> damageAgent,
  d.Value<String> damageLocation,
  d.Value<int> severityPct,
  d.Value<String> severity,
});

class $$LtpTreeDamageTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeDamageTable,
    LtpTreeDamageData,
    $$LtpTreeDamageTableFilterComposer,
    $$LtpTreeDamageTableOrderingComposer,
    $$LtpTreeDamageTableProcessedTableManager,
    $$LtpTreeDamageTableInsertCompanionBuilder,
    $$LtpTreeDamageTableUpdateCompanionBuilder> {
  $$LtpTreeDamageTableTableManager(_$Database db, $LtpTreeDamageTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeDamageTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeDamageTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpTreeDamageTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> lptSummaryId = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<String> damageAgent = const d.Value.absent(),
            d.Value<String> damageLocation = const d.Value.absent(),
            d.Value<int> severityPct = const d.Value.absent(),
            d.Value<String> severity = const d.Value.absent(),
          }) =>
              LtpTreeDamageCompanion(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            damageAgent: damageAgent,
            damageLocation: damageLocation,
            severityPct: severityPct,
            severity: severity,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int lptSummaryId,
            required int treeNum,
            required String damageAgent,
            required String damageLocation,
            d.Value<int> severityPct = const d.Value.absent(),
            required String severity,
          }) =>
              LtpTreeDamageCompanion.insert(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            damageAgent: damageAgent,
            damageLocation: damageLocation,
            severityPct: severityPct,
            severity: severity,
          ),
        ));
}

class $$LtpTreeDamageTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpTreeDamageTable,
    LtpTreeDamageData,
    $$LtpTreeDamageTableFilterComposer,
    $$LtpTreeDamageTableOrderingComposer,
    $$LtpTreeDamageTableProcessedTableManager,
    $$LtpTreeDamageTableInsertCompanionBuilder,
    $$LtpTreeDamageTableUpdateCompanionBuilder> {
  $$LtpTreeDamageTableProcessedTableManager(super.$state);
}

class $$LtpTreeDamageTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeDamageTable> {
  $$LtpTreeDamageTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get damageAgent => $state.composableBuilder(
      column: $state.table.damageAgent,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get damageLocation => $state.composableBuilder(
      column: $state.table.damageLocation,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get severityPct => $state.composableBuilder(
      column: $state.table.severityPct,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get severity => $state.composableBuilder(
      column: $state.table.severity,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableFilterComposer get lptSummaryId {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$LtpTreeDamageTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeDamageTable> {
  $$LtpTreeDamageTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get damageAgent => $state.composableBuilder(
      column: $state.table.damageAgent,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get damageLocation => $state.composableBuilder(
      column: $state.table.damageLocation,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get severityPct => $state.composableBuilder(
      column: $state.table.severityPct,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get severity => $state.composableBuilder(
      column: $state.table.severity,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableOrderingComposer get lptSummaryId {
    final $$LtpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpTreeRemovedTableInsertCompanionBuilder = LtpTreeRemovedCompanion
    Function({
  d.Value<int> id,
  required int lptSummaryId,
  required int treeNum,
  required String reason,
});
typedef $$LtpTreeRemovedTableUpdateCompanionBuilder = LtpTreeRemovedCompanion
    Function({
  d.Value<int> id,
  d.Value<int> lptSummaryId,
  d.Value<int> treeNum,
  d.Value<String> reason,
});

class $$LtpTreeRemovedTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeRemovedTable,
    LtpTreeRemovedData,
    $$LtpTreeRemovedTableFilterComposer,
    $$LtpTreeRemovedTableOrderingComposer,
    $$LtpTreeRemovedTableProcessedTableManager,
    $$LtpTreeRemovedTableInsertCompanionBuilder,
    $$LtpTreeRemovedTableUpdateCompanionBuilder> {
  $$LtpTreeRemovedTableTableManager(_$Database db, $LtpTreeRemovedTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeRemovedTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeRemovedTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpTreeRemovedTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> lptSummaryId = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<String> reason = const d.Value.absent(),
          }) =>
              LtpTreeRemovedCompanion(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            reason: reason,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int lptSummaryId,
            required int treeNum,
            required String reason,
          }) =>
              LtpTreeRemovedCompanion.insert(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            reason: reason,
          ),
        ));
}

class $$LtpTreeRemovedTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpTreeRemovedTable,
        LtpTreeRemovedData,
        $$LtpTreeRemovedTableFilterComposer,
        $$LtpTreeRemovedTableOrderingComposer,
        $$LtpTreeRemovedTableProcessedTableManager,
        $$LtpTreeRemovedTableInsertCompanionBuilder,
        $$LtpTreeRemovedTableUpdateCompanionBuilder> {
  $$LtpTreeRemovedTableProcessedTableManager(super.$state);
}

class $$LtpTreeRemovedTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeRemovedTable> {
  $$LtpTreeRemovedTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get reason => $state.composableBuilder(
      column: $state.table.reason,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableFilterComposer get lptSummaryId {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$LtpTreeRemovedTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeRemovedTable> {
  $$LtpTreeRemovedTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get reason => $state.composableBuilder(
      column: $state.table.reason,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableOrderingComposer get lptSummaryId {
    final $$LtpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpTreeAgeTableInsertCompanionBuilder = LtpTreeAgeCompanion Function({
  d.Value<int> id,
  required int lptSummaryId,
  required String quadrant,
  required int treeNum,
  required String siteType,
  required double boreDOB,
  required double boreHt,
  required String suitHt,
  required String suitAge,
  required int fieldAge,
  required String proCode,
});
typedef $$LtpTreeAgeTableUpdateCompanionBuilder = LtpTreeAgeCompanion Function({
  d.Value<int> id,
  d.Value<int> lptSummaryId,
  d.Value<String> quadrant,
  d.Value<int> treeNum,
  d.Value<String> siteType,
  d.Value<double> boreDOB,
  d.Value<double> boreHt,
  d.Value<String> suitHt,
  d.Value<String> suitAge,
  d.Value<int> fieldAge,
  d.Value<String> proCode,
});

class $$LtpTreeAgeTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeAgeTable,
    LtpTreeAgeData,
    $$LtpTreeAgeTableFilterComposer,
    $$LtpTreeAgeTableOrderingComposer,
    $$LtpTreeAgeTableProcessedTableManager,
    $$LtpTreeAgeTableInsertCompanionBuilder,
    $$LtpTreeAgeTableUpdateCompanionBuilder> {
  $$LtpTreeAgeTableTableManager(_$Database db, $LtpTreeAgeTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeAgeTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeAgeTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpTreeAgeTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> lptSummaryId = const d.Value.absent(),
            d.Value<String> quadrant = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<String> siteType = const d.Value.absent(),
            d.Value<double> boreDOB = const d.Value.absent(),
            d.Value<double> boreHt = const d.Value.absent(),
            d.Value<String> suitHt = const d.Value.absent(),
            d.Value<String> suitAge = const d.Value.absent(),
            d.Value<int> fieldAge = const d.Value.absent(),
            d.Value<String> proCode = const d.Value.absent(),
          }) =>
              LtpTreeAgeCompanion(
            id: id,
            lptSummaryId: lptSummaryId,
            quadrant: quadrant,
            treeNum: treeNum,
            siteType: siteType,
            boreDOB: boreDOB,
            boreHt: boreHt,
            suitHt: suitHt,
            suitAge: suitAge,
            fieldAge: fieldAge,
            proCode: proCode,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int lptSummaryId,
            required String quadrant,
            required int treeNum,
            required String siteType,
            required double boreDOB,
            required double boreHt,
            required String suitHt,
            required String suitAge,
            required int fieldAge,
            required String proCode,
          }) =>
              LtpTreeAgeCompanion.insert(
            id: id,
            lptSummaryId: lptSummaryId,
            quadrant: quadrant,
            treeNum: treeNum,
            siteType: siteType,
            boreDOB: boreDOB,
            boreHt: boreHt,
            suitHt: suitHt,
            suitAge: suitAge,
            fieldAge: fieldAge,
            proCode: proCode,
          ),
        ));
}

class $$LtpTreeAgeTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $LtpTreeAgeTable,
    LtpTreeAgeData,
    $$LtpTreeAgeTableFilterComposer,
    $$LtpTreeAgeTableOrderingComposer,
    $$LtpTreeAgeTableProcessedTableManager,
    $$LtpTreeAgeTableInsertCompanionBuilder,
    $$LtpTreeAgeTableUpdateCompanionBuilder> {
  $$LtpTreeAgeTableProcessedTableManager(super.$state);
}

class $$LtpTreeAgeTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeAgeTable> {
  $$LtpTreeAgeTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get quadrant => $state.composableBuilder(
      column: $state.table.quadrant,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get siteType => $state.composableBuilder(
      column: $state.table.siteType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get boreDOB => $state.composableBuilder(
      column: $state.table.boreDOB,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get boreHt => $state.composableBuilder(
      column: $state.table.boreHt,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get suitHt => $state.composableBuilder(
      column: $state.table.suitHt,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get suitAge => $state.composableBuilder(
      column: $state.table.suitAge,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get fieldAge => $state.composableBuilder(
      column: $state.table.fieldAge,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get proCode => $state.composableBuilder(
      column: $state.table.proCode,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableFilterComposer get lptSummaryId {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$LtpTreeAgeTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeAgeTable> {
  $$LtpTreeAgeTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get quadrant => $state.composableBuilder(
      column: $state.table.quadrant,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get siteType => $state.composableBuilder(
      column: $state.table.siteType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get boreDOB => $state.composableBuilder(
      column: $state.table.boreDOB,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get boreHt => $state.composableBuilder(
      column: $state.table.boreHt,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get suitHt => $state.composableBuilder(
      column: $state.table.suitHt,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get suitAge => $state.composableBuilder(
      column: $state.table.suitAge,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get fieldAge => $state.composableBuilder(
      column: $state.table.fieldAge,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get proCode => $state.composableBuilder(
      column: $state.table.proCode,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableOrderingComposer get lptSummaryId {
    final $$LtpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$LtpTreeRenamedTableInsertCompanionBuilder = LtpTreeRenamedCompanion
    Function({
  d.Value<int> id,
  required int lptSummaryId,
  required int treeNum,
  required int treeNumPrev,
});
typedef $$LtpTreeRenamedTableUpdateCompanionBuilder = LtpTreeRenamedCompanion
    Function({
  d.Value<int> id,
  d.Value<int> lptSummaryId,
  d.Value<int> treeNum,
  d.Value<int> treeNumPrev,
});

class $$LtpTreeRenamedTableTableManager extends d.RootTableManager<
    _$Database,
    $LtpTreeRenamedTable,
    LtpTreeRenamedData,
    $$LtpTreeRenamedTableFilterComposer,
    $$LtpTreeRenamedTableOrderingComposer,
    $$LtpTreeRenamedTableProcessedTableManager,
    $$LtpTreeRenamedTableInsertCompanionBuilder,
    $$LtpTreeRenamedTableUpdateCompanionBuilder> {
  $$LtpTreeRenamedTableTableManager(_$Database db, $LtpTreeRenamedTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$LtpTreeRenamedTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$LtpTreeRenamedTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$LtpTreeRenamedTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> lptSummaryId = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<int> treeNumPrev = const d.Value.absent(),
          }) =>
              LtpTreeRenamedCompanion(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            treeNumPrev: treeNumPrev,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int lptSummaryId,
            required int treeNum,
            required int treeNumPrev,
          }) =>
              LtpTreeRenamedCompanion.insert(
            id: id,
            lptSummaryId: lptSummaryId,
            treeNum: treeNum,
            treeNumPrev: treeNumPrev,
          ),
        ));
}

class $$LtpTreeRenamedTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $LtpTreeRenamedTable,
        LtpTreeRenamedData,
        $$LtpTreeRenamedTableFilterComposer,
        $$LtpTreeRenamedTableOrderingComposer,
        $$LtpTreeRenamedTableProcessedTableManager,
        $$LtpTreeRenamedTableInsertCompanionBuilder,
        $$LtpTreeRenamedTableUpdateCompanionBuilder> {
  $$LtpTreeRenamedTableProcessedTableManager(super.$state);
}

class $$LtpTreeRenamedTableFilterComposer
    extends d.FilterComposer<_$Database, $LtpTreeRenamedTable> {
  $$LtpTreeRenamedTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNumPrev => $state.composableBuilder(
      column: $state.table.treeNumPrev,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableFilterComposer get lptSummaryId {
    final $$LtpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$LtpTreeRenamedTableOrderingComposer
    extends d.OrderingComposer<_$Database, $LtpTreeRenamedTable> {
  $$LtpTreeRenamedTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNumPrev => $state.composableBuilder(
      column: $state.table.treeNumPrev,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$LtpSummaryTableOrderingComposer get lptSummaryId {
    final $$LtpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lptSummaryId,
        referencedTable: $state.db.ltpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$LtpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.ltpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$StpSummaryTableInsertCompanionBuilder = StpSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  required String plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$StpSummaryTableUpdateCompanionBuilder = StpSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<String> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$StpSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $StpSummaryTable,
    StpSummaryData,
    $$StpSummaryTableFilterComposer,
    $$StpSummaryTableOrderingComposer,
    $$StpSummaryTableProcessedTableManager,
    $$StpSummaryTableInsertCompanionBuilder,
    $$StpSummaryTableUpdateCompanionBuilder> {
  $$StpSummaryTableTableManager(_$Database db, $StpSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StpSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<String> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              StpSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            required String plotType,
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              StpSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$StpSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StpSummaryTable,
    StpSummaryData,
    $$StpSummaryTableFilterComposer,
    $$StpSummaryTableOrderingComposer,
    $$StpSummaryTableProcessedTableManager,
    $$StpSummaryTableInsertCompanionBuilder,
    $$StpSummaryTableUpdateCompanionBuilder> {
  $$StpSummaryTableProcessedTableManager(super.$state);
}

class $$StpSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $StpSummaryTable> {
  $$StpSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter stpSpeciesRefs(
      d.ComposableFilter Function($$StpSpeciesTableFilterComposer f) f) {
    final $$StpSpeciesTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.stpSpecies,
        getReferencedColumn: (t) => t.stpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$StpSpeciesTableFilterComposer(d.ComposerState($state.db,
                $state.db.stpSpecies, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$StpSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpSummaryTable> {
  $$StpSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$StpSpeciesTableInsertCompanionBuilder = StpSpeciesCompanion Function({
  d.Value<int> id,
  required int stpSummaryId,
  required int treeNum,
  required String origPlotArea,
  required String genus,
  required String species,
  required String variety,
  required String status,
  required double dbh,
  required double height,
  required String measHeight,
  required String stemCondition,
});
typedef $$StpSpeciesTableUpdateCompanionBuilder = StpSpeciesCompanion Function({
  d.Value<int> id,
  d.Value<int> stpSummaryId,
  d.Value<int> treeNum,
  d.Value<String> origPlotArea,
  d.Value<String> genus,
  d.Value<String> species,
  d.Value<String> variety,
  d.Value<String> status,
  d.Value<double> dbh,
  d.Value<double> height,
  d.Value<String> measHeight,
  d.Value<String> stemCondition,
});

class $$StpSpeciesTableTableManager extends d.RootTableManager<
    _$Database,
    $StpSpeciesTable,
    StpSpeciesData,
    $$StpSpeciesTableFilterComposer,
    $$StpSpeciesTableOrderingComposer,
    $$StpSpeciesTableProcessedTableManager,
    $$StpSpeciesTableInsertCompanionBuilder,
    $$StpSpeciesTableUpdateCompanionBuilder> {
  $$StpSpeciesTableTableManager(_$Database db, $StpSpeciesTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StpSpeciesTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StpSpeciesTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StpSpeciesTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> stpSummaryId = const d.Value.absent(),
            d.Value<int> treeNum = const d.Value.absent(),
            d.Value<String> origPlotArea = const d.Value.absent(),
            d.Value<String> genus = const d.Value.absent(),
            d.Value<String> species = const d.Value.absent(),
            d.Value<String> variety = const d.Value.absent(),
            d.Value<String> status = const d.Value.absent(),
            d.Value<double> dbh = const d.Value.absent(),
            d.Value<double> height = const d.Value.absent(),
            d.Value<String> measHeight = const d.Value.absent(),
            d.Value<String> stemCondition = const d.Value.absent(),
          }) =>
              StpSpeciesCompanion(
            id: id,
            stpSummaryId: stpSummaryId,
            treeNum: treeNum,
            origPlotArea: origPlotArea,
            genus: genus,
            species: species,
            variety: variety,
            status: status,
            dbh: dbh,
            height: height,
            measHeight: measHeight,
            stemCondition: stemCondition,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int stpSummaryId,
            required int treeNum,
            required String origPlotArea,
            required String genus,
            required String species,
            required String variety,
            required String status,
            required double dbh,
            required double height,
            required String measHeight,
            required String stemCondition,
          }) =>
              StpSpeciesCompanion.insert(
            id: id,
            stpSummaryId: stpSummaryId,
            treeNum: treeNum,
            origPlotArea: origPlotArea,
            genus: genus,
            species: species,
            variety: variety,
            status: status,
            dbh: dbh,
            height: height,
            measHeight: measHeight,
            stemCondition: stemCondition,
          ),
        ));
}

class $$StpSpeciesTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StpSpeciesTable,
    StpSpeciesData,
    $$StpSpeciesTableFilterComposer,
    $$StpSpeciesTableOrderingComposer,
    $$StpSpeciesTableProcessedTableManager,
    $$StpSpeciesTableInsertCompanionBuilder,
    $$StpSpeciesTableUpdateCompanionBuilder> {
  $$StpSpeciesTableProcessedTableManager(super.$state);
}

class $$StpSpeciesTableFilterComposer
    extends d.FilterComposer<_$Database, $StpSpeciesTable> {
  $$StpSpeciesTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get dbh => $state.composableBuilder(
      column: $state.table.dbh,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get height => $state.composableBuilder(
      column: $state.table.height,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get measHeight => $state.composableBuilder(
      column: $state.table.measHeight,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get stemCondition => $state.composableBuilder(
      column: $state.table.stemCondition,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$StpSummaryTableFilterComposer get stpSummaryId {
    final $$StpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stpSummaryId,
        referencedTable: $state.db.stpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$StpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.stpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$StpSpeciesTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StpSpeciesTable> {
  $$StpSpeciesTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treeNum => $state.composableBuilder(
      column: $state.table.treeNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get genus => $state.composableBuilder(
      column: $state.table.genus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get species => $state.composableBuilder(
      column: $state.table.species,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get variety => $state.composableBuilder(
      column: $state.table.variety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get status => $state.composableBuilder(
      column: $state.table.status,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get dbh => $state.composableBuilder(
      column: $state.table.dbh,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get height => $state.composableBuilder(
      column: $state.table.height,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get measHeight => $state.composableBuilder(
      column: $state.table.measHeight,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get stemCondition => $state.composableBuilder(
      column: $state.table.stemCondition,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$StpSummaryTableOrderingComposer get stpSummaryId {
    final $$StpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stpSummaryId,
        referencedTable: $state.db.stpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$StpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.stpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$ShrubSummaryTableInsertCompanionBuilder = ShrubSummaryCompanion
    Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  required String plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$ShrubSummaryTableUpdateCompanionBuilder = ShrubSummaryCompanion
    Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<String> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$ShrubSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $ShrubSummaryTable,
    ShrubSummaryData,
    $$ShrubSummaryTableFilterComposer,
    $$ShrubSummaryTableOrderingComposer,
    $$ShrubSummaryTableProcessedTableManager,
    $$ShrubSummaryTableInsertCompanionBuilder,
    $$ShrubSummaryTableUpdateCompanionBuilder> {
  $$ShrubSummaryTableTableManager(_$Database db, $ShrubSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ShrubSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$ShrubSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ShrubSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<String> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              ShrubSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            required String plotType,
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              ShrubSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$ShrubSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $ShrubSummaryTable,
    ShrubSummaryData,
    $$ShrubSummaryTableFilterComposer,
    $$ShrubSummaryTableOrderingComposer,
    $$ShrubSummaryTableProcessedTableManager,
    $$ShrubSummaryTableInsertCompanionBuilder,
    $$ShrubSummaryTableUpdateCompanionBuilder> {
  $$ShrubSummaryTableProcessedTableManager(super.$state);
}

class $$ShrubSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $ShrubSummaryTable> {
  $$ShrubSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter shrubListEntryRefs(
      d.ComposableFilter Function($$ShrubListEntryTableFilterComposer f) f) {
    final $$ShrubListEntryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.shrubListEntry,
        getReferencedColumn: (t) => t.shrubSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$ShrubListEntryTableFilterComposer(d.ComposerState($state.db,
                $state.db.shrubListEntry, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$ShrubSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $ShrubSummaryTable> {
  $$ShrubSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$ShrubListEntryTableInsertCompanionBuilder = ShrubListEntryCompanion
    Function({
  d.Value<int> id,
  required int shrubSummaryId,
  required int recordNum,
  required String shrubGenus,
  required String shrubSpecies,
  required String shrubVariety,
  required String shrubStatus,
  required int bdClass,
  required int frequency,
});
typedef $$ShrubListEntryTableUpdateCompanionBuilder = ShrubListEntryCompanion
    Function({
  d.Value<int> id,
  d.Value<int> shrubSummaryId,
  d.Value<int> recordNum,
  d.Value<String> shrubGenus,
  d.Value<String> shrubSpecies,
  d.Value<String> shrubVariety,
  d.Value<String> shrubStatus,
  d.Value<int> bdClass,
  d.Value<int> frequency,
});

class $$ShrubListEntryTableTableManager extends d.RootTableManager<
    _$Database,
    $ShrubListEntryTable,
    ShrubListEntryData,
    $$ShrubListEntryTableFilterComposer,
    $$ShrubListEntryTableOrderingComposer,
    $$ShrubListEntryTableProcessedTableManager,
    $$ShrubListEntryTableInsertCompanionBuilder,
    $$ShrubListEntryTableUpdateCompanionBuilder> {
  $$ShrubListEntryTableTableManager(_$Database db, $ShrubListEntryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$ShrubListEntryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$ShrubListEntryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$ShrubListEntryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> shrubSummaryId = const d.Value.absent(),
            d.Value<int> recordNum = const d.Value.absent(),
            d.Value<String> shrubGenus = const d.Value.absent(),
            d.Value<String> shrubSpecies = const d.Value.absent(),
            d.Value<String> shrubVariety = const d.Value.absent(),
            d.Value<String> shrubStatus = const d.Value.absent(),
            d.Value<int> bdClass = const d.Value.absent(),
            d.Value<int> frequency = const d.Value.absent(),
          }) =>
              ShrubListEntryCompanion(
            id: id,
            shrubSummaryId: shrubSummaryId,
            recordNum: recordNum,
            shrubGenus: shrubGenus,
            shrubSpecies: shrubSpecies,
            shrubVariety: shrubVariety,
            shrubStatus: shrubStatus,
            bdClass: bdClass,
            frequency: frequency,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int shrubSummaryId,
            required int recordNum,
            required String shrubGenus,
            required String shrubSpecies,
            required String shrubVariety,
            required String shrubStatus,
            required int bdClass,
            required int frequency,
          }) =>
              ShrubListEntryCompanion.insert(
            id: id,
            shrubSummaryId: shrubSummaryId,
            recordNum: recordNum,
            shrubGenus: shrubGenus,
            shrubSpecies: shrubSpecies,
            shrubVariety: shrubVariety,
            shrubStatus: shrubStatus,
            bdClass: bdClass,
            frequency: frequency,
          ),
        ));
}

class $$ShrubListEntryTableProcessedTableManager
    extends d.ProcessedTableManager<
        _$Database,
        $ShrubListEntryTable,
        ShrubListEntryData,
        $$ShrubListEntryTableFilterComposer,
        $$ShrubListEntryTableOrderingComposer,
        $$ShrubListEntryTableProcessedTableManager,
        $$ShrubListEntryTableInsertCompanionBuilder,
        $$ShrubListEntryTableUpdateCompanionBuilder> {
  $$ShrubListEntryTableProcessedTableManager(super.$state);
}

class $$ShrubListEntryTableFilterComposer
    extends d.FilterComposer<_$Database, $ShrubListEntryTable> {
  $$ShrubListEntryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get recordNum => $state.composableBuilder(
      column: $state.table.recordNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get shrubGenus => $state.composableBuilder(
      column: $state.table.shrubGenus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get shrubSpecies => $state.composableBuilder(
      column: $state.table.shrubSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get shrubVariety => $state.composableBuilder(
      column: $state.table.shrubVariety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get shrubStatus => $state.composableBuilder(
      column: $state.table.shrubStatus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get bdClass => $state.composableBuilder(
      column: $state.table.bdClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get frequency => $state.composableBuilder(
      column: $state.table.frequency,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$ShrubSummaryTableFilterComposer get shrubSummaryId {
    final $$ShrubSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.shrubSummaryId,
        referencedTable: $state.db.shrubSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$ShrubSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.shrubSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$ShrubListEntryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $ShrubListEntryTable> {
  $$ShrubListEntryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get recordNum => $state.composableBuilder(
      column: $state.table.recordNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get shrubGenus => $state.composableBuilder(
      column: $state.table.shrubGenus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get shrubSpecies => $state.composableBuilder(
      column: $state.table.shrubSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get shrubVariety => $state.composableBuilder(
      column: $state.table.shrubVariety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get shrubStatus => $state.composableBuilder(
      column: $state.table.shrubStatus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get bdClass => $state.composableBuilder(
      column: $state.table.bdClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get frequency => $state.composableBuilder(
      column: $state.table.frequency,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$ShrubSummaryTableOrderingComposer get shrubSummaryId {
    final $$ShrubSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.shrubSummaryId,
        referencedTable: $state.db.shrubSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$ShrubSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.shrubSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$StumpSummaryTableInsertCompanionBuilder = StumpSummaryCompanion
    Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  required String plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$StumpSummaryTableUpdateCompanionBuilder = StumpSummaryCompanion
    Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<String> plotType,
  d.Value<double?> nomPlotSize,
  d.Value<double?> measPlotSize,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$StumpSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $StumpSummaryTable,
    StumpSummaryData,
    $$StumpSummaryTableFilterComposer,
    $$StumpSummaryTableOrderingComposer,
    $$StumpSummaryTableProcessedTableManager,
    $$StumpSummaryTableInsertCompanionBuilder,
    $$StumpSummaryTableUpdateCompanionBuilder> {
  $$StumpSummaryTableTableManager(_$Database db, $StumpSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StumpSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StumpSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StumpSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<String> plotType = const d.Value.absent(),
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              StumpSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            required String plotType,
            d.Value<double?> nomPlotSize = const d.Value.absent(),
            d.Value<double?> measPlotSize = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              StumpSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            plotType: plotType,
            nomPlotSize: nomPlotSize,
            measPlotSize: measPlotSize,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$StumpSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StumpSummaryTable,
    StumpSummaryData,
    $$StumpSummaryTableFilterComposer,
    $$StumpSummaryTableOrderingComposer,
    $$StumpSummaryTableProcessedTableManager,
    $$StumpSummaryTableInsertCompanionBuilder,
    $$StumpSummaryTableUpdateCompanionBuilder> {
  $$StumpSummaryTableProcessedTableManager(super.$state);
}

class $$StumpSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $StumpSummaryTable> {
  $$StumpSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter stumpEntryRefs(
      d.ComposableFilter Function($$StumpEntryTableFilterComposer f) f) {
    final $$StumpEntryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.stumpEntry,
        getReferencedColumn: (t) => t.stumpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$StumpEntryTableFilterComposer(d.ComposerState($state.db,
                $state.db.stumpEntry, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$StumpSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StumpSummaryTable> {
  $$StumpSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotType => $state.composableBuilder(
      column: $state.table.plotType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get nomPlotSize => $state.composableBuilder(
      column: $state.table.nomPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get measPlotSize => $state.composableBuilder(
      column: $state.table.measPlotSize,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$StumpEntryTableInsertCompanionBuilder = StumpEntryCompanion Function({
  d.Value<int> id,
  required int stumpSummaryId,
  required int stumpNum,
  required String origPlotArea,
  required String stumpGenus,
  required String stumpSpecies,
  required String stumpVariety,
  required double stumpDib,
  required double stumpDiameter,
  required int stumpDecay,
  required double stumpLength,
});
typedef $$StumpEntryTableUpdateCompanionBuilder = StumpEntryCompanion Function({
  d.Value<int> id,
  d.Value<int> stumpSummaryId,
  d.Value<int> stumpNum,
  d.Value<String> origPlotArea,
  d.Value<String> stumpGenus,
  d.Value<String> stumpSpecies,
  d.Value<String> stumpVariety,
  d.Value<double> stumpDib,
  d.Value<double> stumpDiameter,
  d.Value<int> stumpDecay,
  d.Value<double> stumpLength,
});

class $$StumpEntryTableTableManager extends d.RootTableManager<
    _$Database,
    $StumpEntryTable,
    StumpEntryData,
    $$StumpEntryTableFilterComposer,
    $$StumpEntryTableOrderingComposer,
    $$StumpEntryTableProcessedTableManager,
    $$StumpEntryTableInsertCompanionBuilder,
    $$StumpEntryTableUpdateCompanionBuilder> {
  $$StumpEntryTableTableManager(_$Database db, $StumpEntryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$StumpEntryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$StumpEntryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$StumpEntryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> stumpSummaryId = const d.Value.absent(),
            d.Value<int> stumpNum = const d.Value.absent(),
            d.Value<String> origPlotArea = const d.Value.absent(),
            d.Value<String> stumpGenus = const d.Value.absent(),
            d.Value<String> stumpSpecies = const d.Value.absent(),
            d.Value<String> stumpVariety = const d.Value.absent(),
            d.Value<double> stumpDib = const d.Value.absent(),
            d.Value<double> stumpDiameter = const d.Value.absent(),
            d.Value<int> stumpDecay = const d.Value.absent(),
            d.Value<double> stumpLength = const d.Value.absent(),
          }) =>
              StumpEntryCompanion(
            id: id,
            stumpSummaryId: stumpSummaryId,
            stumpNum: stumpNum,
            origPlotArea: origPlotArea,
            stumpGenus: stumpGenus,
            stumpSpecies: stumpSpecies,
            stumpVariety: stumpVariety,
            stumpDib: stumpDib,
            stumpDiameter: stumpDiameter,
            stumpDecay: stumpDecay,
            stumpLength: stumpLength,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int stumpSummaryId,
            required int stumpNum,
            required String origPlotArea,
            required String stumpGenus,
            required String stumpSpecies,
            required String stumpVariety,
            required double stumpDib,
            required double stumpDiameter,
            required int stumpDecay,
            required double stumpLength,
          }) =>
              StumpEntryCompanion.insert(
            id: id,
            stumpSummaryId: stumpSummaryId,
            stumpNum: stumpNum,
            origPlotArea: origPlotArea,
            stumpGenus: stumpGenus,
            stumpSpecies: stumpSpecies,
            stumpVariety: stumpVariety,
            stumpDib: stumpDib,
            stumpDiameter: stumpDiameter,
            stumpDecay: stumpDecay,
            stumpLength: stumpLength,
          ),
        ));
}

class $$StumpEntryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $StumpEntryTable,
    StumpEntryData,
    $$StumpEntryTableFilterComposer,
    $$StumpEntryTableOrderingComposer,
    $$StumpEntryTableProcessedTableManager,
    $$StumpEntryTableInsertCompanionBuilder,
    $$StumpEntryTableUpdateCompanionBuilder> {
  $$StumpEntryTableProcessedTableManager(super.$state);
}

class $$StumpEntryTableFilterComposer
    extends d.FilterComposer<_$Database, $StumpEntryTable> {
  $$StumpEntryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get stumpNum => $state.composableBuilder(
      column: $state.table.stumpNum,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get stumpGenus => $state.composableBuilder(
      column: $state.table.stumpGenus,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get stumpSpecies => $state.composableBuilder(
      column: $state.table.stumpSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get stumpVariety => $state.composableBuilder(
      column: $state.table.stumpVariety,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get stumpDib => $state.composableBuilder(
      column: $state.table.stumpDib,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get stumpDiameter => $state.composableBuilder(
      column: $state.table.stumpDiameter,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get stumpDecay => $state.composableBuilder(
      column: $state.table.stumpDecay,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get stumpLength => $state.composableBuilder(
      column: $state.table.stumpLength,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$StumpSummaryTableFilterComposer get stumpSummaryId {
    final $$StumpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stumpSummaryId,
        referencedTable: $state.db.stumpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$StumpSummaryTableFilterComposer(d.ComposerState($state.db,
                $state.db.stumpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$StumpEntryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $StumpEntryTable> {
  $$StumpEntryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get stumpNum => $state.composableBuilder(
      column: $state.table.stumpNum,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get origPlotArea => $state.composableBuilder(
      column: $state.table.origPlotArea,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get stumpGenus => $state.composableBuilder(
      column: $state.table.stumpGenus,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get stumpSpecies => $state.composableBuilder(
      column: $state.table.stumpSpecies,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get stumpVariety => $state.composableBuilder(
      column: $state.table.stumpVariety,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get stumpDib => $state.composableBuilder(
      column: $state.table.stumpDib,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get stumpDiameter => $state.composableBuilder(
      column: $state.table.stumpDiameter,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get stumpDecay => $state.composableBuilder(
      column: $state.table.stumpDecay,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get stumpLength => $state.composableBuilder(
      column: $state.table.stumpLength,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$StumpSummaryTableOrderingComposer get stumpSummaryId {
    final $$StumpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.stumpSummaryId,
        referencedTable: $state.db.stumpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$StumpSummaryTableOrderingComposer(d.ComposerState($state.db,
                $state.db.stumpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$GpSummaryTableInsertCompanionBuilder = GpSummaryCompanion Function({
  d.Value<int> id,
  required int surveyId,
  required DateTime measDate,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});
typedef $$GpSummaryTableUpdateCompanionBuilder = GpSummaryCompanion Function({
  d.Value<int> id,
  d.Value<int> surveyId,
  d.Value<DateTime> measDate,
  d.Value<bool> notAssessed,
  d.Value<bool> complete,
});

class $$GpSummaryTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSummaryTable,
    GpSummaryData,
    $$GpSummaryTableFilterComposer,
    $$GpSummaryTableOrderingComposer,
    $$GpSummaryTableProcessedTableManager,
    $$GpSummaryTableInsertCompanionBuilder,
    $$GpSummaryTableUpdateCompanionBuilder> {
  $$GpSummaryTableTableManager(_$Database db, $GpSummaryTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpSummaryTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpSummaryTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSummaryTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> surveyId = const d.Value.absent(),
            d.Value<DateTime> measDate = const d.Value.absent(),
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              GpSummaryCompanion(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            notAssessed: notAssessed,
            complete: complete,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int surveyId,
            required DateTime measDate,
            d.Value<bool> notAssessed = const d.Value.absent(),
            d.Value<bool> complete = const d.Value.absent(),
          }) =>
              GpSummaryCompanion.insert(
            id: id,
            surveyId: surveyId,
            measDate: measDate,
            notAssessed: notAssessed,
            complete: complete,
          ),
        ));
}

class $$GpSummaryTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpSummaryTable,
    GpSummaryData,
    $$GpSummaryTableFilterComposer,
    $$GpSummaryTableOrderingComposer,
    $$GpSummaryTableProcessedTableManager,
    $$GpSummaryTableInsertCompanionBuilder,
    $$GpSummaryTableUpdateCompanionBuilder> {
  $$GpSummaryTableProcessedTableManager(super.$state);
}

class $$GpSummaryTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSummaryTable> {
  $$GpSummaryTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableFilterComposer get surveyId {
    final $$SurveyHeadersTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.surveyId,
        referencedTable: $state.db.surveyHeaders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$SurveyHeadersTableFilterComposer(d.ComposerState($state.db,
                $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }

  d.ComposableFilter gpSiteInfoRefs(
      d.ComposableFilter Function($$GpSiteInfoTableFilterComposer f) f) {
    final $$GpSiteInfoTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.gpSiteInfo,
        getReferencedColumn: (t) => t.gpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$GpSiteInfoTableFilterComposer(d.ComposerState($state.db,
                $state.db.gpSiteInfo, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter gpDisturbanceRefs(
      d.ComposableFilter Function($$GpDisturbanceTableFilterComposer f) f) {
    final $$GpDisturbanceTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.gpDisturbance,
        getReferencedColumn: (t) => t.gpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$GpDisturbanceTableFilterComposer(d.ComposerState($state.db,
                $state.db.gpDisturbance, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter gpOriginRefs(
      d.ComposableFilter Function($$GpOriginTableFilterComposer f) f) {
    final $$GpOriginTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.gpOrigin,
        getReferencedColumn: (t) => t.gpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$GpOriginTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpOrigin, joinBuilder, parentComposers)));
    return f(composer);
  }

  d.ComposableFilter gpTreatmentRefs(
      d.ComposableFilter Function($$GpTreatmentTableFilterComposer f) f) {
    final $$GpTreatmentTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $state.db.gpTreatment,
        getReferencedColumn: (t) => t.gpSummaryId,
        builder: (joinBuilder, parentComposers) =>
            $$GpTreatmentTableFilterComposer(d.ComposerState($state.db,
                $state.db.gpTreatment, joinBuilder, parentComposers)));
    return f(composer);
  }
}

class $$GpSummaryTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSummaryTable> {
  $$GpSummaryTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<DateTime> get measDate => $state.composableBuilder(
      column: $state.table.measDate,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get notAssessed => $state.composableBuilder(
      column: $state.table.notAssessed,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<bool> get complete => $state.composableBuilder(
      column: $state.table.complete,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$SurveyHeadersTableOrderingComposer get surveyId {
    final $$SurveyHeadersTableOrderingComposer composer =
        $state.composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.surveyId,
            referencedTable: $state.db.surveyHeaders,
            getReferencedColumn: (t) => t.id,
            builder: (joinBuilder, parentComposers) =>
                $$SurveyHeadersTableOrderingComposer(d.ComposerState($state.db,
                    $state.db.surveyHeaders, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$GpSiteInfoTableInsertCompanionBuilder = GpSiteInfoCompanion Function({
  d.Value<int> id,
  required int gpSummaryId,
  required String plotCompletion,
  required String incompReason,
  required int ecozone,
  d.Value<String?> provEcoType,
  required int provEcoRef,
  required String postProcessing,
  required int utmN,
  required double utmNAccuracy,
  required int utmE,
  required double utmEAccuracy,
  required int utmZone,
  required int slope,
  required int aspect,
  required int elevation,
  required String landBase,
  required String landCover,
  required String landPos,
  required String vegType,
  required String densityCl,
  required String standStru,
  required String succStage,
  required String wetlandClass,
  d.Value<String?> userInfo,
  required String gpsMake,
  required String gpsModel,
  required int gpsPoint,
});
typedef $$GpSiteInfoTableUpdateCompanionBuilder = GpSiteInfoCompanion Function({
  d.Value<int> id,
  d.Value<int> gpSummaryId,
  d.Value<String> plotCompletion,
  d.Value<String> incompReason,
  d.Value<int> ecozone,
  d.Value<String?> provEcoType,
  d.Value<int> provEcoRef,
  d.Value<String> postProcessing,
  d.Value<int> utmN,
  d.Value<double> utmNAccuracy,
  d.Value<int> utmE,
  d.Value<double> utmEAccuracy,
  d.Value<int> utmZone,
  d.Value<int> slope,
  d.Value<int> aspect,
  d.Value<int> elevation,
  d.Value<String> landBase,
  d.Value<String> landCover,
  d.Value<String> landPos,
  d.Value<String> vegType,
  d.Value<String> densityCl,
  d.Value<String> standStru,
  d.Value<String> succStage,
  d.Value<String> wetlandClass,
  d.Value<String?> userInfo,
  d.Value<String> gpsMake,
  d.Value<String> gpsModel,
  d.Value<int> gpsPoint,
});

class $$GpSiteInfoTableTableManager extends d.RootTableManager<
    _$Database,
    $GpSiteInfoTable,
    GpSiteInfoData,
    $$GpSiteInfoTableFilterComposer,
    $$GpSiteInfoTableOrderingComposer,
    $$GpSiteInfoTableProcessedTableManager,
    $$GpSiteInfoTableInsertCompanionBuilder,
    $$GpSiteInfoTableUpdateCompanionBuilder> {
  $$GpSiteInfoTableTableManager(_$Database db, $GpSiteInfoTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpSiteInfoTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpSiteInfoTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpSiteInfoTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> gpSummaryId = const d.Value.absent(),
            d.Value<String> plotCompletion = const d.Value.absent(),
            d.Value<String> incompReason = const d.Value.absent(),
            d.Value<int> ecozone = const d.Value.absent(),
            d.Value<String?> provEcoType = const d.Value.absent(),
            d.Value<int> provEcoRef = const d.Value.absent(),
            d.Value<String> postProcessing = const d.Value.absent(),
            d.Value<int> utmN = const d.Value.absent(),
            d.Value<double> utmNAccuracy = const d.Value.absent(),
            d.Value<int> utmE = const d.Value.absent(),
            d.Value<double> utmEAccuracy = const d.Value.absent(),
            d.Value<int> utmZone = const d.Value.absent(),
            d.Value<int> slope = const d.Value.absent(),
            d.Value<int> aspect = const d.Value.absent(),
            d.Value<int> elevation = const d.Value.absent(),
            d.Value<String> landBase = const d.Value.absent(),
            d.Value<String> landCover = const d.Value.absent(),
            d.Value<String> landPos = const d.Value.absent(),
            d.Value<String> vegType = const d.Value.absent(),
            d.Value<String> densityCl = const d.Value.absent(),
            d.Value<String> standStru = const d.Value.absent(),
            d.Value<String> succStage = const d.Value.absent(),
            d.Value<String> wetlandClass = const d.Value.absent(),
            d.Value<String?> userInfo = const d.Value.absent(),
            d.Value<String> gpsMake = const d.Value.absent(),
            d.Value<String> gpsModel = const d.Value.absent(),
            d.Value<int> gpsPoint = const d.Value.absent(),
          }) =>
              GpSiteInfoCompanion(
            id: id,
            gpSummaryId: gpSummaryId,
            plotCompletion: plotCompletion,
            incompReason: incompReason,
            ecozone: ecozone,
            provEcoType: provEcoType,
            provEcoRef: provEcoRef,
            postProcessing: postProcessing,
            utmN: utmN,
            utmNAccuracy: utmNAccuracy,
            utmE: utmE,
            utmEAccuracy: utmEAccuracy,
            utmZone: utmZone,
            slope: slope,
            aspect: aspect,
            elevation: elevation,
            landBase: landBase,
            landCover: landCover,
            landPos: landPos,
            vegType: vegType,
            densityCl: densityCl,
            standStru: standStru,
            succStage: succStage,
            wetlandClass: wetlandClass,
            userInfo: userInfo,
            gpsMake: gpsMake,
            gpsModel: gpsModel,
            gpsPoint: gpsPoint,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int gpSummaryId,
            required String plotCompletion,
            required String incompReason,
            required int ecozone,
            d.Value<String?> provEcoType = const d.Value.absent(),
            required int provEcoRef,
            required String postProcessing,
            required int utmN,
            required double utmNAccuracy,
            required int utmE,
            required double utmEAccuracy,
            required int utmZone,
            required int slope,
            required int aspect,
            required int elevation,
            required String landBase,
            required String landCover,
            required String landPos,
            required String vegType,
            required String densityCl,
            required String standStru,
            required String succStage,
            required String wetlandClass,
            d.Value<String?> userInfo = const d.Value.absent(),
            required String gpsMake,
            required String gpsModel,
            required int gpsPoint,
          }) =>
              GpSiteInfoCompanion.insert(
            id: id,
            gpSummaryId: gpSummaryId,
            plotCompletion: plotCompletion,
            incompReason: incompReason,
            ecozone: ecozone,
            provEcoType: provEcoType,
            provEcoRef: provEcoRef,
            postProcessing: postProcessing,
            utmN: utmN,
            utmNAccuracy: utmNAccuracy,
            utmE: utmE,
            utmEAccuracy: utmEAccuracy,
            utmZone: utmZone,
            slope: slope,
            aspect: aspect,
            elevation: elevation,
            landBase: landBase,
            landCover: landCover,
            landPos: landPos,
            vegType: vegType,
            densityCl: densityCl,
            standStru: standStru,
            succStage: succStage,
            wetlandClass: wetlandClass,
            userInfo: userInfo,
            gpsMake: gpsMake,
            gpsModel: gpsModel,
            gpsPoint: gpsPoint,
          ),
        ));
}

class $$GpSiteInfoTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpSiteInfoTable,
    GpSiteInfoData,
    $$GpSiteInfoTableFilterComposer,
    $$GpSiteInfoTableOrderingComposer,
    $$GpSiteInfoTableProcessedTableManager,
    $$GpSiteInfoTableInsertCompanionBuilder,
    $$GpSiteInfoTableUpdateCompanionBuilder> {
  $$GpSiteInfoTableProcessedTableManager(super.$state);
}

class $$GpSiteInfoTableFilterComposer
    extends d.FilterComposer<_$Database, $GpSiteInfoTable> {
  $$GpSiteInfoTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get plotCompletion => $state.composableBuilder(
      column: $state.table.plotCompletion,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get incompReason => $state.composableBuilder(
      column: $state.table.incompReason,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get ecozone => $state.composableBuilder(
      column: $state.table.ecozone,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get provEcoType => $state.composableBuilder(
      column: $state.table.provEcoType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get provEcoRef => $state.composableBuilder(
      column: $state.table.provEcoRef,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get postProcessing => $state.composableBuilder(
      column: $state.table.postProcessing,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get utmN => $state.composableBuilder(
      column: $state.table.utmN,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get utmNAccuracy => $state.composableBuilder(
      column: $state.table.utmNAccuracy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get utmE => $state.composableBuilder(
      column: $state.table.utmE,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<double> get utmEAccuracy => $state.composableBuilder(
      column: $state.table.utmEAccuracy,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get utmZone => $state.composableBuilder(
      column: $state.table.utmZone,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get slope => $state.composableBuilder(
      column: $state.table.slope,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get aspect => $state.composableBuilder(
      column: $state.table.aspect,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get elevation => $state.composableBuilder(
      column: $state.table.elevation,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get landBase => $state.composableBuilder(
      column: $state.table.landBase,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get landCover => $state.composableBuilder(
      column: $state.table.landCover,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get landPos => $state.composableBuilder(
      column: $state.table.landPos,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get vegType => $state.composableBuilder(
      column: $state.table.vegType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get densityCl => $state.composableBuilder(
      column: $state.table.densityCl,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get standStru => $state.composableBuilder(
      column: $state.table.standStru,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get succStage => $state.composableBuilder(
      column: $state.table.succStage,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get wetlandClass => $state.composableBuilder(
      column: $state.table.wetlandClass,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get userInfo => $state.composableBuilder(
      column: $state.table.userInfo,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get gpsMake => $state.composableBuilder(
      column: $state.table.gpsMake,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get gpsModel => $state.composableBuilder(
      column: $state.table.gpsModel,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get gpsPoint => $state.composableBuilder(
      column: $state.table.gpsPoint,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$GpSummaryTableFilterComposer get gpSummaryId {
    final $$GpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$GpSiteInfoTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpSiteInfoTable> {
  $$GpSiteInfoTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get plotCompletion => $state.composableBuilder(
      column: $state.table.plotCompletion,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get incompReason => $state.composableBuilder(
      column: $state.table.incompReason,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get ecozone => $state.composableBuilder(
      column: $state.table.ecozone,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get provEcoType => $state.composableBuilder(
      column: $state.table.provEcoType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get provEcoRef => $state.composableBuilder(
      column: $state.table.provEcoRef,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get postProcessing => $state.composableBuilder(
      column: $state.table.postProcessing,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get utmN => $state.composableBuilder(
      column: $state.table.utmN,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get utmNAccuracy => $state.composableBuilder(
      column: $state.table.utmNAccuracy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get utmE => $state.composableBuilder(
      column: $state.table.utmE,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<double> get utmEAccuracy => $state.composableBuilder(
      column: $state.table.utmEAccuracy,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get utmZone => $state.composableBuilder(
      column: $state.table.utmZone,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get slope => $state.composableBuilder(
      column: $state.table.slope,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get aspect => $state.composableBuilder(
      column: $state.table.aspect,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get elevation => $state.composableBuilder(
      column: $state.table.elevation,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get landBase => $state.composableBuilder(
      column: $state.table.landBase,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get landCover => $state.composableBuilder(
      column: $state.table.landCover,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get landPos => $state.composableBuilder(
      column: $state.table.landPos,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get vegType => $state.composableBuilder(
      column: $state.table.vegType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get densityCl => $state.composableBuilder(
      column: $state.table.densityCl,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get standStru => $state.composableBuilder(
      column: $state.table.standStru,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get succStage => $state.composableBuilder(
      column: $state.table.succStage,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get wetlandClass => $state.composableBuilder(
      column: $state.table.wetlandClass,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get userInfo => $state.composableBuilder(
      column: $state.table.userInfo,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get gpsMake => $state.composableBuilder(
      column: $state.table.gpsMake,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get gpsModel => $state.composableBuilder(
      column: $state.table.gpsModel,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get gpsPoint => $state.composableBuilder(
      column: $state.table.gpsPoint,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$GpSummaryTableOrderingComposer get gpSummaryId {
    final $$GpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$GpDisturbanceTableInsertCompanionBuilder = GpDisturbanceCompanion
    Function({
  d.Value<int> id,
  required int gpSummaryId,
  required String distAgent,
  required int distYr,
  required int distPct,
  required int mortPct,
  required String mortBasis,
  d.Value<String?> agentType,
});
typedef $$GpDisturbanceTableUpdateCompanionBuilder = GpDisturbanceCompanion
    Function({
  d.Value<int> id,
  d.Value<int> gpSummaryId,
  d.Value<String> distAgent,
  d.Value<int> distYr,
  d.Value<int> distPct,
  d.Value<int> mortPct,
  d.Value<String> mortBasis,
  d.Value<String?> agentType,
});

class $$GpDisturbanceTableTableManager extends d.RootTableManager<
    _$Database,
    $GpDisturbanceTable,
    GpDisturbanceData,
    $$GpDisturbanceTableFilterComposer,
    $$GpDisturbanceTableOrderingComposer,
    $$GpDisturbanceTableProcessedTableManager,
    $$GpDisturbanceTableInsertCompanionBuilder,
    $$GpDisturbanceTableUpdateCompanionBuilder> {
  $$GpDisturbanceTableTableManager(_$Database db, $GpDisturbanceTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpDisturbanceTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpDisturbanceTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpDisturbanceTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> gpSummaryId = const d.Value.absent(),
            d.Value<String> distAgent = const d.Value.absent(),
            d.Value<int> distYr = const d.Value.absent(),
            d.Value<int> distPct = const d.Value.absent(),
            d.Value<int> mortPct = const d.Value.absent(),
            d.Value<String> mortBasis = const d.Value.absent(),
            d.Value<String?> agentType = const d.Value.absent(),
          }) =>
              GpDisturbanceCompanion(
            id: id,
            gpSummaryId: gpSummaryId,
            distAgent: distAgent,
            distYr: distYr,
            distPct: distPct,
            mortPct: mortPct,
            mortBasis: mortBasis,
            agentType: agentType,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int gpSummaryId,
            required String distAgent,
            required int distYr,
            required int distPct,
            required int mortPct,
            required String mortBasis,
            d.Value<String?> agentType = const d.Value.absent(),
          }) =>
              GpDisturbanceCompanion.insert(
            id: id,
            gpSummaryId: gpSummaryId,
            distAgent: distAgent,
            distYr: distYr,
            distPct: distPct,
            mortPct: mortPct,
            mortBasis: mortBasis,
            agentType: agentType,
          ),
        ));
}

class $$GpDisturbanceTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpDisturbanceTable,
    GpDisturbanceData,
    $$GpDisturbanceTableFilterComposer,
    $$GpDisturbanceTableOrderingComposer,
    $$GpDisturbanceTableProcessedTableManager,
    $$GpDisturbanceTableInsertCompanionBuilder,
    $$GpDisturbanceTableUpdateCompanionBuilder> {
  $$GpDisturbanceTableProcessedTableManager(super.$state);
}

class $$GpDisturbanceTableFilterComposer
    extends d.FilterComposer<_$Database, $GpDisturbanceTable> {
  $$GpDisturbanceTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get distAgent => $state.composableBuilder(
      column: $state.table.distAgent,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get distYr => $state.composableBuilder(
      column: $state.table.distYr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get distPct => $state.composableBuilder(
      column: $state.table.distPct,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get mortPct => $state.composableBuilder(
      column: $state.table.mortPct,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get mortBasis => $state.composableBuilder(
      column: $state.table.mortBasis,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get agentType => $state.composableBuilder(
      column: $state.table.agentType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$GpSummaryTableFilterComposer get gpSummaryId {
    final $$GpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$GpDisturbanceTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpDisturbanceTable> {
  $$GpDisturbanceTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get distAgent => $state.composableBuilder(
      column: $state.table.distAgent,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get distYr => $state.composableBuilder(
      column: $state.table.distYr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get distPct => $state.composableBuilder(
      column: $state.table.distPct,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get mortPct => $state.composableBuilder(
      column: $state.table.mortPct,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get mortBasis => $state.composableBuilder(
      column: $state.table.mortBasis,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get agentType => $state.composableBuilder(
      column: $state.table.agentType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$GpSummaryTableOrderingComposer get gpSummaryId {
    final $$GpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$GpOriginTableInsertCompanionBuilder = GpOriginCompanion Function({
  d.Value<int> id,
  required int gpSummaryId,
  required String vegOrig,
  required String regenType,
  required int regenYr,
});
typedef $$GpOriginTableUpdateCompanionBuilder = GpOriginCompanion Function({
  d.Value<int> id,
  d.Value<int> gpSummaryId,
  d.Value<String> vegOrig,
  d.Value<String> regenType,
  d.Value<int> regenYr,
});

class $$GpOriginTableTableManager extends d.RootTableManager<
    _$Database,
    $GpOriginTable,
    GpOriginData,
    $$GpOriginTableFilterComposer,
    $$GpOriginTableOrderingComposer,
    $$GpOriginTableProcessedTableManager,
    $$GpOriginTableInsertCompanionBuilder,
    $$GpOriginTableUpdateCompanionBuilder> {
  $$GpOriginTableTableManager(_$Database db, $GpOriginTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpOriginTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpOriginTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpOriginTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> gpSummaryId = const d.Value.absent(),
            d.Value<String> vegOrig = const d.Value.absent(),
            d.Value<String> regenType = const d.Value.absent(),
            d.Value<int> regenYr = const d.Value.absent(),
          }) =>
              GpOriginCompanion(
            id: id,
            gpSummaryId: gpSummaryId,
            vegOrig: vegOrig,
            regenType: regenType,
            regenYr: regenYr,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int gpSummaryId,
            required String vegOrig,
            required String regenType,
            required int regenYr,
          }) =>
              GpOriginCompanion.insert(
            id: id,
            gpSummaryId: gpSummaryId,
            vegOrig: vegOrig,
            regenType: regenType,
            regenYr: regenYr,
          ),
        ));
}

class $$GpOriginTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpOriginTable,
    GpOriginData,
    $$GpOriginTableFilterComposer,
    $$GpOriginTableOrderingComposer,
    $$GpOriginTableProcessedTableManager,
    $$GpOriginTableInsertCompanionBuilder,
    $$GpOriginTableUpdateCompanionBuilder> {
  $$GpOriginTableProcessedTableManager(super.$state);
}

class $$GpOriginTableFilterComposer
    extends d.FilterComposer<_$Database, $GpOriginTable> {
  $$GpOriginTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get vegOrig => $state.composableBuilder(
      column: $state.table.vegOrig,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get regenType => $state.composableBuilder(
      column: $state.table.regenType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get regenYr => $state.composableBuilder(
      column: $state.table.regenYr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$GpSummaryTableFilterComposer get gpSummaryId {
    final $$GpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$GpOriginTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpOriginTable> {
  $$GpOriginTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get vegOrig => $state.composableBuilder(
      column: $state.table.vegOrig,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get regenType => $state.composableBuilder(
      column: $state.table.regenType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get regenYr => $state.composableBuilder(
      column: $state.table.regenYr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$GpSummaryTableOrderingComposer get gpSummaryId {
    final $$GpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

typedef $$GpTreatmentTableInsertCompanionBuilder = GpTreatmentCompanion
    Function({
  d.Value<int> id,
  required int gpSummaryId,
  required String treatType,
  required int treatYr,
  required int treatPct,
});
typedef $$GpTreatmentTableUpdateCompanionBuilder = GpTreatmentCompanion
    Function({
  d.Value<int> id,
  d.Value<int> gpSummaryId,
  d.Value<String> treatType,
  d.Value<int> treatYr,
  d.Value<int> treatPct,
});

class $$GpTreatmentTableTableManager extends d.RootTableManager<
    _$Database,
    $GpTreatmentTable,
    GpTreatmentData,
    $$GpTreatmentTableFilterComposer,
    $$GpTreatmentTableOrderingComposer,
    $$GpTreatmentTableProcessedTableManager,
    $$GpTreatmentTableInsertCompanionBuilder,
    $$GpTreatmentTableUpdateCompanionBuilder> {
  $$GpTreatmentTableTableManager(_$Database db, $GpTreatmentTable table)
      : super(d.TableManagerState(
          db: db,
          table: table,
          filteringComposer:
              $$GpTreatmentTableFilterComposer(d.ComposerState(db, table)),
          orderingComposer:
              $$GpTreatmentTableOrderingComposer(d.ComposerState(db, table)),
          getChildManagerBuilder: (p) =>
              $$GpTreatmentTableProcessedTableManager(p),
          getUpdateCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            d.Value<int> gpSummaryId = const d.Value.absent(),
            d.Value<String> treatType = const d.Value.absent(),
            d.Value<int> treatYr = const d.Value.absent(),
            d.Value<int> treatPct = const d.Value.absent(),
          }) =>
              GpTreatmentCompanion(
            id: id,
            gpSummaryId: gpSummaryId,
            treatType: treatType,
            treatYr: treatYr,
            treatPct: treatPct,
          ),
          getInsertCompanionBuilder: ({
            d.Value<int> id = const d.Value.absent(),
            required int gpSummaryId,
            required String treatType,
            required int treatYr,
            required int treatPct,
          }) =>
              GpTreatmentCompanion.insert(
            id: id,
            gpSummaryId: gpSummaryId,
            treatType: treatType,
            treatYr: treatYr,
            treatPct: treatPct,
          ),
        ));
}

class $$GpTreatmentTableProcessedTableManager extends d.ProcessedTableManager<
    _$Database,
    $GpTreatmentTable,
    GpTreatmentData,
    $$GpTreatmentTableFilterComposer,
    $$GpTreatmentTableOrderingComposer,
    $$GpTreatmentTableProcessedTableManager,
    $$GpTreatmentTableInsertCompanionBuilder,
    $$GpTreatmentTableUpdateCompanionBuilder> {
  $$GpTreatmentTableProcessedTableManager(super.$state);
}

class $$GpTreatmentTableFilterComposer
    extends d.FilterComposer<_$Database, $GpTreatmentTable> {
  $$GpTreatmentTableFilterComposer(super.$state);
  d.ColumnFilters<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<String> get treatType => $state.composableBuilder(
      column: $state.table.treatType,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treatYr => $state.composableBuilder(
      column: $state.table.treatYr,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  d.ColumnFilters<int> get treatPct => $state.composableBuilder(
      column: $state.table.treatPct,
      builder: (column, joinBuilders) =>
          d.ColumnFilters(column, joinBuilders: joinBuilders));

  $$GpSummaryTableFilterComposer get gpSummaryId {
    final $$GpSummaryTableFilterComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableFilterComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class $$GpTreatmentTableOrderingComposer
    extends d.OrderingComposer<_$Database, $GpTreatmentTable> {
  $$GpTreatmentTableOrderingComposer(super.$state);
  d.ColumnOrderings<int> get id => $state.composableBuilder(
      column: $state.table.id,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<String> get treatType => $state.composableBuilder(
      column: $state.table.treatType,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treatYr => $state.composableBuilder(
      column: $state.table.treatYr,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  d.ColumnOrderings<int> get treatPct => $state.composableBuilder(
      column: $state.table.treatPct,
      builder: (column, joinBuilders) =>
          d.ColumnOrderings(column, joinBuilders: joinBuilders));

  $$GpSummaryTableOrderingComposer get gpSummaryId {
    final $$GpSummaryTableOrderingComposer composer = $state.composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.gpSummaryId,
        referencedTable: $state.db.gpSummary,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder, parentComposers) =>
            $$GpSummaryTableOrderingComposer(d.ComposerState(
                $state.db, $state.db.gpSummary, joinBuilder, parentComposers)));
    return composer;
  }
}

class _$DatabaseManager {
  final _$Database _db;
  _$DatabaseManager(this._db);
  $$JurisdictionsTableTableManager get jurisdictions =>
      $$JurisdictionsTableTableManager(_db, _db.jurisdictions);
  $$PlotsTableTableManager get plots =>
      $$PlotsTableTableManager(_db, _db.plots);
  $$TreeGenusTableTableManager get treeGenus =>
      $$TreeGenusTableTableManager(_db, _db.treeGenus);
  $$SubstrateTypeTableTableManager get substrateType =>
      $$SubstrateTypeTableTableManager(_db, _db.substrateType);
  $$SsDepthLimitTableTableManager get ssDepthLimit =>
      $$SsDepthLimitTableTableManager(_db, _db.ssDepthLimit);
  $$EcpGenusTableTableManager get ecpGenus =>
      $$EcpGenusTableTableManager(_db, _db.ecpGenus);
  $$EcpLayerTableTableManager get ecpLayer =>
      $$EcpLayerTableTableManager(_db, _db.ecpLayer);
  $$EcpPlotTypeTableTableManager get ecpPlotType =>
      $$EcpPlotTypeTableTableManager(_db, _db.ecpPlotType);
  $$SoilPitClassificationTableTableManager get soilPitClassification =>
      $$SoilPitClassificationTableTableManager(_db, _db.soilPitClassification);
  $$SoilDrainageClassTableTableManager get soilDrainageClass =>
      $$SoilDrainageClassTableTableManager(_db, _db.soilDrainageClass);
  $$SoilMoistureClassTableTableManager get soilMoistureClass =>
      $$SoilMoistureClassTableTableManager(_db, _db.soilMoistureClass);
  $$SoilDepositionTableTableManager get soilDeposition =>
      $$SoilDepositionTableTableManager(_db, _db.soilDeposition);
  $$SoilHumusFormTableTableManager get soilHumusForm =>
      $$SoilHumusFormTableTableManager(_db, _db.soilHumusForm);
  $$SoilPitCodeTableTableManager get soilPitCode =>
      $$SoilPitCodeTableTableManager(_db, _db.soilPitCode);
  $$SoilPitFeatureClassTableTableManager get soilPitFeatureClass =>
      $$SoilPitFeatureClassTableTableManager(_db, _db.soilPitFeatureClass);
  $$SoilHorizonDesignationTableTableManager get soilHorizonDesignation =>
      $$SoilHorizonDesignationTableTableManager(
          _db, _db.soilHorizonDesignation);
  $$SoilColorTableTableManager get soilColor =>
      $$SoilColorTableTableManager(_db, _db.soilColor);
  $$SoilTextureTableTableManager get soilTexture =>
      $$SoilTextureTableTableManager(_db, _db.soilTexture);
  $$StpTypeTableTableManager get stpType =>
      $$StpTypeTableTableManager(_db, _db.stpType);
  $$StpOrigPlotAreaTableTableManager get stpOrigPlotArea =>
      $$StpOrigPlotAreaTableTableManager(_db, _db.stpOrigPlotArea);
  $$StpStatusFieldTableTableManager get stpStatusField =>
      $$StpStatusFieldTableTableManager(_db, _db.stpStatusField);
  $$StpHeightTableTableManager get stpHeight =>
      $$StpHeightTableTableManager(_db, _db.stpHeight);
  $$StpStemConditionTableTableManager get stpStemCondition =>
      $$StpStemConditionTableTableManager(_db, _db.stpStemCondition);
  $$ShrubPlotTypeTableTableManager get shrubPlotType =>
      $$ShrubPlotTypeTableTableManager(_db, _db.shrubPlotType);
  $$ShrubStatusFieldTableTableManager get shrubStatusField =>
      $$ShrubStatusFieldTableTableManager(_db, _db.shrubStatusField);
  $$ShrubBasalDiameterTableTableManager get shrubBasalDiameter =>
      $$ShrubBasalDiameterTableTableManager(_db, _db.shrubBasalDiameter);
  $$StumpPlotTypeTableTableManager get stumpPlotType =>
      $$StumpPlotTypeTableTableManager(_db, _db.stumpPlotType);
  $$StumpOrigPlotAreaTableTableManager get stumpOrigPlotArea =>
      $$StumpOrigPlotAreaTableTableManager(_db, _db.stumpOrigPlotArea);
  $$LtpPlotTypeTableTableManager get ltpPlotType =>
      $$LtpPlotTypeTableTableManager(_db, _db.ltpPlotType);
  $$LtpPlotSplitTableTableManager get ltpPlotSplit =>
      $$LtpPlotSplitTableTableManager(_db, _db.ltpPlotSplit);
  $$LtpOrigPlotAreaTableTableManager get ltpOrigPlotArea =>
      $$LtpOrigPlotAreaTableTableManager(_db, _db.ltpOrigPlotArea);
  $$LtpStatusFieldTableTableManager get ltpStatusField =>
      $$LtpStatusFieldTableTableManager(_db, _db.ltpStatusField);
  $$LtpGenusTableTableManager get ltpGenus =>
      $$LtpGenusTableTableManager(_db, _db.ltpGenus);
  $$LtpCrownClassFieldTableTableManager get ltpCrownClassField =>
      $$LtpCrownClassFieldTableTableManager(_db, _db.ltpCrownClassField);
  $$LtpBarkConditionTableTableManager get ltpBarkCondition =>
      $$LtpBarkConditionTableTableManager(_db, _db.ltpBarkCondition);
  $$LtpCrownConditionTableTableManager get ltpCrownCondition =>
      $$LtpCrownConditionTableTableManager(_db, _db.ltpCrownCondition);
  $$LtpStemConditionTableTableManager get ltpStemCondition =>
      $$LtpStemConditionTableTableManager(_db, _db.ltpStemCondition);
  $$LtpWoodConditionTableTableManager get ltpWoodCondition =>
      $$LtpWoodConditionTableTableManager(_db, _db.ltpWoodCondition);
  $$LtpQuadrantTableTableManager get ltpQuadrant =>
      $$LtpQuadrantTableTableManager(_db, _db.ltpQuadrant);
  $$LtpTreeTypeTableTableManager get ltpTreeType =>
      $$LtpTreeTypeTableTableManager(_db, _db.ltpTreeType);
  $$LtpSiteHeightSuitabilityTableTableManager get ltpSiteHeightSuitability =>
      $$LtpSiteHeightSuitabilityTableTableManager(
          _db, _db.ltpSiteHeightSuitability);
  $$LtpSiteAgeSuitabilityTableTableManager get ltpSiteAgeSuitability =>
      $$LtpSiteAgeSuitabilityTableTableManager(_db, _db.ltpSiteAgeSuitability);
  $$LtpProrateTableTableManager get ltpProrate =>
      $$LtpProrateTableTableManager(_db, _db.ltpProrate);
  $$GpSiteInfoStandStructureTableTableManager get gpSiteInfoStandStructure =>
      $$GpSiteInfoStandStructureTableTableManager(
          _db, _db.gpSiteInfoStandStructure);
  $$GpSiteInfoSuccessionStageTableTableManager get gpSiteInfoSuccessionStage =>
      $$GpSiteInfoSuccessionStageTableTableManager(
          _db, _db.gpSiteInfoSuccessionStage);
  $$GpSiteInfoUtmZoneTableTableManager get gpSiteInfoUtmZone =>
      $$GpSiteInfoUtmZoneTableTableManager(_db, _db.gpSiteInfoUtmZone);
  $$GpSiteInfoVegTypeTableTableManager get gpSiteInfoVegType =>
      $$GpSiteInfoVegTypeTableTableManager(_db, _db.gpSiteInfoVegType);
  $$GpSiteInfoWetlandTableTableManager get gpSiteInfoWetland =>
      $$GpSiteInfoWetlandTableTableManager(_db, _db.gpSiteInfoWetland);
  $$GpSiteInfoEcozoneTableTableManager get gpSiteInfoEcozone =>
      $$GpSiteInfoEcozoneTableTableManager(_db, _db.gpSiteInfoEcozone);
  $$GpSiteInfoPlotCompletionTableTableManager get gpSiteInfoPlotCompletion =>
      $$GpSiteInfoPlotCompletionTableTableManager(
          _db, _db.gpSiteInfoPlotCompletion);
  $$GpSiteInfoDensityTableTableManager get gpSiteInfoDensity =>
      $$GpSiteInfoDensityTableTableManager(_db, _db.gpSiteInfoDensity);
  $$GpSiteInfoLandBaseTableTableManager get gpSiteInfoLandBase =>
      $$GpSiteInfoLandBaseTableTableManager(_db, _db.gpSiteInfoLandBase);
  $$GpSiteInfoLandCoverTableTableManager get gpSiteInfoLandCover =>
      $$GpSiteInfoLandCoverTableTableManager(_db, _db.gpSiteInfoLandCover);
  $$GpSiteInfoLandPosTableTableManager get gpSiteInfoLandPos =>
      $$GpSiteInfoLandPosTableTableManager(_db, _db.gpSiteInfoLandPos);
  $$GpSiteInfoPostProcessingTableTableManager get gpSiteInfoPostProcessing =>
      $$GpSiteInfoPostProcessingTableTableManager(
          _db, _db.gpSiteInfoPostProcessing);
  $$GpSiteInfoPlotIncompleteReasonTableTableManager
      get gpSiteInfoPlotIncompleteReason =>
          $$GpSiteInfoPlotIncompleteReasonTableTableManager(
              _db, _db.gpSiteInfoPlotIncompleteReason);
  $$GpDistAgentTableTableManager get gpDistAgent =>
      $$GpDistAgentTableTableManager(_db, _db.gpDistAgent);
  $$SurveyHeadersTableTableManager get surveyHeaders =>
      $$SurveyHeadersTableTableManager(_db, _db.surveyHeaders);
  $$MetaCommentTableTableManager get metaComment =>
      $$MetaCommentTableTableManager(_db, _db.metaComment);
  $$SurveySummaryTableTableManager get surveySummary =>
      $$SurveySummaryTableTableManager(_db, _db.surveySummary);
  $$SurveyHeaderGroundPhotoTableTableManager get surveyHeaderGroundPhoto =>
      $$SurveyHeaderGroundPhotoTableTableManager(
          _db, _db.surveyHeaderGroundPhoto);
  $$SurveyHeaderTreeTableTableManager get surveyHeaderTree =>
      $$SurveyHeaderTreeTableTableManager(_db, _db.surveyHeaderTree);
  $$SurveyHeaderEcologicalTableTableManager get surveyHeaderEcological =>
      $$SurveyHeaderEcologicalTableTableManager(
          _db, _db.surveyHeaderEcological);
  $$SurveyHeaderSoilTableTableManager get surveyHeaderSoil =>
      $$SurveyHeaderSoilTableTableManager(_db, _db.surveyHeaderSoil);
  $$WoodyDebrisSummaryTableTableManager get woodyDebrisSummary =>
      $$WoodyDebrisSummaryTableTableManager(_db, _db.woodyDebrisSummary);
  $$WoodyDebrisHeaderTableTableManager get woodyDebrisHeader =>
      $$WoodyDebrisHeaderTableTableManager(_db, _db.woodyDebrisHeader);
  $$WoodyDebrisSmallTableTableManager get woodyDebrisSmall =>
      $$WoodyDebrisSmallTableTableManager(_db, _db.woodyDebrisSmall);
  $$WoodyDebrisOddTableTableManager get woodyDebrisOdd =>
      $$WoodyDebrisOddTableTableManager(_db, _db.woodyDebrisOdd);
  $$WoodyDebrisRoundTableTableManager get woodyDebrisRound =>
      $$WoodyDebrisRoundTableTableManager(_db, _db.woodyDebrisRound);
  $$SurfaceSubstrateSummaryTableTableManager get surfaceSubstrateSummary =>
      $$SurfaceSubstrateSummaryTableTableManager(
          _db, _db.surfaceSubstrateSummary);
  $$SurfaceSubstrateHeaderTableTableManager get surfaceSubstrateHeader =>
      $$SurfaceSubstrateHeaderTableTableManager(
          _db, _db.surfaceSubstrateHeader);
  $$SurfaceSubstrateTallyTableTableManager get surfaceSubstrateTally =>
      $$SurfaceSubstrateTallyTableTableManager(_db, _db.surfaceSubstrateTally);
  $$EcpSummaryTableTableManager get ecpSummary =>
      $$EcpSummaryTableTableManager(_db, _db.ecpSummary);
  $$EcpHeaderTableTableManager get ecpHeader =>
      $$EcpHeaderTableTableManager(_db, _db.ecpHeader);
  $$EcpSpeciesTableTableManager get ecpSpecies =>
      $$EcpSpeciesTableTableManager(_db, _db.ecpSpecies);
  $$SoilPitSummaryTableTableManager get soilPitSummary =>
      $$SoilPitSummaryTableTableManager(_db, _db.soilPitSummary);
  $$SoilSiteInfoTableTableManager get soilSiteInfo =>
      $$SoilSiteInfoTableTableManager(_db, _db.soilSiteInfo);
  $$SoilPitFeatureTableTableManager get soilPitFeature =>
      $$SoilPitFeatureTableTableManager(_db, _db.soilPitFeature);
  $$SoilPitHorizonDescriptionTableTableManager get soilPitHorizonDescription =>
      $$SoilPitHorizonDescriptionTableTableManager(
          _db, _db.soilPitHorizonDescription);
  $$LtpSummaryTableTableManager get ltpSummary =>
      $$LtpSummaryTableTableManager(_db, _db.ltpSummary);
  $$LtpTreeTableTableManager get ltpTree =>
      $$LtpTreeTableTableManager(_db, _db.ltpTree);
  $$LtpTreeDamageTableTableManager get ltpTreeDamage =>
      $$LtpTreeDamageTableTableManager(_db, _db.ltpTreeDamage);
  $$LtpTreeRemovedTableTableManager get ltpTreeRemoved =>
      $$LtpTreeRemovedTableTableManager(_db, _db.ltpTreeRemoved);
  $$LtpTreeAgeTableTableManager get ltpTreeAge =>
      $$LtpTreeAgeTableTableManager(_db, _db.ltpTreeAge);
  $$LtpTreeRenamedTableTableManager get ltpTreeRenamed =>
      $$LtpTreeRenamedTableTableManager(_db, _db.ltpTreeRenamed);
  $$StpSummaryTableTableManager get stpSummary =>
      $$StpSummaryTableTableManager(_db, _db.stpSummary);
  $$StpSpeciesTableTableManager get stpSpecies =>
      $$StpSpeciesTableTableManager(_db, _db.stpSpecies);
  $$ShrubSummaryTableTableManager get shrubSummary =>
      $$ShrubSummaryTableTableManager(_db, _db.shrubSummary);
  $$ShrubListEntryTableTableManager get shrubListEntry =>
      $$ShrubListEntryTableTableManager(_db, _db.shrubListEntry);
  $$StumpSummaryTableTableManager get stumpSummary =>
      $$StumpSummaryTableTableManager(_db, _db.stumpSummary);
  $$StumpEntryTableTableManager get stumpEntry =>
      $$StumpEntryTableTableManager(_db, _db.stumpEntry);
  $$GpSummaryTableTableManager get gpSummary =>
      $$GpSummaryTableTableManager(_db, _db.gpSummary);
  $$GpSiteInfoTableTableManager get gpSiteInfo =>
      $$GpSiteInfoTableTableManager(_db, _db.gpSiteInfo);
  $$GpDisturbanceTableTableManager get gpDisturbance =>
      $$GpDisturbanceTableTableManager(_db, _db.gpDisturbance);
  $$GpOriginTableTableManager get gpOrigin =>
      $$GpOriginTableTableManager(_db, _db.gpOrigin);
  $$GpTreatmentTableTableManager get gpTreatment =>
      $$GpTreatmentTableTableManager(_db, _db.gpTreatment);
}
